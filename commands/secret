#!/usr/bin/env bash

# NOTE:
# do not use the `ok` command instead of `|| :` â€” this file uses functions, and the `ok` command only works with commands

function secret() (
	source "$DOROTHY/sources/bash.bash"
	require_nullglob
	require_array 'mapfile' 'empty'

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper for 1password, allowing you to invoke applications with secrets securely.

			ACTIONS:
			install
			    The 1Password CLI tool will be installed upfront if it does not exist, however this command forces its upgrade.

			login|signin

			    Authenticate with the 1Password CLI tool.
			    If using 1Password CLI v1, sessions expire quickly for security, so this is occassionally required.
			    If using 1Password CLI v2 with Biometric security, this is rarely required.

			logout|signout

			    Invalidates your current authentication with the 1Password CLI tool.

			map <secret> [vault] [item] [field]

			    Map a secret to a specific 1Password vault, item, and field.

			    For example:

			        secret map MY_SECRET

			        Will ask you which of your vaults you would like to use,
			        then ask you which item inside that vault you would like to use,
			        then ask you which field inside that item you would like to use,
			        then it will map the MY_SECRET secret to that specification.

			        Once done, this enables:

			        secret get MY_SECRET
			        secret env MY_SECRET -- echo 'my secret is: \$MY_SECRET'

			get <secret>

			    Get the value of what the secret maps to,
			    from the cache if possible, otherwise from 1Password's API if signed in.

			env <secret...> -- <command> [args...]

			    Gets the value of the secret(s) and passes them as configured environment variables to solely the command.
			    This prevents exposing your secrets to your general shell, your shell history, and unauthorised commands,
			    as with this, only the command you intend to run is given the secrets.

			    For example:

			        secret env MY_SECRET -- echo 'my secret is: \$MY_SECRET'

			        Will get the value of MY_SECRET, and provide it to the echo command's environment
			        such that when it is interpolated into

			            echo my secret is: \$MY_SECRET

			        \$MY_SECRET will be exist in that environment, and be outputted accordingly.

			unmap <secret>

			    Removes the mapping for the secret, such that its shorthand can no longer be fetched.

			invalidate [secret]

			    If a the secret argument was provided, then that secret alone will be cleared from the cache.
			    If no argument is provided, then all cached secrets will be cleared.

			fetch [vault] [item] [field]

			    Fetches the value of a field, from an item, from a 1Password vault.
			    If an argument is missing, you will be prompted to select its value from the available options.
			    Arguments can be partial values (for filtering), and can be the label or value.
			    Labels for vaults and items are converted to the UUID, to avoid conflicts against ambiguous names.
			    Results will be cached until they are invalidated by \`secret invalidate <secret>\`
			        or unmapped by \`secret unmap <secret>\`.

			    For example:

			        secret fetch

			            Will ask you which of your vaults to use,
			            then ask you which item inside that vault to use,
			            then ask you which field inside that item to fetch the value for.

			https

			    Update all the login URLs in your 1Password vault to use HTTPS if they support it,
			    otherwise attempt several variations and use what does work,
			    and if nothing works, then advise that the service appears unresponsive and is likely ready for archiving.

			help

			    Output this help message.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# process
	local item action='' args=() option_conceal='no' option_quiet
	option_quiet="$(echo-quiet -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-conceal'* | '--conceal'*)
			option_conceal="$(
				get-flag-value conceal --missing="$option_conceal" -- "$item" | echo-affirmative
			)"
			;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		*)
			if test -z "$action"; then
				action="$item"
			else
				args+=("$item")
			fi
			;;
		esac
	done

	# =====================================
	# Dependencies

	setup-util-jq --quiet
	if command-missing op; then
		setup-util-1password-cli --quiet
	fi

	# check compatibility
	local op_version
	op_version="$(op --version)"
	if test "$(version-compare "$op_version" 1)" -eq 0; then
		# https://developer.1password.com/docs/cli/v1/reference
		op_version=1
	elif test "$(version-compare "$op_version" 2)" -eq 0; then
		# https://developer.1password.com/docs/cli/upgrade
		# https://developer.1password.com/docs/cli/upgrade#step-2-update-your-scripts
		op_version=2
	else
		help "Unsupported 1Password CLI version: $op_version"
	fi

	# =====================================
	# Adjustments

	local actions=(
		'install'
		'login'
		'logout'
		'map'
		'env'
		'get'
		'invalidate'
		'unmap'
		'fetch'
		'https'
		'help'
	)
	action="$(
		choose-option \
			--question='What action do you wish to take?' \
			--filter="$action" -- "${actions[@]}"
	)"

	# =====================================
	# Configuration

	# database
	local database="$DOROTHY/user/config.local/secrets.json"
	function correct_database_permission {
		sudo chown "$USER" "$database"
		sudo chmod 600 "$database"
	}
	function correct_key_permission {
		local state_key="$1"
		sudo chown root: "$state_key"
		sudo chmod 600 "$state_key"
	}
	if ! sudo test -f "$database"; then
		echo '{}' | sudo tee "$database" &>/dev/null
	fi
	correct_database_permission

	# move old state location to new state location
	local state="$XDG_STATE_HOME/secrets"
	if test -d "$DOROTHY/user/secrets"; then
		mv -v "$DOROTHY/user/secrets" "$state"
	fi
	mkdir -p "$state"

	# prepare
	export OP_SESSION='' OP_SUBDOMAIN=''

	# conceal
	local ask_password_arguments=()
	if test "$option_conceal" = 'yes'; then
		ask_password_arguments+=('--password')
	fi

	# =====================================
	# Action

	function cache_clear {
		sudo rm -Rf "$state/"*
	}

	function cache_exists {
		local key ec
		for key in "$@"; do
			ec=0 && sudo test -f "$state/$key" || ec="$?"
			if test "$ec" -ne 0; then
				return 1
			fi
		done
	}

	function cache_delete {
		local key ec
		for key in "$@"; do
			ec=0 && sudo rm -f "$state/$key" || ec="$?"
			if test "$ec" -ne 0; then
				return 1
			fi
		done
	}

	function cache_write {
		local key value
		key="$1"
		value="$2"
		cache_delete "$key"
		if is-value "$value"; then
			echo -n "$value" >"$state/$key"
			correct_key_permission "$state/$key"
		else
			echo-error "Attempted to write an empty secret key [$key]"
			return 1
		fi
	}

	function cache_read {
		local key="$1" value
		if cache_exists "$key"; then
			value="$(sudo cat "$state/$key" | tr -d '\n')"
			if is-value "$value"; then
				echo -n "$value"
			else
				echo-error "Cached secret key [$key] was empty [$value]"
				cache_delete "$key"
				return 1
			fi
		else
			echo-error "Cached secret key [$key] was missing."
			return 1
		fi
	}

	function secret_get {
		local ec key result vault item field value

		# many
		if test "$#" -gt '1'; then
			for key in "$@"; do
				ec=0 && value="$(secret_get "$key")" || ec="$?"
				if test "$ec" -ne 0; then
					echo-error "Unable to fetch the secret key [$key] of many."
					return 1
				fi
				echo "$key=$value"
			done
			return 0
		fi

		# singular
		key="$1"

		# fetch from cache
		if cache_exists "$key"; then
			cache_read "$key"
			return "$?"
		fi

		# fetch from api
		vault="$(jq -r ".${key}[0]" "$database")"
		item="$(jq -r ".${key}[1]" "$database")"
		field="$(jq -r ".${key}[2]" "$database")"
		if is-value "$vault" && is-value "$item" && is-value "$field"; then
			value="$(fetch_field "$vault" "$item" "$field")"
		else
			{
				echo-error "Key [$key] was missing all three parts of its mapping:"
				echo "vault = [$vault]"
				echo "item  = [$item]"
				echo "field = [$field]"
				echo
				echo "Manually edit the database [$database],"
				echo "or use the [secret map ...] command to set the mapping accordingly."
			} >/dev/stderr
			return 1
		fi
		if is-empty-value "$value"; then
			echo-error "Key [$key] failed to resolve."
			return 1
		fi
		cache_write "$key" "$value"
		echo -n "$value"
	}

	# secret_signout [--quiet]
	# [--quiet] used when its operation is secondary to another
	function secret_signout {
		local quiet
		quiet="$(echo-quiet "$option_quiet" -- "$@")"
		if test "$quiet" != 'yes'; then
			echo 'Unauthenticating...'
		fi
		if test -z "${OP_SESSION-}"; then
			if cache_exists "OP_SESSION"; then
				OP_SESSION="$(cache_read OP_SESSION)"
				if test "$op_version" -eq 2; then
					op signout --session "$OP_SESSION" 2>&1 || :
				else
					op signout --session="$OP_SESSION" 2>&1 || :
				fi
			fi
		else
			if test "$op_version" -eq 2; then
				op signout --session "$OP_SESSION" 2>&1 || :
			else
				op signout --session="$OP_SESSION" 2>&1 || :
			fi
		fi
		cache_delete "OP_SESSION"
		cache_delete "OP_SUBDOMAIN"
		OP_SESSION=''
		if test "$quiet" != 'yes'; then
			echo 'Unauthenticated.'
		fi
	}

	# secret_signin [--quiet]
	# [--quiet] used when its operation is secondary to another
	# trunk-ignore(shellcheck/SC2120)
	function secret_signin {
		local quiet email key ec
		quiet="$(echo-quiet "$option_quiet" -- "$@")"
		# session
		if test "$quiet" != 'yes'; then
			echo 'Authenticating...'
		fi
		if test -z "${OP_SESSION-}"; then
			OP_SESSION="$( (cache_exists OP_SESSION && cache_read OP_SESSION) || :)"
			if test -z "$OP_SESSION"; then
				# subdomain
				if test -z "${OP_SUBDOMAIN-}"; then
					OP_SUBDOMAIN="$( (cache_exists OP_SUBDOMAIN && cache_read OP_SUBDOMAIN) || :)"
					if test -z "${OP_SUBDOMAIN-}"; then
						OP_SUBDOMAIN="$(
							ask --required "${ask_password_arguments[@]}" \
								--question='What is your 1password subdomain?'
						)"
						cache_write "OP_SUBDOMAIN" "$OP_SUBDOMAIN"
					fi
				fi
				email="$(
					ask --required "${ask_password_arguments[@]}" \
						--question='What is your 1password email? This is not stored.'
				)"
				if test "$op_version" -eq 2; then
					ec=0 && OP_SESSION="$(op account add --address "$OP_SUBDOMAIN" --email "$email" --signin --raw)" || ec="$?"
					# OP_SESSION will equal '' if biometric auth is used
				else
					key="$(
						ask --required "${ask_password_arguments[@]}" \
							--question='What is your 1password account key? This is not stored.'
					)"
					# unfortunately, this still leaks email and subdomain
					# https://1password.community/discussion/122030/flag-to-disable-op-signin-from-outputting-email-and-subdomain/p1?new=1
					# don't pipe to anything else, as it breaks the OTP question
					ec=0 && OP_SESSION="$(op signin "$OP_SUBDOMAIN" "$email" "$key" --raw)" || ec="$?"
				fi
				if test "$ec" -ne 0; then
					echo-error \
						"Failed to sign into [$OP_SUBDOMAIN] via the email [$email] and account key [$key]." \
						"OP_SESSION = [$OP_SESSION]"
					return 1
				fi
				if test -n "$OP_SESSION"; then
					cache_write "OP_SESSION" "$OP_SESSION"
				else
					cache_delete "OP_SESSION" # biometric
				fi
			fi
		fi
		if test "$quiet" != 'yes'; then
			echo 'Authenticated.'
		fi
	}

	function opwrap {
		local ec result
		ec=0 && result="$(op "$@" 2>&1)" || ec="$?"
		if test "$ec" -ne 0 || [[ $result == '[ERROR]'* ]]; then
			if [[ $result == *'signed in'* ]] || [[ $result == *'session expired'* ]]; then
				echo-error "Session expired, run [secret login] and try again." $'\n' "$result" # $'\n' "$OP_SESSION"
				return 1
			fi
			echo-error "$result"
			return 1
		else
			echo -n "$result"
		fi
	}

	function opgrab {
		local vault="${1-}" item="${2-}" ec

		if is-empty-value "$vault"; then
			# fetch available values
			if test "$op_version" -eq 2; then
				# https://developer.1password.com/docs/cli/reference/management-commands/vault#vault-list
				ec=0 && opwrap vault list --format=json --session "$OP_SESSION" | jq -r '.[] | (.id, .name)' || ec="$?"
			else
				ec=0 && opwrap list vaults --session="$OP_SESSION" | jq -r '.[] | (.uuid, .name)' || ec="$?"
			fi
		elif is-empty-value "$item"; then
			# fetch available items
			if test "$op_version" -eq 2; then
				# https://developer.1password.com/docs/cli/reference/management-commands/item#item-list
				ec=0 && opwrap item list --vault "$vault" --format json --session "$OP_SESSION" | jq -r '.[] | (.id, .title)' || ec="$?"
			else
				ec=0 && opwrap list items --vault="$vault" --session="$OP_SESSION" | jq -r '.[] | (.uuid, .overview.title)' || ec="$?"
			fi
		else
			# fetch item
			if test "$op_version" -eq 2; then
				# https://developer.1password.com/docs/cli/reference/management-commands/item#item-get
				# https://stackoverflow.com/a/40321859
				# newlines in notes will produces superflous tuples, so replace them four spaces
				# cli v2 needs null checks too
				ec=0 && opwrap item get "$item" --vault "$vault" --format json --session "$OP_SESSION" | jq -r '.fields[]? | select(.label != "" and .label != null and .value != "" and .value != null) | (.value, .label) | walk(if type == "string" then gsub("\\p{Cc}"; "    ") else . end)' || ec="$?"
			else
				ec=0 && data="$(opwrap get item "$item" --vault="$vault" --session="$OP_SESSION")" || ec="$?"
				if test "$ec" -eq 0; then
					# section fields
					local fields_via_section
					mapfile -t fields_via_section < <(echo "$data" | jq -r '.details.sections[]? | select(.fields).fields[]? | select(.t != "" and .v != "") | (.v, .t)')
					if is-array-count-ge 2 "${fields_via_section[@]}"; then
						echo-lines "${fields_via_section[@]}"
					fi

					# name fields
					local fields_via_name
					mapfile -t fields_via_name < <(echo "$data" | jq -r '.details.fields[]? | select(.name != "" and .value != "") | (.value, .name)')
					if is-array-count-ge 2 "${fields_via_name[@]}"; then
						echo-lines "${fields_via_name[@]}"
					fi

					# designation fields
					local fields_via_designation
					mapfile -t fields_via_designation < <(echo "$data" | jq -r '.details.fields[]? | select(.designation != "" and .value != "") | (.value, .designation)')
					if is-array-count-ge 2 "${fields_via_designation[@]}"; then
						echo-lines "${fields_via_designation[@]}"
					fi
				fi
			fi
		fi

		return "$ec"
	}

	function fetch_vault {
		local vault="${1-}" tuples

		# fetch available vaults
		mapfile -t tuples < <(opgrab)
		if is-array-empty "${tuples[@]}"; then
			echo-error "Failed to fetch a vault:" $'\n' \
				"$(echo-verbose "${tuples[@]}")"
			return 1
		fi

		# filter or ask
		choose-option \
			--question="Which vault did you want with [$vault]?" \
			--filter="$vault" --label --visual="\$LABEL [\$VALUE]" \
			-- "${tuples[@]}"
		return "$?" # return with the above on success and failure
	}

	function fetch_item {
		local vault="${1-}" item="${2-}" tuples

		# fetch available items
		mapfile -t tuples < <(opgrab "$vault")
		if is-array-empty "${tuples[@]}"; then
			echo-error "Failed to fetch any items:" $'\n' \
				"$(echo-verbose "${tuples[@]}")"
			return 1
		fi

		# filter or ask
		choose-option \
			--question="Which item did you want with [$item]?" \
			--filter="$item" --label --visual="\$LABEL [\$VALUE]" \
			-- "${tuples[@]}"
		return "$?" # return with the above on success and failure
	}

	function fetch_field {
		local vault="${1-}" item="${2-}" field="${3-}" tuples
		local wants
		if test "${4-}" = '--label'; then
			# trunk-ignore(shellcheck/SC2016)
			wants='$LABEL'
		else
			# trunk-ignore(shellcheck/SC2016)
			wants='$VALUE'
		fi

		# fetch available items
		mapfile -t tuples < <(opgrab "$vault" "$item")
		if is-array-empty "${tuples[@]}"; then
			echo-error "Failed to fetch any items:" $'\n' \
				"$(echo-verbose "${tuples[@]}")"
			return 1
		fi

		# filter or ask
		choose-option \
			--question="Which field did you want with [$field]?" \
			--filter="$field" --label --visual="\$LABEL [\$VALUE]" --return="$wants" \
			-- "${tuples[@]}"
		return "$?" # return with the above on success and failure
	}

	function get_job_count {
		jobs -p | get-line-count
	}

	function item_upgrade {
		local vault="$1" item="$2" ec result

		# fetch
		if test "$op_version" -eq 2; then
			# [select(.primary = true)] returns multiple urls
			ec=0 && website="$(opwrap item get "$item" --vault "$vault" --format json --session "$OP_SESSION" | jq -r '.urls[]? | .href' | echo-first)" || ec="$?"
		else
			ec=0 && website="$(opwrap get item "$item" --vault "$vault" --fields website --session="$OP_SESSION")" || ec="$?"
		fi
		if test "$ec" -ne 0; then
			echo-style --error="[$item] [$website] failed to fetch"
			return 1
		fi
		if test -z "$website"; then
			echo-style --dim="[$item] no urls"
			return 0
		fi

		# upgrade
		result="$(get-url-upgrade "$website" 2>/dev/null || :)"
		if test -z "$result"; then
			# echo to stdout, as is actionable for user if they are piping
			echo-style --warning="[$item] [$website] unresponsive, consider archiving"
			return 1
		fi

		# check if changed
		if test "$result" = "$website"; then
			echo-style --dim="[$item] [$website] already upgraded"
			return 0
		fi

		# echo to stdout, as is actionable for user if they are piping
		echo-style --success="[$item] [$website] => [$result]"

		# apply
		if test "$op_version" -eq 2; then
			ec=0 && opwrap item edit "$item" --vault "$vault" --url "$result" --format json --session "$OP_SESSION" >/dev/null || ec="$?"
		else
			ec=0 && opwrap edit item "$item" --vault "$vault" website="$result" --session="$OP_SESSION" || ec="$?"
		fi
		if test "$ec" -ne 0; then
			echo-style --error="[$item] [$website] failed to save"
			return 1
		fi
	}

	function secret_https {
		local last="${1-}" ec vault item
		if test "$op_version" -eq 2; then
			ec=0 && vaults="$(opwrap vault list --format json --session "$OP_SESSION" | jq -r '.[].id' | sort)" || ec="$?"
		else
			ec=0 && vaults="$(opwrap list vaults --session="$OP_SESSION" | jq -r '.[].uuid' | sort)" || ec="$?"
		fi
		if test "$ec" -ne 0 -o -z "$vaults"; then
			echo-error "Failed to fetch vaults..."
			return 1
		fi
		for vault in $vaults; do
			if test "$op_version" -eq 2; then
				ec=0 && items="$(opwrap item list --categories Login --vault "$vault" --format json --session "$OP_SESSION" | jq -r '.[].id' | sort)" || ec="$?"
			else
				ec=0 && items="$(opwrap list items --categories Login --vault "$vault" --session="$OP_SESSION" | jq -r '.[].uuid' | sort)" || ec="$?"
			fi
			if test "$ec" -ne 0 -o -z "$items"; then
				echo-style --warning="Failed to fetch items for vault [$vault]"
				continue
			fi
			# ignoring of status code is in case it returned a vault we don't have write access to
			for item in $items; do
				# resume
				if test -n "$last"; then
					if test "$item" = "$last"; then
						# stop skipping
						last=''
					else
						# continue skipping
						echo-style --dim="[$item] skipping"
						continue
					fi
				fi
				while test "$(get_job_count)" -eq 15; do
					sleep 1
				done
				(item_upgrade "$vault" "$item" || :) &
			done
		done

		# wait for completed jobs, then note completion
		while test "$(get_job_count)" -ne 0; do
			echo "Waiting on [$(get_job_count)] jobs..."
			sleep 5
			jobs &>/dev/null # for some reason, this seems necessary to prevent hung jobs
		done
		echo 'All done.'
	}

	function secret_fetch {
		local vault item
		value="$(fetch_vault "${1-}")"
		item="$(fetch_item "$vault" "${2-}")"
		fetch_field "$vault" "$item" "${3-}"
		return "$?" # return with the above on success and failure
	}

	function secret_map {
		local secret vault item field result
		secret="$(
			ask --required \
				--question='What shall the name of the environment variable (secret) be?' \
				--default="${1-}"
		)"
		vault="$(fetch_vault "${2-}")"
		item="$(fetch_item "$vault" "${3-}")"
		field="$(fetch_field "$vault" "$item" "${4-}" --label)"
		result="$(jq -r \
			--arg secret "$secret" \
			--arg vault "$vault" \
			--arg item "$item" \
			--arg field "$field" \
			'.[$secret] = [$vault, $item, $field]' \
			"$database")"
		echo "$result" | sudo tee "$database" &>/dev/null
		correct_database_permission
		{
			echo "Sucessfully updated [$database] so that [$secret] fetches [$vault].[$item].[$field]"
			echo "Fetching [$secret]..."
		} >/dev/stderr
		cache_delete "$secret"
		secret_get "$secret"
	}

	function secret_unmap {
		local secret result
		secret="$(
			ask --required \
				--question='What environment variable (secret) name do you wish to unmap?' \
				--default="${1-}"
		)"
		echo 'Enter your sudo password to update the database with the correct permissions...'
		result="$(jq -r \
			--arg secret "$secret" \
			'del(.[$secret])' \
			"$database")"
		echo "$result" | sudo tee "$database"
		correct_database_permission
		cache_delete "$secret"
		echo "Sucessfully unmapped [$secret]" >/dev/stderr
	}

	function secret_env {
		local before=() after=() found='no' args arg
		local keys key value
		local envSecrets envArgs envArg

		for arg in "$@"; do
			if test "$arg" = '--'; then
				found='yes'
				continue
			fi
			if test "$found" = 'yes'; then
				after+=("$arg")
			else
				before+=("$arg")
			fi
		done

		if test "$found" = 'yes' && is-array-full "${before[@]}" && is-array-full "${after[@]}"; then
			keys=("${before[@]}")
			args=("${after[@]}")
		else
			help "env action requires -- separator"
		fi

		# load secrets
		envSecrets=()
		for key in "${keys[@]}"; do
			value="$(secret_get "$key")"
			envSecrets+=("$key=$value")
		done

		# replace secrets in args
		envArgs=()
		for arg in "${args[@]}"; do
			envArg="$arg"
			for key in "${keys[@]}"; do
				value="$(secret_get "$key")"
				envArg="${envArg//\$$key/$value}"
			done
			envArgs+=("$envArg")
		done

		# echo "loaded secrets:  ${vars[*]}"
		# echo "running command: ${args[*]}"
		# echo ''

		env "${envSecrets[@]}" "${envArgs[@]}"
	}

	# =====================================
	# Act

	if test "$action" = 'install'; then
		setup-util-1password-cli --upgrade
	elif test "$action" = 'login'; then
		secret_signout --quiet >/dev/stderr
		# trunk-ignore(shellcheck/SC2119)
		secret_signin
	elif test "$action" = 'logout'; then
		secret_signout
	elif test "$action" = 'map'; then
		secret_map "${args[@]}"
	elif test "$action" = 'env'; then
		secret_env "${args[@]}"
	elif test "$action" = 'get'; then
		if test -n "${args[*]}"; then
			secret_get "${args[@]}"
		else
			help "get action requires <name> argument"
		fi
	elif test "$action" = 'invalidate'; then
		if test -n "${args[*]}"; then
			cache_delete "${args[@]}"
		else
			cache_clear
		fi
	elif test "$action" = 'unmap'; then
		secret_unmap "${args[@]}"
	elif test "$action" = 'fetch'; then
		secret_fetch "${args[@]}"
	elif test "$action" = 'https'; then
		secret_https "${args[@]}"
	elif test "$action" = 'help'; then
		help
	else
		help 'Invalid <action>'
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	secret "$@"
fi
