#!/usr/bin/env bash
# trunk-ignore-all(shellcheck/SC2016)

# @note that if they have installed bash via homebrew, and that is what is invoking this script, and then that is what is being uninstalled, the script will crash once bash has been removed. Other methods shouldn't have this issue, as they move the bash executable to a "trash" equiavlent directory, which allows the invoked script to continue. This is such an edge case, it's not worth doing more on, unless a user actually reports a valid need for a warning or workaround. A workaround being ensuring this script invokes with the system bash instead of the installed bash.

function setup_util_bash() (
	source "$DOROTHY/sources/bash.bash"
	# imports:
	# IS_BASH_VERSION_OUTDATED
	# BASH_VERSION_CURRENT
	# BASH_VERSION_LATEST

	# testing
	if test "$*" = '--test'; then
		# test if the known version is still the latest available version
		echo-segment --h1="TEST: $0"

		# dependencies
		source "$DOROTHY/sources/ripgrep.bash"

		# fetch 'https://ftp.gnu.org/gnu/bash/?C=M;O=D' | grep -m1 -o -E --regexp='href="bash-.+?tar.gz"' | sed 's/href="//' | sed 's/"//'
		local bash_version_latest_available
		bash_version_latest_available="$(
			fetch 'https://ftp.gnu.org/gnu/bash/?C=M;O=D' | rg --max-count=1 --only-matching --regexp='href="bash-(.+?)[.]tar[.]gz"' --replace='$1'
		)"
		echo-segment --h2='latest known bash version is the latest available bash version'
		echo-style --bold='current bash version' ' = ' --invert="$BASH_VERSION_CURRENT"
		echo-style --bold='latest known bash version' ' = ' --invert="$BASH_VERSION_LATEST"
		echo-style --bold='latest available bash version' ' = ' --invert="$bash_version_latest_available"
		if test "$BASH_VERSION_LATEST" != "$bash_version_latest_available"; then
			echo-segment --g2='latest known bash version is the latest available bash version'
			return 1
		fi
		echo-segment --g2='latest known bash version is the latest available bash version'
		echo-segment --g1="TEST: $0"
		return 0
	fi

	# enable DOWNLOAD_BUILD_EVAL
	source "$(command -v setup-util)"

	# if outdated bash, then enable upgrade option
	local extras=()
	if test "$IS_BASH_VERSION_OUTDATED" = 'yes'; then
		extras+=('--upgrade')
	fi

	# setup bash
	function build_bash {
		./configure
		make
	}
	local options=(
		"${extras[@]}"
		--cli='bash'
		"$@"
		DOWNLOAD="https://ftp.gnu.org/gnu/bash/bash-${BASH_VERSION_LATEST}.tar.gz"
		DOWNLOAD_UNZIP_FORMAT='tar'
		DOWNLOAD_BUILD_EVAL='build_bash'
		APK='bash'
		APT='bash'
		AUR='bash'
		BREW='bash'
		RPM='bash'
		ZYPPER='bash'
	)
	setup_util "${options[@]}"

	# setup bash completions
	# https://github.com/scop/bash-completion
	options=(
		"${extras[@]}"
		--optional
		--no-fallback
		--name='Bash Completions'
		"$@"
		APK='bash-completion'
		APT='bash-completion'
		AUR='bash-completion'
		BREW='bash-completion'
		RPM='bash-completion'
		ZYPPER='bash-completion'
	)
	setup_util "${options[@]}"

	# if the login shell is outdated bash, and if the new bash is installed, then update the login shell to the newer bash
	# @todo figure out how this works if login shell is the now uninstall bash
	local login_shell bash_shell
	login_shell="${SHELL-}"
	bash_shell="$(command -v bash)"
	if test -n "$login_shell"; then
		login_shell_name="$(basename "$login_shell")"
		if test "$login_shell_name" = 'bash' -a "$login_shell" != "$bash_shell"; then
			login_shell_version="$("$login_shell" -c -- 'echo $BASH_VERSION')"
			bash_shell_version="$("$bash_shell" -c -- 'echo $BASH_VERSION')"
			if test "$login_shell_version" != "$bash_shell_version"; then
				echo-style --h2="Your login shell is an outdated version of bash."
				echo-style --h2="You will now be prompted now to change it to a more modern shell."
				select-shell
				echo-style --h2="Close this terminal, open a new one, then run the command you ran again."
				return 0
			fi
		fi
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup_util_bash "$@"
fi
