#!/usr/bin/env bash

# =====================================
# OPEN

## SAMBA - MACOS (supports keychain auth, mounts to /Volumes/*, mounts as smbfs)
# open --hide --background 'smb://username:password@server/share'
# open --hide --background 'smb://balupton@balupton-mbp._smb._tcp.local/balupton'
# open --hide --background 'smb://balupton@192.168.4.21/BOOTCAMP'
# open --hide --background 'smb://Benjamin%20Lupton@192.168.7.94/Data'

# =====================================
# MOUNTING

## DEVICE
# sudo mount /dev/sdb1 /mnt

## BTRFS
# /dev/sdb1 on /mnt type btrfs (rw,relatime,space_cache)

## SAMBA - UBUNTU (user,username,pass,password are alias - does not support URI authentication - if no /etc/fstab entry, then requires sudo)
# sudo mount -t cifs //server/share /mnt -o username=user,password=pass
# sudo mount -t cifs //192.168.4.21/balupton ./samba -o "username=balupton,password=hello today"

## SAMBA - MACOS (no keychain auth, no -o auth, mount_smbfs is the tool)
# mount -t smbfs "//url-escaped-username:url-escaped-password@ip-address/url-escaped-share" ./samba

# =====================================
## MOUNTED

## DEVICE - MACOS
# /dev/disk5s1 on /Volumes/Tango (apfs, local, nodev, nosuid, journaled, noowners)

## DEVICE - UBUNTU
# /dev/sdf on /Volumes/share type btrfs (rw,relatime,space_cache,subvolid=5,subvol=/)
# /dev/sdb2 on /media/balupton/UNTITLED type vfat (rw,nosuid,nodev,relatime,uid=1000,gid=1000,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)

## SERVICE - UBUNTU
# log2ram on /var/log type tmpfs (rw,nosuid,nodev,noexec,noatime,size=51200k,mode=755,inode64)

## SAMBA - UBUNTU
# //192.168.4.21/balupton on /home/balupton/Testing/samba type cifs (rw,relatime,vers=default,cache=strict,username=balupton,uid=0,noforceuid,gid=0,noforcegid,addr=192.168.4.21,file_mode=0755,dir_mode=0755,soft,nounix,serverino,mapposix,rsize=4194304,wsize=4194304,bsize=1048576,echo_interval=60,actimeo=1,closetimeo=1)

## SAMBA - MACOS (afpfs is for legacy time capsule sharing, is legacy, is available by finder and open, it is not availale for mount command - however time capsule sharing is mountable as smbfs with mount command)
# //url-escaped-username@server/share on /Volumes/share (smbfs, nodev, nosuid, mounted by balupton)
# //Benjamin%20Lupton@tc._afpovertcp._tcp.local/Data on /Volumes/Data (afpfs, nodev, nosuid, mounted by balupton)
# //balupton@balupton-mbp._smb._tcp.local/System on /Volumes/System (smbfs, nodev, nosuid, mounted by balupton)
# //Benjamin%20Lupton@192.168.7.94/Data on /Users/balupton/Testing/samba (smbfs, nodev, nosuid, mounted by balupton)

## GOCRYPTFS - MACOS
# /Users/balupton/Testing/cipher on /Users/balupton/Testing/plain (macfuse, nodev, nosuid, synchronous, mounted by balupton)

## UBUNTU - GOCRYPTFS
# /Volumes/share/cipher on /Volumes/share type fuse.gocryptfs (rw,nosuid,nodev,relatime,user_id=1001,group_id=1002,default_permissions,allow_other,max_read=131072)
# /home/balupton/Testing/cipher on /home/balupton/Testing/plain type fuse.gocryptfs (rw,nosuid,nodev,relatime,user_id=1000,group_id=1000,max_read=1048576)

# =====================================
# FSTAB

## DEVICE - UBUNTU
# LABEL=writable  /       ext4    discard 0       1
# /dev/sdb1    /mnt    ext4    defaults    0    0
# /dev/sdb1    /mnt    btrfs    defaults    0    0

## SAMBA - UBUNTU (fstab octal escaping, \040 = space)
# //server/share    /mnt    cifs    username=user,password=pass    0    0
# //192.168.4.21/balupton /home/balupton/Testing/samba cifs username=balupton,password=fstab-escaped-string 0 0

## SAMBA - MACOS
# //url-escaped-username@server/url-escaped-share /mount-target smbfs auto 0 0
# //balupton:url-escaped-password@192.168.4.21/balupton /Users/balupton/Testing/samba smbfs auto 0 0

## GOCRYPTFS - UBUNTU
# /path/to/encrypted    /mnt    fuse.gocryptfs    rw,user_id=0,group_id=0,default_permissions,allow_other    0    0

# =====================================
# TODOS

# [ ] move sudo and ls commands to where appropriate
# [ ] make sure all variables are defined, and included in the log dump
# [ ] rename _source variables to whatever is appropriate
# [ ] move cron mounting code to error instead
# [ ] note that [check] action does not require many options, but the others do, ensure that is handled correctly
# [ ] review help text

# Consider a mount.bash configuration file that will allow
# MOUNTHELPER_AUTOMOUNTS=(
# 	-- --samba --username=... --password=... --server=... --share=... --target=...
# )
# MOUNTHELPER_AUTOMOUNTS=(
# 	-- --btrfs --label=... --count=... --target=...
# 	-- --gocryptfs --share=... --target=... --password=...
# )
# mount-helper --auto --mount
# mount-helper --auto --unmount

# Consider cron support:
# if test "$cron_required" = 'yes'; then
# 	# @todo consider using [mount -a] to defer to fstab automounts (not suitable for gocryptfs)
# 	# or to use [mount-helper] in cron
# 	# however at this point, this is only desirable for samba mounts as the other mounts can be nested and therefore haphazard
# 	# so for now, letting it be until we have a samba mount we want to mount
# 	cron_args=(
# 		"$(command -v bash | echo-quote)"
# 		'-l'
# 		'--'
# 		"$(command -v mount-helper | echo-quote)"
# 		'--mount'
# 		'--no-remount'
# 		"--type=${option_type@Q}"
# 		"--user=${option_user@Q}"
# 		"--group=${option_group@Q}"
# 		"--owner=${option_owner@Q}"
# 		"--username=${option_username@Q}"
# 		"--password=${option_password@Q}"
# 		"--server=${option_server@Q}"
# 		"--share=${option_share@Q}"
# 		"--target=${option_target@Q}"
# 	)
# 	cron_line="*/15 * * * * ${cron_args[*]}"

# =====================================
# NOTES

# MOUNTED = `mount` output
# OPEN = `open ...`
# FSTAB = `/etc/fstab` contents

# [621979.345650] CIFS: No dialect specified on mount. Default has changed to a more secure dialect, SMB2.1 or later (e.g. SMB3.1.1), from CIFS (SMB1). To use the less secure SMB1 dialect to access old servers which do not support SMB3.1.1 (or even SMB3 or SMB2.1) specify vers=1.0 on mount.

# The latest documentation about autofs on macos from 2012-2017, I could not figure anything out that was relevant today. There is no `autofs` brew package, and there is do `autofs` or `autofsd` or `system/autofsd` services.

function mount-helper() (
	source "$DOROTHY/sources/bash.bash"
	require_array 'mapfile'

	# dependencies
	source "$DOROTHY/sources/ripgrep.bash"
	setup-util --quiet --cli='smbinfo' APT='cifs-utils'

	# =====================================
	# Helpers

	function is_device {
		[[ $1 =~ device|drive|disk ]]
	}
	# function is_source_device {
	# 	[[ $1 == '/dev/'* ]]
	# }
	# function is_source_server {
	# 	[[ $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]
	# }
	function is_samba {
		[[ $1 =~ samba|smb|smbfs|cifs ]]
	}
	function is_gocryptfs {
		[[ $1 =~ gocryptfs|fuse.gocryptfs ]]
	}
	function is_btrfs {
		test "$1" = 'btrfs'
	}
	function stringify_args {
		local result=() arg
		for arg in "$@"; do
			if test -n "$arg" && [[ "$arg" != *'=' ]] && [[ "$arg" != *"=''" ]]; then
				result+=("$arg")
			fi
		done
		echo "${result[*]}"
	}
	function string_dump {
		local result=() arg value
		for arg in "$@"; do
			if test -z "$arg"; then
				result+=($'\n')
			else
				value="${!arg}"
				if test -n "$value"; then
					value="--invert=$value"
				fi
				result+=(
					--bold="$arg"
					' = '
					"$value"
					$' \n'
				)
			fi
		done
		echo-style "${result[@]}"
	}
	function value_dump {
		local result=() arg value mode='var'
		for arg in "$@"; do
			if test "$mode" = 'var'; then
				result+=(
					--bold="$arg"
					' = '
				)
				mode='value'
			else
				if test -n "$arg"; then
					result+=(
						"--invert=$arg"
					)
				fi
				result+=(
					$' \n'
				)
				mode='var'
			fi
		done
		echo-style "${result[@]}"
	}

	# =====================================
	# Action

	local option_actions option_remount option_type option_user option_group option_owner option_username option_password option_server option_label option_count option_share option_source option_target
	function reset {
		option_actions=''
		option_remount=''
		option_type=''
		option_user=''
		option_group=''
		option_owner=''
		option_username=''
		option_password=''
		option_server=''
		option_label=''
		option_count=''
		option_share=''
		option_source=''
		option_target=''
	}
	reset
	function action {
		# open is for `open ...` calls
		# mounted is for results of `mount` command
		# fstab is for `mount` command and fstab entries
		local temp=''
		local mount_source='' mounted_source='' fstab_source='' open_source='' gocryptfs_source=''
		local mount_type='' mounted_type='' fstab_type='' mount_fstab_options=''
		local check_source='' check_target='' check_type=''
		local fstab_line='' cron_args=() cron_line=''
		local open_cmd=() gocryptfs_cmd=() mount_cmd=() mounting_cmd=()
		local sudo_cmd=(
			'sudo-helper'
			"--user=$option_user"
			"--group=$option_group"
			'--'
		)
		local ls_cmd=(
			'ls'
			'-la'
			"$option_target"
		)
		local mounting_safety='yes'

		# skip if first --
		if test -z "$option_type" -a -z "$option_server" -a -z "$option_share" -a -z "$option_source" -a -z "$option_target"; then
			return
		fi

		# logging
		local title='mount-helper'
		if [[ $option_actions == *'[parse]'* ]]; then
			title+=' --parse'
		fi
		if [[ $option_actions == *'[check]'* ]]; then
			title+=' --check'
		fi
		if [[ $option_actions == *'[mount]'* ]]; then
			title+=' --mount'
		fi
		if [[ $option_actions == *'[unmount]'* ]]; then
			title+=' --unmount'
		fi
		if [[ $option_actions == *'[automount]'* ]]; then
			title+=' --automount'
		fi
		if [[ $option_actions == *'[unautomount]'* ]]; then
			title+=' --unautomount'
		fi
		if test "$title" = 'mount-helper'; then
			echo-error "Require --parse, --check, --mount, --unmount, --automount, --unautomount"
			return 22 # Invalid argument
		fi
		echo-segment --h2="$title"
		function on_return {
			local on_return_ec="$?"
			if test "$on_return_ec" -eq 0; then
				echo-segment --g2="$title"
			else
				echo-segment --e2="$title"
			fi
			trap - RETURN EXIT
			return "$on_return_ec"
		}
		trap on_return RETURN EXIT # RETURN is success, EXIT is exceptions

		# coerce target
		if test -n "$option_target"; then
			option_target="$(fs-realpath -- "$option_target")"
		fi

		# coerce source options by parsing source
		if test -n "$option_source"; then
			temp=''
			# {type}:?//{user}:{password}@{server}/{share}
			if [[ $temp == *'://'* ]]; then
				option_type="${temp%%://*}"
				temp="${temp#*://}"
			elif [[ $temp == *'//'* ]]; then
				option_type="${temp%%//*}"
				temp="${temp#*//}"
			fi
			# check [what] was supplied, as inferance is possible but problematic
			if test -z "$option_type"; then
				help 'When using ' --code="--source=$option_source" ' ensure ' --code='<type>://...' ' or ' --code='--type=<type>' ' is provided'
			fi
			# {username}:{password}@{server}/{share}
			if [[ $temp == *':'*'@'* ]]; then
				option_username="${temp%%:*}"
				temp="${temp#*:}"
				option_password="${temp%%@*}"
				temp="${temp#*@}"
			elif [[ $temp == *'@'* ]]; then
				option_username="${temp%%@*}"
				temp="${temp#*@}"
			fi
			# {server}/{share} OR {share}
			if is_samba "$option_type"; then
				# trim leading /
				option_server="${temp%%/*}"
				# trim leading and trailing /
				option_share="${temp#*/}"
				option_share="${option_share%%/*}"
			else
				# everything goes in share
				option_share="$temp"
			fi
		fi

		# coerce formats
		if is_samba "$option_type"; then
			option_type='samba'
			mount_source='//'
			mounted_source='//'
			fstab_source='//'

			if is-mac; then
				open_source="smb://"
				mount_type='smbfs'
				mounted_type='smbfs'
				fstab_type='smbfs'

				# @todo consider using guest as default username
				if test -n "$option_username" -o "$option_password"; then
					if test -n "$option_username"; then
						temp="$(echo-url-encode "$option_username")"
						open_source+="$temp"
						mount_source+="$temp"
						mounted_source+="$temp"
						fstab_source+="$temp"
					fi
					if test -n "$option_password"; then
						temp=":$(echo-url-encode "$option_password")"
						open_source+="$temp"
						mount_source+="$temp"
						# password is removed from mounted_source
						fstab_source+="$temp"
					fi
					open_source+="@"
					mount_source+="@"
					mounted_source+="@"
					fstab_source+="@"
				fi

				if test -n "$option_server" -o -n "$option_share"; then # optional under [check]
					if test -z "$option_server" -o -z "$option_share"; then
						echo-error "<server> and <share> must be used together"
						return 22 # EINVAL Invalid argument
					fi

					temp="$(echo-url-encode "$option_server/$option_share")"
					open_source+="$temp"
					mount_source+="$temp"
					mounted_source+="$temp"
					fstab_source+="$temp"

					if test -z "$option_target"; then
						option_target="/Volumes/$option_share"
					fi
					if [[ $option_target == '/Volumes/'* ]]; then
						open_cmd=(
							'open'
							'--background'
							'--hide'
							"$open_source"
						)
					else
						mount_cmd=(
							'mount'
							"$mount_source"
							"$option_target"
							'-t' "$mount_type"
						)
					fi
				fi
			else
				mount_type='cifs'
				mounted_type='cifs'
				fstab_type='cifs'

				# @todo consider using guest as default username
				if test -n "$option_username" -a -n "$option_password"; then
					mount_fstab_options+="username=$(echo-fstab-encode "$option_username"),password=$(echo-fstab-encode "$option_password")"
				elif test -n "$option_username"; then
					mount_fstab_options+="username=$(echo-fstab-encode "$option_username")"
				elif test -n "$option_password"; then
					mount_fstab_options+="password=$(echo-fstab-encode "$option_password")"
				fi

				if test -n "$option_server" -o -n "$option_share"; then # check can miss this
					if test -z "$option_server" -o -z "$option_share"; then
						echo-error "<server> and <share> must be used together"
						return 22 # EINVAL Invalid argument
					fi

					temp="$(echo-url-encode "$option_server/$option_share")"
					mount_source="$temp"
					mounted_source="$temp"
					fstab_source="$(echo-fstab-encode "$option_server/$option_share")"

					if test -n "$option_target"; then # optional under [check]
						mount_cmd=(
							'mount'
							"$fstab_source"
							"$option_target"
							'-t' "$mount_type"
						)
						if test -n "$mount_fstab_options"; then
							mount_cmd+=(
								'-o' "$mount_fstab_options"
							)
						fi
					fi
				fi
			fi
		elif is_gocryptfs "$option_type"; then
			option_type='gocryptfs'

			if is-mac; then
				# direct [mount] and [fstab] not available for macos
				mounted_type='macfuse'
			else
				mount_type='fuse.gocryptfs'
				mounted_type='fuse.gocryptfs'
				fstab_type='fuse.gocryptfs'

				mount_fstab_options+="rw,noprealloc,allow_other"
				if test -n "$option_password"; then
					mount_fstab_options+=",extpass=$(echo-fstab-encode "echo $option_password")"
				fi
				if test -n "$option_owner"; then
					mount_fstab_options+=",force_owner=$(echo-fstab-encode "$option_owner")"
				fi
			fi

			if test -n "$option_share"; then # option under [check]
				option_share="$(fs-realpath -- "$option_share")"
				gocryptfs_source="$option_share"
				mount_source="$option_share"   # @todo is this escaped?
				mounted_source="$option_share" # @todo is this escaped?
				if test -n "$fstab_type"; then
					fstab_source="$(echo-fstab-encode "$option_share")"
				fi

				if ! gocryptfs-helper verify -- "$gocryptfs_source" "--user=$option_user" "--group=$option_group"; then
					echo-error "Failed to verify gocryptfs mount source: $gocryptfs_source"
					return 22 # Invalid argument

				fi

				if test -n "$option_target"; then # optional under [check]
					if is-linux; then
						mount_cmd=(
							'mount'
							"$mount_source"
							"$option_target"
							'-t' "$mount_type"
							'-o' "$mount_fstab_options"
						)
					fi

					gocryptfs_cmd=(
						'gocryptfs'
						"$gocryptfs_source"
						"$option_target"
						'--rw'
						'--noprealloc'
						'--allow_other'
					)
					if test -n "$option_password"; then
						gocryptfs_cmd+=(
							"--extpass=echo $option_password"
						)
					fi
					if test -n "$option_owner"; then
						gocryptfs_cmd+=(
							'--force_owner'
							"$option_owner"
						)
					fi
				fi
			fi

		elif test -n "$option_type"; then
			# btrfs, device, etc
			mount_type="$option_type"
			mounted_type="$option_type"
			fstab_type="$option_type"

			# verify label
			if test -n "$option_label"; then
				if ! is_btrfs "$option_type"; then
					echo-error "<label> only supported for <btrfs>"
					return 22 # EINVAL Invalid argument
				fi

				temp="$(btrfs-helper drive -- "$option_label")"
				if test -n "$option_share"; then
					if test "$option_share" != "$temp"; then
						echo-error "label [$option_label] returned [$temp] which was not the expected share [$option_share]"
						return 22 # EINVAL Invalid argument
					fi
				elif test -n "$temp"; then
					option_share="$temp"
				else
					echo-error "invalid label [$option_label]"
					return 22 # EINVAL Invalid argument
				fi

				# verify count
				if test -n "$option_count"; then
					btrfs-helper verify -- "$option_label" "$option_count"
				fi
			elif test -n "$option_count"; then
				echo-error "<count> requires <label> to be defined"
				return 22 # EINVAL Invalid argument
			fi

			if test -n "$option_share"; then # option under [check]
				mount_source="$option_share"
				mounted_source="$option_share"
				fstab_source="$(echo-fstab-encode "$option_share")"

				# require target
				if test -z "$option_target"; then
					echo-error "<target> requires <share> to be defined"
					return 22 # EINVAL Invalid argument
				fi
				mount_cmd=(
					'mount'
					"$mount_source"
					"$option_target"
					-t "$mount_type"
				)
			fi
		fi

		# coerce lines
		if test -n "$fstab_source" -a -n "$option_target" -a -n "$fstab_type"; then
			if test -z "$mount_fstab_options"; then
				mount_fstab_options='auto'
			else
				mount_fstab_options="auto,$mount_fstab_options"
			fi
			fstab_line="$fstab_source $(echo-fstab-encode "$option_target") $fstab_type $mount_fstab_options 0 0"
			cron_line="*/15 * * * * mount ${option_target@Q}"
		fi
		# @todo for the following to work, it will require a `dorothy run -- mount-helper ...` command
		if test -n "$option_share" -a -n "$option_target"; then
			# using [which] as [command -v] fails on functions, which [mount-helper] is in this context
			cron_args=(
				"$(which dorothy | echo-quote)"
				'trial'
				'--'
				"$(which mount-helper | echo-quote)"
				'--mount'
				'--no-remount'
				"--type=${option_type@Q}"
				"--user=${option_user@Q}"
				"--group=${option_group@Q}"
				"--owner=${option_owner@Q}"
				"--username=${option_username@Q}"
				"--password=${option_password@Q}"
				"--server=${option_server@Q}"
				"--label=${option_label@Q}"
				"--count=${option_count@Q}"
				"--share=${option_share@Q}"
				"--target=${option_target@Q}"
			)
			cron_line="*/15 * * * * $(stringify_args "${cron_args[@]}")"
		fi

		# coerce commands
		if is_samba "$option_type" && is-mac && [[ $option_target == '/Volumes/'* ]]; then
			mounting_cmd+=(
				# not necessary: "${sudo_cmd[@]}"
				"${open_cmd[@]}"
			)
			mounting_safety='no'
		elif is_gocryptfs "$option_type"; then
			mounting_cmd+=(
				"${sudo_cmd[@]}"
				"${gocryptfs_cmd[@]}"
			)
		else
			# linux/macos device, linux samba
			mounting_cmd+=(
				"${sudo_cmd[@]}"
				"${mount_cmd[@]}"
			)
		fi

		# coerce check
		if test -n "$mounted_source"; then
			check_source="$mounted_source on "
		fi
		if test -n "$option_target"; then
			check_target=" on $option_target "
		fi
		if test -n "$mounted_type"; then
			if is-mac; then
				check_type+=" ($mounted_type"
			else
				check_type+=" type $mounted_type "
			fi
		fi

		# coerce log
		log_source="$option_type"
		if test -n "$option_user"; then
			log_source+="[user=$option_user]"
		fi
		if test -n "$option_group"; then
			log_source+="[group=$option_group]"
		fi
		if test -n "$option_owner"; then
			log_source+="[owner=$option_owner]"
		fi
		if test -n "$option_username"; then
			log_source+="[username=$option_username]"
		fi
		if test -n "$option_password"; then
			log_source+="[password=redacted]"
		fi
		if test -n "$option_server"; then
			log_source+="[server=$option_server]"
		fi
		if test -n "$option_label"; then
			log_source+="[label=$option_label]"
		fi
		if test -n "$option_count"; then
			log_source+="[count=$option_count]"
		fi
		if test -n "$option_share"; then
			log_source+="[share=$option_share]"
		fi

		# helpers
		function do_parse {
			echo
			string_dump \
				log_source option_actions option_remount option_source option_target '' \
				mount_source mounted_source fstab_source open_source gocryptfs_source '' \
				mount_type mounted_type fstab_type mount_fstab_options '' \
				check_source check_target check_type '' \
				fstab_line cron_line
			value_dump \
				open_cmd "${open_cmd[*]}" \
				gocryptfs_cmd "${gocryptfs_cmd[*]}" \
				mount_cmd "${mount_cmd[*]}" \
				mounting_cmd "${mounting_cmd[*]}"
		}
		function do_automount_adjust {
			local fstab_lines='' cron_lines='' automount_action="$1"
			if test -z "$option_share" -o -z "$option_target"; then
				echo-error "[mount-helper --automount] requires <share> and <target>"
				return 22 # Invalid argument
			fi

			# fstab
			echo
			if test -z "$fstab_line"; then
				echo-style 'Automounting via ' --invert='fstab' ' is ' --negative='unsupported' ' for ' --code="$log_source"
			else
				echo-style 'Automounting via ' --invert='fstab' ' is ' --positive='supported' ' for ' --code="$log_source"
			fi
			if test "$automount_action" = 'remove'; then
				fstab_line=''
				echo-style 'Automounting via ' --invert='fstab' ' is ' --negative='undesired.'
			else
				echo-style 'Automounting via ' --invert='fstab' ' is ' --positive='desired.'
			fi
			while true; do
				fstab_lines="$(cat /etc/fstab | rg --fixed-strings --regexp="$(echo-fstab-encode "$option_target")" || :)"
				if test "$fstab_lines" = "$fstab_line"; then
					echo-style 'Your ' --invert='fstab' ' configuration is ' --positive='correctly' ' configured.'
					if test -z "$fstab_line"; then
						echo-style --positive='No changes necessary.'
					else
						echo-style --positive='It already has these lines:' $'\n' --code="$fstab_line"
					fi
					echo
					break
				else
					echo-style 'Your ' --invert='fstab' ' configuration is ' --negative='incorrectly' ' configured.'
					if test -n "$fstab_lines"; then
						echo-style --negative='You must remove these lines:' $'\n' --code="$fstab_lines"
					fi
					if test -n "$fstab_line"; then
						echo-style --positive='You must add this line:' $'\n' --code="$fstab_line"
					fi
					if confirm --positive --ppid=$$ -- "Ready to continue?"; then
						edit --sudo -- '/etc/fstab' || :
					else
						return 125 # ECANCELED 125 Operation cancelled
					fi
					echo
				fi
			done

			# cron
			echo
			if test -z "$cron_line"; then
				echo-style 'Automounting via ' --invert='cron' ' is ' --negative='unsupported' ' for ' --code="$log_source"
			else
				echo-style 'Automounting via ' --invert='cron' ' is ' --positive='supported' ' for ' --code="$log_source"
			fi
			if test "$automount_action" = 'remove'; then
				cron_line=''
				echo-style 'Automounting via ' --invert='cron' ' is ' --negative='undesired.'
			else
				echo-style 'Automounting via ' --invert='cron' ' is ' --positive='desired.'
			fi
			while true; do
				cron_lines="$("${sudo_cmd[@]}" crontab -l | sponge | rg --fixed-strings --regexp="$option_target" || :)"
				if test "$cron_lines" = "$cron_line" || [[ "$automount_action" == 'add' && "$cron_lines" == *cronitor* ]]; then
					echo-style 'Your ' --invert='cron' ' configuration is ' --positive='correctly' ' configured.'
					if test -z "$cron_line"; then
						echo-style --positive='No changes necessary.'
					else
						echo-style --positive='It already has these lines:' $'\n' --code="$cron_line"
					fi
					echo
					break
				else
					echo-style 'Your ' --invert='cron' ' configuration is ' --negative='incorrectly' ' configured.'
					if test -n "$cron_lines"; then
						echo-style --negative='You must remove these lines:' $'\n' --code="$cron_lines"
					fi
					if test -n "$cron_line"; then
						echo-style --positive='You must add this line:' $'\n' --code="$cron_line"
					fi
					if confirm --positive --ppid=$$ -- "Ready to continue?"; then
						"${sudo_cmd[@]}" env EDITOR="$(edit --dry --terminal)" crontab -e || :
					else
						return 125 # ECANCELED 125 Operation cancelled
					fi
					echo
				fi
			done
		}
		function do_automount_remove {
			do_automount_adjust 'remove'
		}
		function do_automount_add {
			do_automount_adjust 'add'
		}
		function do_check {
			local filter=''

			# check if invalid
			if test -z "$check_source" -a -z "$check_target" -a -z "$check_type"; then
				echo-error "[mount-helper --check] requires at least <source>, <target>, or <type>"
				return 22 # Invalid argument
			fi

			# start filtering
			filter="$(mount)"
			if test -n "$check_source"; then
				filter="$(echo "$filter" | rg --fixed-strings --regexp="$check_source" || :)"
				if test -z "$filter"; then
					echo-style --notice='mount source is not mounted:' ' ' --code="$mounted_source"
					return 1
				fi
				echo-style --success='mount source is mounted:' ' ' --code="$mounted_source"
			fi
			if test -n "$check_target"; then
				filter="$(echo "$filter" | rg --fixed-strings --regexp="$check_target" || :)"
				if test -z "$filter"; then
					echo-style --notice='mount target is not mounted:' ' ' --code="$option_target"
					return 1
				fi
				echo-style --success='mount target is mounted:' ' ' --code="$option_target"
			fi
			if test -n "$check_type"; then
				filter="$(echo "$filter" | rg --fixed-strings --regexp="$check_type" || :)"
				if test -z "$filter"; then
					echo-style --notice='mount type is not mounted:' ' ' --code="$mounted_type"
					return 1
				fi
				echo-style --success='mount type is mounted:' ' ' --code="$mounted_type"
			fi
		}
		function do_unmount {
			local was_mounted='maybe' unmount_confirm_ec

			# check if invalid
			if test -z "$option_target"; then
				echo-error "[mount-helper --unmount] requires <target>"
				return 22 # Invalid argument
			fi

			# is the relative mount point missing
			if test ! -e "$option_target"; then
				echo-style --code="$option_target" ' ' --success="was previously unmounted"
				return 0
			fi

			# is the resolved mount point missing
			was_mounted='maybe'
			if test ! -e "$option_target"; then
				echo-style --code="$option_target" ' ' --success="was previously unmounted"
				return 0
			fi

			# if mounted, then unmount
			while true; do
				if do_check; then
					was_mounted='yes'
					if sudo-helper -- umount --verbose --recursive "$option_target"; then
						echo-style --code="$option_target" ' ' --notice="was unmounted"
					else
						# https://github.com/rfjakob/gocryptfs/issues/459
						what-is-using "$option_target"
						unmount_confirm_ec=0 && confirm --positive --ppid=$$ -- "Yes for try again, no for force, ctrl+c for abort" || unmount_confirm_ec="$?"
						if test "$unmount_confirm_ec" -eq 1; then
							sudo-helper -- umount --verbose --recursive --force "$option_target"
							echo-style --code="$option_target" ' ' --notice="was forcefully unmounted"
						fi
					fi
				else
					was_mounted='no'
					echo-style --code="$option_target" ' ' --notice="was not an active mount"
					break
				fi
			done

			# check if still mounted
			if test "$was_mounted" = 'yes'; then
				if do_check; then
					echo-style --code="$option_target" ' ' --error="failed to unmount"
					return 66 # Directory not empty
				fi
				echo-style --code="$option_target" ' ' --success="was unmounted successfully"
			fi

			# clean up
			if test -e "$option_target"; then
				fs-rm --sudo -- "$option_target"
			fi
			if test -e "$option_target"; then
				echo-style --code="$option_target" ' ' --success="was unmounted successfully" ', ' --error="but failed to clean up"
				return 66 # Directory not empty
			fi
			echo-style --code="$option_target" ' ' --success="was cleaned successfully"

			# success
			echo-style --code="$option_target" ' ' --success="was unmounted and cleaned successfully"
			return 0
		}
		function do_mount {
			local mount_confirm_ec

			# check if invalid
			if test -z "$option_share" -o -z "$option_target"; then
				echo-error "[mount-helper --mount] requires <share> and <target>"
				return 22 # Invalid argument
			fi

			# verify mounting
			if test "${#mounting_cmd[@]}" -eq 0; then
				echo-error "Unable to understand how to mount the source:" ' ' --code="$log_source"
				return 22 # Invalid argument
			fi

			# if already mounted then ignore
			if test -d "$option_target"; then
				if do_check; then
					# is mounted
					if test "$option_remount" = 'yes'; then
						# remount
						echo-style --code="$log_source" --bold=" already mounted to " --code="$option_target" ' ' --notice="but remounting."
					elif test "$option_remount" = 'no'; then
						# already mounted, exit
						echo-style --code="$log_source" --bold=" already mounted to " --code="$option_target" ' ' --success="and not remounting."
						return 0
					else
						# already mounted, remount?
						echo-style --code="$log_source" --bold=" already mounted to " --code="$option_target"
						mount_confirm_ec=0 && confirm --negative --ppid=$$ -- 'Do you wish to remount?' || mount_confirm_ec="$?"
						if test "$mount_confirm_ec" -eq 1; then
							# already mounted, exit
							echo-style --success="was previously mounted."
							return 0
						fi
					fi
				fi
				# user wanted to remount, or the check failed to validate that source was at that target
				do_unmount
			fi

			# if not mounted, go through the process
			if test "$mounting_safety" = 'yes'; then
				# make the directory as the user, otherwise as sudo
				mkdir -p "$option_target" || sudo-helper -- mkdir -p "$option_target"

				# chown
				eval-helper --no-quiet --wrap --shapeshifter \
					-- fs-own --no-quiet --changes \
					--owner="$option_owner" \
					--user="$option_user" \
					--group="$option_group" \
					-- "$option_target"
			fi

			# mount
			eval-helper --no-quiet --wrap \
				-- "${mounting_cmd[@]}"

			# check
			if test "$mounting_safety" = 'yes'; then
				# ls
				eval-helper --no-quiet --wrap \
					-- "${ls_cmd[@]}"

				# chown
				if test -n "$option_owner" -o -n "$option_user" -o -n "$option_group"; then
					eval-helper --no-quiet --wrap --shapeshifter \
						-- fs-own --no-quiet --changes \
						--owner="$option_owner" \
						--user="$option_user" \
						--group="$option_group" \
						-- "$option_target"
				fi
			fi

			# log
			echo-style --code="$log_source" ' ' --success="successfully mounted to" ' ' --code="$option_target"
		}

		# parse
		if [[ $option_actions == *'[parse]'* ]]; then
			do_parse
		fi

		# check
		if [[ $option_actions == *'[check]'* ]]; then
			do_check
		fi

		# automount option for mount
		if [[ $option_actions == *'[automount]'* ]]; then
			do_automount_add
		fi
		if [[ $option_actions == *'[unautomount]'* ]]; then
			do_automount_remove
		fi

		# unmount
		if [[ $option_actions == *'[unmount]'* ]]; then
			do_unmount
		fi

		# mount
		if [[ $option_actions == *'[mount]'* ]]; then
			do_mount
		fi
	}

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			USAGE:
			mount-helper ...[-- ...options]

			OPTIONS:

			Actions can be combined, however at least one is required:
			--action=<parse|check|mount|unmount|automount|unautomount>
			[--parse]
			    Outputs the parsed formats.
			[--check|--mounted]
			[--mount]
			[--unmount]
			[--automount]
			[--unautomount|--no-automount]

			Only one type can be specified:
			--type=<samba|gocryptfs|btrfs|device>
			[--<samba|smb|smbfs|cifs>]
			[--<gocryptfs|fuse.gocryptfs>]
			[--btrfs]
			[--<device|drive|disk>]

			Mount target permissions:
			[--user=<user>]
			[--group=<group>]
			[--owner=<owner>]

			Source connection permissions:
			[--username=<username>]
			    Applicable to <samba>.
			[--password=<password>]
			    Applicable to <samba> and <gocryptfs>.
			[--server=<server>]
			    Aplicable to <samba>.

			[--label=<label>]
			    When using btrfs, this is the label of the source device, can infer the <share> from it.
			    If both <share> and <label> are provided, we will validate they are equivalent.
			[--count=<count>]
			    When using btrfs, this is the amount of devices that comprise the mount.

			--share=<share>
			    When using <samba>, this is the share name.
			    When using <gocryptfs>, this is the vault path.
			    When using <btrfs|device>, this is the /dev/... path.

			--target=<target>
			    This is the mount location.
			    If <samba> and MacOS, this is inferred as /Volumes/<share>

			USAGE:

			mount-helper \
				-- --action=... --device --share='/dev/...' --target='/Volumes/folder' \
				-- --action=... --btrfs [--label='...'] [--count=...] [--share='/dev/...'] --target='/Volumes/folder' \
				-- --action=... --gocryptfs --share='/path/to/vault' --target='/Volumes/folder' \
				-- --action=... --samba --server='ip' --share='folder' --target='/Volumes/folder' \
				-- --automount --samba --username='user' --password='pass' --server='ip' --share='folder' --target='/Volumes/folder'
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# process
	local item
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;

		'--type='*) item="--${item#*--type=}" ;;&
		'--parse') option_actions+='[parse]' ;;
		'--mount') option_actions+='[mount]' ;;
		'--unmount') option_actions='[unmount]' ;;
		'--check' | '--mounted') option_actions='[check]' ;;
		'--automount') option_actions+='[automount]' ;;
		'--unautomount' | '--no-automount' | '--automount=no' | '--automount=false') option_actions+='[unautomount]' ;;

		'--no-remount'* | '--remount'*) option_remount="$(
			get-flag-value remount --missing="$option_remount" -- "$item" | echo-affirmative
		)" ;;

		'--type='*) option_type="${item#*--type=}" ;;
		'--samba' | '--smb' | '--smbfs' | '--cifs') option_type='samba' ;;
		'--gocryptfs' | '--fuse.gocryptfs') option_type='gocryptfs' ;;
		'--btrfs') option_type='btrfs' ;;
		'--device' | '--drive' | '--disk') option_type='device' ;;

		'--user='*) option_user="${item#*--user=}" ;;
		'--group='*) option_group="${item#*--group=}" ;;
		'--owner='*) option_owner="${item#*--owner=}" ;;

		'--username='*) option_username="${item#*--username=}" ;;
		'--password='*) option_password="${item#*--password=}" ;;
		'--server='*) option_server="${item#*--server=}" ;;

		'--label='*) option_label="${item#*--label=}" ;;
		'--count='*) option_count="${item#*--count=}" ;;

		'--share='*) option_share="${item#*--share=}" ;;
		'--source='*) option_source="${item#*--source=}" ;;
		'--target='*) option_target="${item#*--target=}" ;;
		'--')
			# act on prior group
			action
			reset
			;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# act on remaining group
	action
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	mount-helper "$@"
fi
