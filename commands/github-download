#!/usr/bin/env bash

function github_download() (
	source "$DOROTHY/sources/bash.bash"
	require_array 'mapfile'

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Download a file from a GitHub repository.

			USAGE:
			github-download [...options]

			OPTIONS:
			--slug=<org>/<repo>
			    Use this repository, e.g. 'jqlang/jq'

			--head | --HEAD
			    Get the latest commit on the default branch, typically 'main' or 'master'
			--branch=<branch>
			    Use this branch, e.g. 'main', 'master', etc.
			--tag=<tag>
			    Use this reference or release tag name, e.g. 'jq-1.7rc2'
			--commit=<commit>
			    Use this commit, e.g. '94d6971fac4033b2f06e1d9793053a89f52d3ffd
			--reference=<branch,commit,tag> | --ref=<branch,commit,tag>
			    Deprecated alias for --branch=<branch>, --commit=<commit>, and --tag=<tag>

			--latest
			    Use the latest release. Alias for ---alias=latest
			--alias=<alias>
			    Use this release alias, e.g. 'latest'
			--tag=<tag>
			    Use this reference or release tag name, e.g. 'jq-1.7rc2'
			--id=<id>
			    Use this release id, e.g. '118848514'
			--release=<alias,tag,id>
			    Deprecated alias for either --alias=<alias>, --tag=<tag>, --id=<id>

			--pathname=<pathname>
			    If downloading a reference, filter by this pathname, e.g. 'commands/github-download'

			--asset-filter=<regexp>
			    If downloading a release, filter assets by this.

			--archive-format=<format> | --archive-format=<format>
			    If downloading an archive file, use this to enforce an extraction <format>.
			    This option is handled by the [unziptar] command.

			--archive-filter=<filter> | --archive-filter=<filter>
			    If downloading an archive file, use this to only extract files that match the glob pattern <filter>.
			    This option is handled by the [unziptar] command.

			--directory=<directory>
			    Place downloaded file(s) inside <directory>.
			    If ommitted, the current working directory will be used.

			--file=<file>
			    If only a single file was downloaded, rename it to <file>.
			    If multiple files were downloaded, then fail.

			--filepath=<directory>/<file>
			    If only a single file was downloaded, rename it to <file>, and place it inside <directory>.
			    If multiple files were downloaded, then fail.

			--[no-]quiet
			    Whether or not output should be simplified, defaults to enabled.

			--[no-]dry
			    Whether or not to only output the resolved URL and do nothing else.

			QUIRKS:
			To get the release identifier of a tag that hasn't been promoted to a release:
			fetch 'https://bevry.me/api/github/repos/jqlang/jq/releases' | jq -r '.[] | {tag_name, id}'
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item slug='' branch='' commit='' reference='' alias='' tag='' id='' release='' pathname='' asset_filter='' archive_format='' archive_filter='' directory='' file='' filepath='' quiet='yes' dry='no'
	quiet="$(is-quiet-enabled "$quiet" -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by is-quiet-enabled
		# repo
		'--slug='*) slug="${item#*--slug=}" ;;
		# reference
		'--head' | '--HEAD') reference='HEAD' ;;
		'--branch='*) branch="${item#*--branch=}" ;;
		'--commit='*) commit="${item#*--commit=}" ;;
		'--reference='*) reference="${item#*--reference=}" ;;
		'--ref='*) reference="${item#*--ref=}" ;;
		'--pathname='*) pathname="${item#*--pathname=}" ;;
		# release
		'--latest') alias='latest' ;;
		'--alias='*) alias="${item#*--alias=}" ;;
		'--tag='*) tag="${item#*--tag=}" ;;
		'--id='*) id="${item#*--id=}" ;;
		'--release='*) release="${item#*--release=}" ;;
		# asset
		'--asset-filter='*) asset_filter="${item#*--asset-filter=}" ;;
		'--unzip-format='*) archive_format="${item#*--unzip-format=}" ;; # deprecated
		'--unzip-filter='*) archive_filter="${item#*--unzip-filter=}" ;; # deprecated
		'--archive-format='*) archive_format="${item#*--archive-format=}" ;;
		'--archive-filter='*) archive_filter="${item#*--archive-filter=}" ;;
		'--directory='*) directory="${item#*--directory=}" ;;
		'--file='*) file="${item#*--file=}" ;;
		'--filepath='*) filepath="${item#*--filepath=}" ;;
		'--no-dry'* | '--dry'*)
			dry="$(get-flag-value dry --missing="$dry" -- "$item" | echo-affirmative --stdin)"
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# enforcements
	if test -z "$slug"; then
		help 'A GitHub repository slug is required.'
	fi
	if test -n "$release"; then
		# convert release into its modern format
		if test "$release" = 'latest'; then
			echo-style --notice='deprecation warning:' ' ' --code_notice="--release=$release → --latest" >/dev/tty
			if test -n "$alias"; then
				help "[--release=latest] and [--alias=$alias] are mutually exclusive, you should only use: --alias=$alias"
			fi
			alias='latest'
		elif is-integer "$release"; then
			echo-style --notice='deprecation warning:' ' ' --code_notice="--release=$release → --id=$release" >/dev/tty
			if test -n "$id"; then
				help "[--release=$release] and [--id=$id] are mutually exclusive, you should only use: --id=$id"
			fi
			id="$release"
		else
			echo-style --notice='deprecation warning:' ' ' --code_notice="--release=$release → --tag=$release" >/dev/tty
			if test -n "$tag"; then
				help "[--release=$release] and [--tag=$tag] are mutually exclusive, you should only use: --tag=$tag"
			fi
			tag="$release"
		fi
	fi
	if test -n "$alias" -a "$alias" != 'latest'; then
		help '<alias> can only be ' --code='latest'
	fi
	if test -z "$release"; then
		# convert release properties into release, to make figuring out what we are doing easier
		if test -n "$alias"; then
			release="$alias"
		elif test -n "$tag"; then
			release="$tag"
		elif test -n "$id"; then
			release="$id"
		fi
	fi
	if test -z "$reference"; then
		# convert references into references, as we actually juse use them as a reference
		if test -n "$branch"; then
			reference="$branch"
		elif test -n "$tag"; then
			reference="$tag"
		elif test -n "$commit"; then
			reference="$commit"
		fi
	fi

	# check for incompatibilities
	if test -n "$release"; then
		# don't check pathname, as tha tcan work for tag
		if test -n "$branch" -o -n "$commit"; then
			help "[--reference/head/branch/commit] and [--release/latest/alias/id] are mutually exclusive"
		fi
	fi
	if test -n "$reference"; then
		# don't check asset-filter, as that can work for tag
		if test -n "$alias" -o -n "$id"; then
			help "[--release/latest/alias/id] and [--reference/head/branch/commit] are mutually exclusive"
		fi
	fi
	if test -n "$asset_filter" -a "$pathname"; then
		help "[--asset-filter] and [--pathname] are mutually exclusive, did you intend to use: --archive-filter=$pathname"
	elif test -n "$asset_filter"; then
		reference=''
	elif test -n "$pathname"; then
		release=''
	fi
	if test -z "$reference" -a -z "$release"; then
		if test -n "$asset_filter"; then
			release='latest'
			alias='latest'
		elif test -n "$pathname"; then
			reference='HEAD'
		else
			release='latest'
			alias='latest'
		fi
	fi

	# ensure directory, filename, filepath
	if test -n "$filepath"; then
		# filepath is a directory + file combination
		filepath="$(fs-absolute -- "$filepath")"
		directory="$(dirname "$filepath")"
		file="$(basename "$filepath")"
	elif test -n "$directory" -a -n "$file"; then
		# directory + file
		filepath="$(fs-absolute -- "$directory/$file")"
		directory="$(dirname "$filepath")"
		file="$(basename "$filepath")"
	elif test -z "$directory" -a -n "$file"; then
		# file, without directory
		filepath="$(pwd)/$file"
		directory="$(dirname "$filepath")"
		file="$(basename "$filepath")"
	elif test -n "$directory" -a -z "$file"; then
		# directory, without file
		directory="$(fs-absolute -- "$directory")"
		filepath='' # it is for dir+file combos only
	else
		directory="$(pwd)"
		filepath='' # it is for dir+file combos only
	fi
	mkdir -p "$directory"

	# =====================================
	# Action

	function get_assets {
		# we don't care for all assets, just the release in it's entirety
		if test -z "$asset_filter"; then
			get-github-release --slug="$slug" --tar --alias="$alias" --tag="$tag" --id="$id"
			return
		fi

		# get the assets [name, url] for the release
		local assets=()
		mapfile -t assets < <(get-github-release --slug="$slug" --assets --alias="$alias" --tag="$tag" --id="$id")
		if test "${#assets[@]}" -eq 0; then
			echo-error 'No release assets were found for repository ' --code="$slug"
			return 1
		fi

		# filter out junk, and filter names according to the asset-filter, keeping only urls
		local index name url matches=()
		for ((index = 0; index < ${#assets[@]}; index = index + 2)); do
			name="${assets[index]}"
			url="${assets[index + 1]}"
			# neovim: .sha256sum, .zsync
			# tealdeer: .sha
			# gocryptfs: .asc
			# vsh: .sbom
			if grep --quiet --extended-regexp --regexp='[.](asc|mini|sbom|sha256sum|sha256|sha|sig|zsync)$' <<<"$name"; then
				# ignore signature assets
				continue
			elif test -z "$asset_filter"; then
				# no asset filter, add them all
				matches+=("$url")
			elif test "$asset_filter" = "$name"; then
				# exact match, use only that
				matches=("$url")
				break
			elif grep --quiet --extended-regexp --regexp="$asset_filter" <<<"$name"; then
				# regexp match, make note
				matches+=("$url")
			fi # no match, ignore
		done

		# filtering worked
		if test "${#matches[@]}" -eq 0; then
			{
				echo-style --error='No assets matched the filter:' ' ' --code="$asset_filter"
				echo-verbose -- "${assets[@]}"
			} >/dev/stderr
			return 1
		fi

		# output only the matching urls
		echo-lines -- "${matches[@]}"
	}
	function get_ref_pathname_url {
		# determine branch
		if test -z "$reference"; then
			if fetch --ok "https://raw.githubusercontent.com/$slug/master/$pathname"; then
				reference='master'
			elif fetch --ok "https://raw.githubusercontent.com/$slug/main/$pathname"; then
				reference='main'
			else
				help "Unable to determine the [--ref] automatically, you must specify it manually."
			fi
		fi

		# download
		print_line "https://raw.githubusercontent.com/$slug/$reference/$pathname"
	}
	function download_reference {
		local url filter
		if test -n "$pathname"; then
			url="$(get_ref_pathname_url)"
			filter="$archive_filter"
		else
			url="https://github.com/$slug/archive/$reference.tar.gz"
			filter="*-$reference/${archive_filter:-"*"}"
		fi
		if test "$dry" = 'yes'; then
			print_line "$url"
			return 0
		fi
		down "$url" \
			--quiet="$quiet" \
			--archive-format="$archive_format" \
			--archive-filter="$filter" \
			--directory="$directory" \
			--file="$file" \
			--filepath="$filepath"
	}
	function download_release {
		local asset assets
		mapfile -t assets < <(get_assets)
		if test "${#assets[@]}" -eq 0; then
			echo-error 'No download assets were found for repository ' --code="$slug"
			return 1
		fi
		for asset in "${assets[@]}"; do
			if test "$dry" = 'yes'; then
				print_line "$asset"
				continue
			fi
			down "$asset" \
				--quiet="$quiet" \
				--archive-format="$archive_format" \
				--archive-filter="$archive_filter" \
				--directory="$directory" \
				--file="$file" \
				--filepath="$filepath"
		done
	}

	# =====================================
	# Action

	if test -n "$reference"; then
		download_reference # prefer tag via reference, as is quicker than via release
	elif test -n "$release"; then
		download_release
	else
		help 'Invalid combination of options.'
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	github_download "$@"
fi
