#!/usr/bin/env bash

function echo_file() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Output the contents of the passed file paths.

			USAGE:
			echo-file ...[options] [--] ...<paths>

			OPTIONS:
			--[no-]bat
			    If affirmative, install and use [bat] if it doesn't exist.
				If missing, use [bat] if it exists.
				If negative, don't use [bat].

			--raw
			    No line numbers or filename, only file contents.

			--plain
			    No line numbers.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_bat='' option_raw='no' option_plain='no' ARGS=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-bat'* | '--bat'*)
			option_bat="$(get-flag-value bat --missing="$option_bat" -- "$item" | echo-affirmative)"
			;;
		'--no-raw'* | '--raw'*)
			option_raw="$(get-flag-value raw --missing="$option_raw" -- "$item" | echo-affirmative)"
			;;
		'--no-plain'* | '--plain'*)
			option_plain="$(get-flag-value plain --missing="$option_plain" -- "$item" | echo-affirmative)"
			;;
		'--')
			ARGS+=("$@")
			shift "$#"
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) ARGS+=("$item") ;;
		esac
	done

	# install bat if yes
	if test "$option_bat" = 'yes' && command-missing bat; then
		setup-util-bat --quiet --optional
	fi
	# use bat only if it exists
	if test -z "$option_bat" -o "$option_bat" = 'yes'; then
		option_bat="$(echo-exit-affirmative -- command-exists bat)"
	fi

	# =====================================
	# Action

	if test "$option_raw" = 'yes'; then
		# raw
		function echo_files {
			local file result=0
			while test "$#" -ne 0; do
				file="$1"
				shift
				if test -f "$file"; then
					echo-trim-stdin <"$file"
				else
					echo-style --error="The file does not exist." >/dev/stderr
					result=2 # ENOENT No such file or directory
					# ^ dont like this, so that all files are noted before crash
				fi
				if test "$#" -ne 0; then
					echo
					echo
				fi
			done
			return "$result"
		}
	else
		# plain/bat
		local bat_cmd=(
			'bat'
			'--paging=never'
		)
		if test "$option_plain" = 'yes'; then
			bat_cmd+=('--plain')
		fi
		if test -z "${BAT_THEME-}"; then
			# don't use [get-terminal-theme] THEME fallback, as no need, if [get-terminal-theme] is working correctly, then THEME is defined
			if test "${THEME-}" = 'light'; then
				bat_cmd+=(
					'--theme=ansi'
				)
			elif test "${THEME-}" = 'dark'; then
				bat_cmd+=(
					'--theme=1337'
				)
			else
				bat_cmd=()
				# bat is installed, but without knowing the terminal theme, we cannot be sure that the bat theme is readable
			fi
		fi

		function echo_file_bat {
			local file="$1"
			if test "$option_plain" = 'yes'; then
				echo-element --open="$file"
				"${bat_cmd[@]}" "$file"
				echo
				echo-element --close="$file"
			else
				"${bat_cmd[@]}" "$file"
			fi
		}
		function echo_files {
			local file result=0 bat_status=1
			while test "$#" -ne 0; do
				file="$1"
				shift
				if test -f "$file"; then
					if test "$option_bat" = 'yes'; then
						eval_capture --statusvar=bat_status -- echo_file_bat "$file"
					fi
					if test "$bat_status" -ne 0; then
						echo-element --open="$file"
						echo-style --code="$(echo-trim-stdin <"$file")"
						echo-element --close="$file"
					fi
				else
					echo-element --open="$file" >/dev/stderr
					echo-style --error="The file does not exist." >/dev/stderr
					echo-element --close="$file" --status=2 >/dev/stderr
					result=2 # ENOENT No such file or directory
					# ^ dont like this, so that all files are noted before crash
				fi
				if test "$#" -ne 0; then
					echo
					echo
				fi
			done
			return "$result"
		}
	fi

	local files=()
	function on_input {
		files+=("$1")
	}
	function on_finish {
		echo_files "${files[@]}"
	}

	source "$DOROTHY/sources/stdinargs.bash"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	echo_file "$@"
fi
