#!/usr/bin/env bash

# QUIRKS:
# - if there are more options than [$LINES - header], then this will fall apart

# TODOS:
# - [ ] limit the options output to [$LINES - header]
# - [ ] if one gets to $LINES, and there are truncated values, then scroll downwards
# - [ ] support $COLUMNS - if a menu item is larger than the column, then it will show all of it when active
# - [ ] ctrl n/p for navigating up/down.
# - [ ] `hjkl` vim arrow keys.

function choose_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-segment --h1="TEST: $0"

	## choose-menu ##

	# timeout response not required
	eval-tester --name='timeout response not required' --status='60' --stderr='Read timed out [60], without selection.' \
		-- env NO_COLOR=yes choose --index --question='timeout response not required' --timeout=5 -- a b c

	# timeout response is required
	eval-tester --name='timeout response is required' --status='60' --stderr='Read timed out [60], without selection.' \
		-- env NO_COLOR=yes choose --index --question='timeout response is required' --timeout=5 --required -- a b c

	# default response
	{
		sleep 3
	} | eval-tester --name='default response' --stdout='1' --ignore-stderr \
		-- choose --index --question='default response' --timeout=2 --default=b -- a b c

	# default response should clear on movement
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
	} | eval-tester --name='default response should clear on movement' --status='60' --stdout='' --ignore-stderr \
		-- choose --index --question='default response should clear on movement' --timeout=10 --default=b -- a b c

	# default multi response
	{
		sleep 3
	} | eval-tester --name='default multi response' --stdout=$'1\n2' --ignore-stderr \
		-- choose --index --question='default multi response' --timeout=2 --multi --default=b --default=c -- a b c

	# default multi response should not clear on movement
	{
		sleep 3
		printf $'\eOB'
		sleep 3
	} | eval-tester --name='default multi response should not clear on movement' --stdout=$'1\n2' --ignore-stderr \
		-- choose --index --question='default multi response should not clear on movement' --timeout=10 --multi --default=b --default=c -- a b c

	# multiline defaults
	{
		sleep 3
	} | eval-tester --name='default multiline response' --stdout=$'1\n2\n3' --ignore-stderr \
		-- choose --index --question='default multiline response' --timeout=2 --multi --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d

	# first selection
	{
		sleep 3
		echo
	} | eval-tester --name='first response' --stdout='0' \
		-- choose --index --question='first selection' -- a b c

	# second selection
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
		echo
	} | eval-tester --name='second response' --stdout='1' \
		-- choose --index --question='second selection' -- a b c

	# abort response via escape
	{
		# press escape key
		sleep 3
		printf $'\x1b'
	} | eval-tester --name='abort response via escape' \
		-- choose --index --question='abort response via escape' -- a b c

	## choose ##

	# timeout response not required
	eval-tester --name='timeout response not required' --status='0' --stderr=$'Read timed out [60], without selection.\nMenu timed out [60], no result, not required.' \
		-- env NO_COLOR=yes choose --question='timeout response not required' --timeout=5 -- a b c

	# timeout response is required
	eval-tester --name='timeout response is required' --status='60' --stderr=$'Read timed out [60], without selection.\nMenu timed out [60], no result, is required.' \
		-- env NO_COLOR=yes choose --question='timeout response is required' --timeout=5 --required -- a b c

	# default response
	{
		sleep 3
	} | eval-tester --name='default response' --stdout='b' --ignore-stderr \
		-- choose --question='default response' --timeout=2 --default=b -- a b c

	# default multi response
	{
		sleep 3
	} | eval-tester --name='default multi response' --stdout=$'b\nc' --ignore-stderr \
		-- choose --question='default multi response' --timeout=2 --multi --default=b --default=c -- a b c

	# first selection
	{
		sleep 3
		echo
	} | eval-tester --name='first selection' --stdout='a' \
		-- choose --question='first selection' -- a b c

	# second selection
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
		echo
	} | eval-tester --name='second selection' --stdout='b' \
		-- choose --question='second selection' -- a b c

	# abort response via escape
	{
		# press escape key
		sleep 3
		printf $'\x1b'
	} | eval-tester --name='abort response via escape' \
		-- choose --question='abort response via escape' -- a b c

	echo-segment --g1="TEST: $0"
	return 0
)
function choose_() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/tty.bash"
	__require_array 'mapfile'

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Prompt the user to select an item from the menu, in a clean and robust way.

			USAGE:
			choose [...options] -- ...<item>

			OPTIONS:
			<question> | --question=<question>
			    Display this question in the prompt. If specified multiple times, they will be joined by newline, and only the first will be lingered.

			--label -- ...[<value> <label>]
			    Pass values and labels.

			--label=first -- ...[<label> <value>]
			    Pass values and labels, with the label first.

			--visual='\$LABEL' -- ...[<value> <label>]
			    Customise what is displayed to the user. It is eval'd. E.g.
			    To show label and value, use: --visual='\$LABEL [\$VALUE]'
			    If empty LABEL, then will equal VALUE.

			--return='\$VALUE' -- ...[<value> <label>]
			    Customise how the value is returned to the program. It is eval'd. E.g.
			    To return the visual, use: --return='\$VISUAL'
			    Tto return the index, use: --return='\$INDEX' or --index

			--default-exact=<value>
			--defaults-exact=<newline separated values>
			    Pre-select <value>s by exact matching.

			--default-fuzzy=<value>
			--defaults-fuzzy=<newline separated values>
			    Pre-select <value>s by fuzzy matching.

			--[no-]confirm=[yes|no]
			    Confirm the (default/entered) value(s) before continuing.

			--[no-]confirm-default=[YES|no] | --[no-]skip-default=[yes|NO]
			    Confirm the default value(s) (if provided) before continuing. Defaults to enabled.

			--[no-]confirm-input=[yes|NO]
			    Confirm the entered value(s) before continuing. Defaults to disabled.

			--[no-]required=[yes|NO]
			    Do not continue until a selection is made. Disable aborting the prompt.

			--[no-]multi=[yes|NO]
			    Multiple items can be selected.

			--[no-]hints=[YES|no]
			    Display interaction hint line.

			--[no-]linger=[yes|NO]
			    Whether the prompt should persist afterwards.

			--timeout=<timeout>
			    Custom timeout value in seconds.

			QUIRKS:
			If you wish to return the index, which is desirable in the case of when multiple values can be identical, use --index or --return='\$INDEX'.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item='' inputs=() tmp=()
	local option_question=()
	# trunk-ignore(shellcheck/SC2016)
	local option_label='no' option_visual='' option_return='$VALUE'
	local defaults_exact=() defaults_fuzzy=() option_confirm_default='yes' option_confirm_input='no'
	local option_required='no' option_multi='no' option_hints='yes'
	local option_linger='no' option_timeout=''
	local use_colors
	use_colors="$(echo-color-enabled --fallback=yes -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-color'* | '--color'*) ;; # handled by echo-color-enabled
		'--question='*) option_question+=("${item#*=}") ;;
		'--no-label'* | '--label'*)
			# label can be 'yes', 'no', and 'first'
			option_label="$(get-flag-value --fallback="$option_label" -- "$item")"
			;;
		'--visual='*) option_visual="${item#*=}" ;;
		'--return='*) option_return="${item#*=}" ;;
		# trunk-ignore(shellcheck/SC2016)
		'--index') option_return='$INDEX' ;;
		'--default-exact='* | '--default='*) defaults_exact+=("${item#*=}") ;;
		'--defaults-exact='* | '--defaults='*)
			mapfile -t tmp <<<"${item#*=}"
			defaults_exact+=("${tmp[@]}")
			;;
		'--default-fuzzy='*) defaults_fuzzy+=("${item#*=}") ;;
		'--defaults-fuzzy='*)
			mapfile -t tmp <<<"${item#*=}"
			defaults_fuzzy+=("${tmp[@]}")
			;;
		'--no-skip-default'* | '--skip-default'*)
			option_confirm_default="$(get-flag-value --non-affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-default'* | '--confirm-default'*)
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			;;
		'--no-confirm-input'* | '--confirm-input'*)
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--no-confirm'* | '--confirm'*)
			option_confirm_default="$(get-flag-value --affirmative --fallback="$option_confirm_default" -- "$item")"
			option_confirm_input="$(get-flag-value --affirmative --fallback="$option_confirm_input" -- "$item")"
			;;
		'--no-required'* | '--required'*)
			option_required="$(get-flag-value --affirmative --fallback="$option_required" -- "$item")"
			;;
		'--no-multi'* | '--multi'*)
			option_multi="$(get-flag-value --affirmative --fallback="$option_multi" -- "$item")"
			;;
		'--no-hints'* | '--hints'*)
			option_hints="$(get-flag-value --affirmative --fallback="$option_hints" -- "$item")"
			;;
		'--no-linger'* | '--linger'*)
			option_linger="$(get-flag-value --affirmative --fallback="$option_linger" -- "$item")"
			;;
		'--timeout='*) option_timeout="${item#*=}" ;;
		'--')
			inputs+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) option_question+=("$item") ;;
		esac
	done

	# ensure items were provided
	if test "${#inputs[@]}" -eq 0; then
		help 'No <item>s provided.'
	fi

	# styles
	local style_dim=$'\e[2m' style_bold=$'\e[1m' style_reset=$'\e[0m'

	# adjust question
	local question_title question_with_body
	if test "${#option_question[@]}" -ne 0; then # bash v3 compat
		if test -n "${option_question[0]}"; then
			question_title="$style_bold${option_question[0]}$style_reset"
			question_with_body="$(__print_lines "$question_title" "${option_question[@]:1}")"
		else
			question_title="$(__print_lines "${option_question[@]:1}")"
			question_with_body="$question_title"
		fi
	else
		question_title=''
		question_with_body=''
	fi

	# enforce question if lingering
	if test "$option_linger" = 'yes' -a -z "$question_title"; then
		help 'A <question> is required when using --linger'
	fi

	# generic helpers
	function __fuzzy_haystack_needle {
		local haystack="$1" needle="$2"
		[[ "$(__lowercase_string "$haystack")" == *"$(__lowercase_string "$needle")"* ]]
	}

	# prepare label handling
	local inputs_step=1
	if test "$option_label" != 'no'; then
		# because of labels, we will iterate items two at a time
		inputs_step=2

		# verify we have a label for each value
		if is-odd -- "${#inputs[@]}"; then
			{
				echo-style --colors="$use_colors" --error="The amount of <label>s must match the amount of <value>s. See [$0 --help] for usage." $'\n' --bold='Make the below provide an even amount of items, to ensure there is a <label> for each <value>.'
				echo-verbose -- "${inputs[@]}"
			} >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
	fi

	# generate the items
	# @todo add support for option_default_indexes if a user requests it
	local index INDEX=-1 VALUE LABEL VISUAL RETURN items=() returns=() default default_indexes=()
	for ((index = 0; index < ${#inputs[@]}; index = index + inputs_step)); do
		# index considers inputs_step, INDEX is only each item (label/value combo)
		INDEX=$((INDEX + 1))

		# order of
		if test "$option_label" = 'no'; then
			VALUE="${inputs[index]}"
			LABEL="$VALUE"
			if test -z "$VALUE"; then
				echo-style --colors="$use_colors" --error="The $INDEX item at index $index was empty, all items must be non-empty." >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
		else
			if test "$option_label" = 'yes'; then
				VALUE="${inputs[index]}"
				LABEL="${inputs[index + 1]}"
			elif test "$option_label" = 'first'; then
				VALUE="${inputs[index + 1]}"
				LABEL="${inputs[index]}"
			else
				echo-style --colors="$use_colors" --error="Invalid label option [$option_label], it must be no, yes, or first" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
			if test -z "$LABEL" -o -z "$VALUE"; then
				echo-style --colors="$use_colors" --error="Invalid label=[$LABEL] value=[$VALUE] combination, both must be non-empty" >/dev/stderr
				return 22 # EINVAL 22 Invalid argument
			fi
		fi

		# enable if default
		if test "${#defaults_exact[@]}" -ne 0; then # bash v3 compat
			for default in "${defaults_exact[@]}"; do
				if test "$VALUE" = "$default"; then
					default_indexes+=("$INDEX")
				fi
			done
		elif test "${#defaults_fuzzy[@]}" -ne 0; then # bash v3 compat
			for default in "${defaults_fuzzy[@]}"; do
				if __fuzzy_haystack_needle "$VALUE" "$default"; then
					default_indexes+=("$INDEX")
				fi
			done
		fi

		# generate what is used
		if test -n "$option_visual"; then
			eval "VISUAL=\"$option_visual\""
		else
			VISUAL="$LABEL"
		fi
		if test -z "$VISUAL"; then
			echo-style --colors="$use_colors" --error="Invalid visual=[$VISUAL] for label=[$LABEL] value=[$VALUE], all must be non-empty" >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
		if test -n "$option_return"; then
			eval "RETURN=\"$option_return\""
		else
			RETURN="$VALUE"
		fi
		if test -z "$RETURN"; then
			echo-style --colors="$use_colors" --error="Invalid return=[$RETURN] for label=[$LABEL] value=[$VALUE], all must be non-empty" >/dev/stderr
			return 22 # EINVAL 22 Invalid argument
		fi
		items+=("$VISUAL")
		returns+=("$RETURN")
	done

	# handle default options
	local can_revert_to_defaults can_cancel
	if test "${#default_indexes[@]}" -ne 0; then
		can_revert_to_defaults='yes'
		can_cancel='yes'
		if test "${#default_indexes[@]}" -gt 1 -a "$option_multi" = 'no'; then
			help 'Multiple defaults were found, but --multi was not enabled.'
		fi
	else
		can_revert_to_defaults='no'
		if test "$option_required" = 'no'; then
			can_cancel='yes'
		else
			can_cancel='no'
		fi
	fi

	# prepare vars
	# show the menu
	# one hollow circle: ⚬ ○ ◯ ❍
	# two hollow circles: ◎ ⦾ ⊚
	# one hollow, one full: ☉ ⦿ ◉
	# one full: ●
	# ▣ ▢ □ ⊡
	# ☑ ☒ ⌧
	# ✓ ✔ ✖  ✗  ✘
	local \
		bin_gfmt='' \
		bin_gfold='' \
		bin_gwc='' \
		commentary='' \
		cursor=0 \
		items_last_index \
		items_total="${#items[@]}" \
		menu_header_shrunk='' \
		menu_header_size \
		menu_header='' \
		menu_hint_extras='' \
		menu_hint_shrunk='' \
		menu_hint_size \
		menu_hint_standard='' \
		menu_hint_confirm='' \
		menu_hint='' \
		menu_status=0 \
		page_last_index=0 \
		page_start_index=0 \
		paging_needed \
		paging_supported='yes' \
		renders=() \
		selections=() \
		size_columns_prior=0 \
		size_columns=80 \
		size_content=75 \
		size_rows_prior=0 \
		size_rows=10 \
		sizes=() \
		style_checked \
		style_help_begin="$style_dim" \
		style_help_end="$style_reset" \
		style_indent='  ' \
		style_key_begin \
		style_key_end=" $style_reset" \
		style_magenta=$'\e[35m' \
		style_selected \
		style_unchecked \
		tty_target
	items_last_index="$((items_total - 1))"
	mapfile -t selections < <(get-array "$items_total")
	mapfile -t renders < <(get-array "$items_total")
	mapfile -t sizes < <(get-array "$items_total")

	# prepare paging
	tty_target="$(is-tty --fallback)"
	if test "$tty_target" = '/dev/stderr' || command-missing tput; then
		# fix [tput: No value for $TERM and no -T specified] errors when fetching columns and rows on CI
		paging_supported='no'
		# @todo multi-line items won't be style_indented properly, use fmt if it exists in this mode for item
	else
		if is-mac; then
			bin_gfold="$(type -P 'gfold' 2>/dev/null || :)"
			bin_gfmt="$(type -P 'gfmt' 2>/dev/null || :)"
			bin_gwc="$(type -P 'gwc' 2>/dev/null || :)"
		else
			# we could support these on macos, however fmt does not support -t on macos (it is something different, so we'd have to manually do that)
			bin_gfold="$(type -P 'fold' 2>/dev/null || :)"
			bin_gfmt="$(type -P 'fmt' 2>/dev/null || :)"
			bin_gwc="$(type -P 'wc' 2>/dev/null || :)"
		fi
		if test -z "$bin_gfold" -o -z "$bin_gfmt" -o -z "$bin_gwc"; then
			paging_supported='no'
			# don't bother installing, as that will require brew, and we might now yet have brew installed
		fi
	fi

	# turn the defaults into selections
	function select_defaults {
		local index
		if test "${#default_indexes[@]}" -ne 0; then # bash v3 compat
			for index in "${default_indexes[@]}"; do
				selections[index]='yes'
				if test "$option_multi" = 'no'; then
					cursor="$index"
				fi
			done
		fi
	}
	select_defaults

	# prepare renders
	if test "$use_colors" = 'no'; then
		style_bold=''
		style_dim=''
		style_help_begin=''
		style_help_end=''
		style_key_begin='['
		style_key_end=']'
		style_magenta=''
		style_reset=''
	elif test "$(get-terminal-theme || :)" = 'dark'; then
		style_key_begin=$'\e[30m\e[47m ' # foreground black, background white
	else
		style_key_begin=$'\e[107m ' # foreground default black, background intense white
	fi
	if test "$option_multi" = 'yes'; then
		style_checked='▣'
		style_unchecked='□'
		style_selected='⊡'
	else
		if test "$option_required" = 'yes'; then
			style_checked='●'
			style_selected='●'
		else
			style_checked='☉'
			style_selected='☉'
		fi
		style_unchecked='○'
	fi
	if test "$option_confirm_input" = 'yes'; then
		menu_hint_confirm="${style_help_begin}CONFIRM${style_help_end}  ${style_key_begin}ENTER${style_key_end}"
	fi
	if test "$option_hints" = 'yes'; then
		if test "$option_multi" = 'no'; then
			menu_hint_standard+="${style_help_begin}SELECT${style_help_end}  ${style_key_begin}SPACE${style_key_end} ${style_key_begin}ENTER${style_key_end} ${style_key_begin}E${style_key_end}"
		else
			menu_hint_standard+="${style_help_begin}SELECT${style_help_end} ${style_key_begin}SPACE${style_key_end}"
			menu_hint_standard+="${style_indent}${style_help_begin}CONFIRM${style_help_end} ${style_key_begin}ENTER${style_key_end} ${style_key_begin}E${style_key_end}"
		fi
		if test "$can_cancel" = 'yes'; then
			# cancel restores defaults and leaves
			menu_hint_standard+="${style_indent}${style_help_begin}CANCEL${style_help_end} ${style_key_begin}ESC${style_key_end} ${style_key_begin}Q${style_key_end}"
		fi
		if test "$items_total" -ne 1; then
			# [⬆⬇⇧] have alignment issues, use [↑↓]
			menu_hint_standard+="${style_indent}${style_help_begin}UP${style_help_end} ${style_key_begin}↑${style_key_end} ${style_key_begin}W${style_key_end} ${style_key_begin}K${style_key_end}"
			menu_hint_standard+="${style_indent}${style_help_begin}DOWN${style_help_end} ${style_key_begin}↓${style_key_end} ${style_key_begin}S${style_key_end} ${style_key_begin}J${style_key_end}"
			menu_hint_extras+="${style_indent}${style_help_begin}FIRST${style_help_end} ${style_key_begin}HOME${style_key_end} ${style_key_begin}A${style_key_end}"
			menu_hint_extras+="${style_indent}${style_help_begin}LAST${style_help_end} ${style_key_begin}END${style_key_end} ${style_key_begin}D${style_key_end}"
			if test "$option_multi" = 'yes'; then
				menu_hint_extras+="${style_indent}${style_help_begin}ALL/NONE${style_help_end} ${style_key_begin}T${style_key_end}"
			fi
		fi
		if test "$can_revert_to_defaults" = 'yes'; then
			menu_hint_extras+="${style_indent}${style_help_begin}DEFAULTS${style_help_end} ${style_key_begin}Z${style_key_end}"
		fi
		# tab and backspace undocumented
	fi
	if test -n "$question_with_body"; then
		# @todo only bold the first question line
		menu_header="$question_with_body"$'\n'
	fi
	# @todo: FILTER [asd] SHOWING [2] HIDING [19] TOTAL [21] TOGGLE [F]

	# this is too slow to recalculate on each interaction
	function refresh_terminal_size {
		if test "$paging_supported" = 'no'; then
			paging_needed='no'
		else
			size_rows="$(tput lines)"
			size_columns="$(tput cols)"
			if test "$size_rows" -ne "$size_rows_prior" -o "$size_columns" -ne "$size_columns_prior"; then
				size_content="$((size_columns - 5))"
				# recalculate for new size
				menu_header_shrunk="$(echo-trim-colors -- "$menu_header" | "$bin_gfold" -w "$size_columns")"
				menu_header_size="$("$bin_gwc" -l <<<"${menu_header_shrunk}")"
				menu_hint="${menu_hint_standard}${menu_hint_extras}"
				menu_hint_shrunk="$(echo-trim-colors -- "$menu_hint" | "$bin_gfold" -w "$size_columns")"
				menu_hint_size="$("$bin_gwc" -l <<<"${menu_hint_shrunk}")"
				if test "$menu_hint_size" -gt 1; then
					menu_hint="${menu_hint_standard}"
					menu_hint_shrunk="$(echo-trim-colors -- "$menu_hint" | "$bin_gfold" -w "$size_columns")"
					menu_hint_size="$("$bin_gwc" -l <<<"${menu_hint_shrunk}")"
				fi
				# move start index to current item, as otherwise it could be out of range
				if test "$size_rows" -lt "$size_rows_prior" -o "$size_columns" -lt "$size_columns_prior"; then
					# @todo we should detect if showing everything is possible before resorting to this
					page_start_index="$cursor"
					page_last_index="$items_last_index"
				fi
				# reset paging for new size
				paging_needed='maybe'
				mapfile -t renders < <(get-array "$items_total")
				mapfile -t sizes < <(get-array "$items_total")
				# update priors
				size_rows_prior="$size_rows"
				size_columns_prior="$size_columns"
			fi
		fi
	}
	function action_jump {
		local index="$1"
		# jump to number and select
		if test "$index" -le 1; then
			cursor=0
		elif test "$index" -ge "$items_total"; then
			cursor="$items_last_index"
		else
			cursor="$((index - 1))"
		fi
		action_select
	}
	function action_up {
		if test "$cursor" -eq 0; then
			if test "$paging_needed" = 'yes'; then
				page_start_index="$items_last_index"
			fi
			cursor="$items_last_index"
		else
			if test "$cursor" -eq "$page_start_index"; then
				page_start_index="$((page_start_index - 1))"
			fi
			cursor="$((cursor - 1))"
		fi
	}
	function action_down {
		if test "$cursor" -eq "$items_last_index"; then
			cursor=0
			page_start_index=0
		else
			if test "$paging_needed" = 'yes' -a "$cursor" -eq "$page_last_index"; then
				page_start_index="$((page_last_index + 1))" # ="$next_page_start_index"
			fi
			cursor="$((cursor + 1))"
		fi
	}
	function action_first {
		cursor=0
		page_start_index=0
	}
	function action_last {
		if test "$paging_needed" = 'yes'; then
			page_start_index="$items_last_index"
		fi
		cursor="$items_last_index"
	}
	function action_select {
		selections[cursor]='yes'
	}
	function action_toggle {
		if test "${selections[cursor]}" = 'yes'; then
			selections[cursor]=''
		else
			selections[cursor]='yes'
		fi
	}
	function action_next {
		# select and move to next line
		selections[cursor]='yes'
		action_down
	}
	function action_previous {
		# unselect and move to prior line
		selections[cursor]=''
		action_up
	}
	function action_none {
		local index
		for index in "${!items[@]}"; do
			selections[index]=''
		done
	}
	function action_all {
		local index
		for index in "${!items[@]}"; do
			selections[index]='yes'
		done
	}
	function action_revert {
		action_none
		select_defaults
	}
	function render_menu {
		local \
			action='' \
			index \
			item_original \
			item_prefix \
			item_rendered \
			item_size \
			items_bundled \
			items_bundled_size=0 \
			menu_confirm \
			menu_size \
			menu_skip_remainder \
			menu_skip_render='no' \
			menu_title='' \
			read_status \
			selected_count=0
		# action
		tty_start
		while test "$action" != 'done'; do
			menu_confirm='no'
			if test "$menu_skip_render" = 'no'; then
				refresh_terminal_size
				items_bundled_size=0
				items_bundled=''
				selected_count=0
				menu_skip_remainder='no'
				for index in "${!items[@]}"; do
					if test "${selections[index]-}" = 'yes'; then
						selected_count=$((selected_count + 1))
					fi
					if test "$index" -lt "$page_start_index" -o "$menu_skip_remainder" = 'yes'; then
						continue
					fi
					# determine prefix
					item_prefix=''
					if test "$index" -eq "$cursor" -a "${selections[index]-}" = 'yes'; then
						item_prefix+="$style_magenta>  $style_checked "
					elif test "${selections[index]-}" = 'yes'; then
						item_prefix+="$style_magenta   $style_checked "
					elif test "$index" -eq "$cursor"; then
						item_prefix+="$style_magenta>  $style_selected "
					else
						item_prefix+="   $style_unchecked "
					fi
					# determine paging
					if test "$paging_needed" = 'no'; then
						# paging is no longer needed, no recalculations needed
						if test -n "${renders[index]}"; then
							# use rendered item (in case it needed to be formatted if it exists)
							items_bundled+="${item_prefix}${renders[index]}${style_reset}"$'\n'
						else
							# otherwise use original item
							items_bundled+="${item_prefix}${items[index]}${style_reset}"$'\n'
						fi
					else
						# paging is needed, so we must recalculate bundled size
						if test -n "${renders[index]}"; then
							item_rendered="${renders[index]}"
							item_size="${sizes[index]}"
						else
							item_original="${items[index]}"
							if test "${#item_original}" -lt "$size_content" && [[ $item_original != *$'\n'* && $item_original != *$'\t'* ]]; then
								# no need to format item, as it is small enough
								item_rendered="$item_original"
								item_size=1
								renders[index]="$item_rendered"
								sizes[index]="$item_size"
							else
								# need to format item, as it is too big
								item_rendered="$("$bin_gfmt" -t -w "$size_content" <<<"$item_original")"
								item_rendered="${item_rendered//$'\n'/$'\n     '}"
								item_size="$("$bin_gwc" -l <<<"${item_rendered}")"
								renders[index]="$item_rendered"
								sizes[index]="$item_size"
							fi
						fi
						# calculate total menu size
						menu_size="$((menu_header_size + items_bundled_size + item_size + menu_hint_size))"
						if test "$menu_size" -gt "$size_rows"; then
							# the menu would now be too large, so skip the rest
							menu_skip_remainder='yes'
						else
							items_bundled+="${item_prefix}${item_rendered}${style_reset}"$'\n'
							items_bundled_size="$((items_bundled_size + item_size))"
							page_last_index="$index"
						fi
					fi
				done

				# output menu
				if test "$paging_supported" = 'yes'; then
					if test "$page_start_index" -ne 0 -o "$page_last_index" -ne "$items_last_index"; then
						paging_needed='yes'
						menu_title=$'\e]0;'"👉 Selected $selected_count of $items_total items 💁‍♀️ Viewing $((page_last_index - page_start_index + 1)) of $items_total items [$((page_start_index + 1))…$((page_last_index + 1))] 👈"$'\a'
					else
						menu_title=$'\e]0;'"👉 Selected $selected_count of $items_total items 👈"$'\a'
						paging_needed='no'
					fi
				fi
				printf '%s' "${menu_title}${menu_header}${items_bundled}${menu_hint}" >"$tty_target"
			fi

			# handle the response
			eval_capture --statusvar=read_status --stdoutvar=action -- read-key --timeout="$option_timeout"
			if test "$read_status" -eq 60; then
				if test "$selected_count" -ne 0; then
					tty_clear
					commentary="$(echo-style --yellow='[timed out: using selection]')"
					break # exit the while loop
				elif test "$option_required" = 'no'; then
					tty_clear
					commentary="$(echo-style --yellow='[timed out: not required]')"
					break # exit the while loop
				else
					tty_clear
					commentary="$(echo-style --red='[input failure: timed out: required]')"
					menu_status="$read_status"
					break # exit the while loop
				fi
			elif test "$read_status" -ne 0; then
				# some other failure
				tty_clear
				commentary="$(echo-style --red="[input failure: $read_status]")"
				menu_status="$read_status"
				break # exit the while loop
			fi

			# style_reset selection if not multi
			if test "$selected_count" -ne 0 -a "$option_multi" = 'no'; then
				# erase all selects
				for index in "${!selections[@]}"; do
					selections[index]=''
				done
			fi

			# perform action
			if is-digit -- "$action"; then
				if is-ci; then
					__print_string "DIGIT=[$action]" >/dev/stderr
				fi
				action_jump "$action"
			elif test "$action" = 'up' -o "$action" = 'left' -o "$action" = 'h' -o "$action" = 'k' -o "$action" = 'w'; then
				action_up
			elif test "$action" = 'down' -o "$action" = 'right' -o "$action" = 'l' -o "$action" = 'j' -o "$action" = 's'; then
				action_down
			elif test "$action" = 'space'; then
				if test "$option_multi" = 'yes'; then
					action_toggle
				else
					action_select
					menu_confirm='yes'
				fi
			elif test "$action" = 'enter' -o "$action" = 'e'; then
				if test "$option_multi" = 'no'; then
					action_select
				fi
				menu_confirm='yes'
			elif test "$action" = 'escape' -o "$action" = 'q'; then
				if test "$option_multi" = 'no' -a "$option_required" = 'no'; then
					: # don't revert
				else
					action_revert
				fi
				menu_confirm='yes'
			elif test "$action" = 'home' -o "$action" = 'a'; then
				action_first
			elif test "$action" = 'end' -o "$action" = 'd'; then
				action_last
			elif test "$action" = 'z'; then
				action_revert
			elif test "$option_multi" = 'yes'; then
				if test "$action" = 't'; then
					if test "$selected_count" -eq "$items_total"; then
						action_none
					else
						action_all
					fi
				elif test "$action" = 'tab'; then
					action_next
				elif test "$action" = 'backspace'; then
					action_previous
				else
					# nothing done, no need to repeat, just need to read again
					menu_skip_render='yes'
					continue
				fi
			else
				# nothing done, no need to repeat, just need to read again
				menu_skip_render='yes'
				continue
			fi

			# confirm
			if test "$menu_confirm" = 'yes'; then
				if test "$option_confirm_input" = 'no'; then
					# no desire to confirm
					break # exit the while loop
				fi

				# confirm selection with the user
				items_bundled=''
				selected_count=0
				for index in "${!selections[@]}"; do
					if test "${selections[index]}" = 'yes'; then
						selected_count=$((selected_count + 1))
						items_bundled+="$style_magenta$style_checked ${items[index]}${style_reset}"$'\n'
					fi
				done
				if test "$selected_count" -eq 0; then
					if test "$option_required" = 'yes'; then
						# nothing done, no need to repeat, just need to read again
						menu_skip_render='yes'
						continue
					fi
					items_bundled="${style_dim}[ nothing provided ]"$'\n'
				fi
				items_bundled+=$'\n'

				# render the confirmation
				tty_clear
				menu_title=$'\e]0;'"👉 Confirm $selected_count of $items_total items 👈"$'\a'
				printf '%s' "${menu_title}${menu_header}${items_bundled}${menu_hint_confirm}" >"$tty_target"

				# handle the response
				eval_capture --statusvar=read_status --stdoutvar=action -- read-key --timeout="$option_timeout"
				if test "$read_status" -eq 60; then
					if test "$selected_count" -ne 0; then
						tty_clear
						commentary="$(echo-style --yellow='[timed out: using selection]')"
						break # exit the while loop
					elif test "$option_required" = 'no'; then
						tty_clear
						commentary="$(echo-style --yellow='[timed out: optional]')"
						break # exit the while loop
					else
						tty_clear
						commentary="$(echo-style --red='[input failure: timed out: required]')"
						menu_status="$read_status"
						break # exit the while loop
					fi
				elif test "$read_status" -ne 0; then
					# some other failure
					tty_clear
					commentary="$(echo-style --red="[input failure: $read_status]")"
					menu_status="$read_status"
					break # exit the while loop
				fi
				if test "$action" = 'enter' -o "$action" = 'e'; then
					break # exit the while loop
				fi
			fi

			# repeat the menu
			menu_skip_render='no'
			tty_clear
		done
		tty_finish
	}

	# render if not skipping
	if test "$option_confirm_default" = 'no' -a "$can_revert_to_defaults" = 'yes'; then
		: # we have defaults, and want to skip defaults
	else
		render_menu
	fi

	# preare result render to the user
	local render="$question_title" selected_count=0 index
	if test -n "$commentary"; then
		if test -n "$render"; then
			render+=" $commentary"
		else
			render="$commentary"
		fi
	fi
	if test -n "$render"; then
		render+=$'\n'
	fi
	if test "$menu_status" -eq 0; then
		# render linger or temp
		if test "$option_linger" = 'yes'; then
			# add results only if lingering, as there may be more than terminal height, so clearing wouldn't support such
			for index in "${!selections[@]}"; do
				if test "${selections[index]}" = 'yes'; then
					selected_count=$((selected_count + 1))
					render+="$style_dim$style_checked ${items[index]}${style_reset}"$'\n'
				fi
			done
			if test "$selected_count" -eq 0; then
				render+="${style_dim}[ nothing provided ]"$'\n'
			fi
			# inform
			__print_string "$render" >"$tty_target"
		elif test -n "$commentary"; then
			# inform temporarily
			__print_string "$render" >/dev/stderr
			sleep 3
			echo-clear-lines --stdin < <(__print_string "$render") >/dev/stderr
		fi
		# stdout
		for index in "${!selections[@]}"; do
			if test "${selections[index]}" = 'yes'; then
				__print_line "${returns[index]}"
			fi
		done
	else
		# inform
		if test -n "$commentary"; then
			if test "$option_linger" = 'yes'; then
				__print_line "$render" >"$tty_target"
			else
				__print_line "$render" >/dev/stderr
			fi
		fi
		return "$menu_status"
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		choose_test
	else
		choose_ "$@"
	fi
fi
