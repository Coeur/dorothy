#!/usr/bin/env bash

# @todo
# consider something like
# pkg=($(get-first-array "${PAMAC[@]}" -- "${AUR[@]}" -- "${ARCH[@]}"))
#
# check for leftover pkgs[@]
#
# APT='apt-transport-https ca-certificates'
# and all others need to be changed

function setup-util() (
	source "$DOROTHY/sources/bash.bash"
	require_array 'mapfile'
	source "$(command -v eval-helper)"

	# when running via fresh installer environment, ensure that environment gets configured
	if test -z "${DOROTHY_ENVIRONMENT-}"; then
		source "$DOROTHY/sources/environment.sh"
	fi

	local installers=(
		# intelligent
		brew
		cask

		# precompiled, has autoupdate
		apt    # debian package manager (supports DEB, successor to aptitude)
		apk    # alpine package manager (supports APK)
		zypper # opensuse package manager (supports YaST, RPM)
		dnf    # fedora package manager (supports RPM, successor to yum)
		yum    # fedora package manager (supports RPM, predecessor to dnf)

		# precompiled containers, has autoupdate
		snap    # dependencies are within the snap
		flatpak # dependencies are their own flatpaks, but everything is precompiled

		# precompiled AUR (first-class AUR support), has autoupdate
		pamac  # manjaro package manager: GUI+CLI, vala, wraps libalpm, snap, flatpak: https://gitlab.manjaro.org/applications/pamac/
		pacman # arch package manager: CLI, c, wraps libalpm: https://wiki.archlinux.org/title/pacman

		# precompiled AUR (third-party AUR wrappers), has autoupdate
		# https://wiki.archlinux.org/title/AUR_helpers
		# https://wiki.manjaro.org/index.php?title=Pamac
		# https://wiki.manjaro.org/index.php/Arch_User_Repository
		# https://itsfoss.com/paru-aur-helper/
		# https://itsfoss.com/best-aur-helpers/
		yay      # GUI, go, wraps pacman: https://github.com/Jguer/yay
		paru     # CLI, rust, wraps pacman: https://github.com/Morganamilo/paru
		pakku    # CLI, nim, wraps pacman: https://github.com/kitsunyan/pakku
		aurutils # CLI, shell, wraps pacman: https://github.com/AladW/aurutils

		# precompiled, no autoupdate
		dpkg # is available on debian, however apt is preferred
		rpm  # is available on opensuse, however zypper is preferred

		# precompiled, doesn't install man pages, no autoupdate
		tea # is available on macos and linux

		# source needing compiling, has autoupdate
		# preferred over JIT as if provided, this will be faster
		cargo
		go

		# source that is JIT, has autoupdate
		npm
		pip
		pipx
		gem

		# mac app store and does autoupdate
		mas

		# windows
		scoop
		winget
		choco # aka chocolatey aka cinst, interferes with unix

		# solaris/bsd
		pkgin
		pkgadd
		pkg

		# unknown
		cabal
		conda
		emerge
		eopkg
		guix
		nix
		port
		xbps
		urpmi

		# disable/removed as no documentation
		# pkgutil
		# pkgman
		# huber
		# eget
		# stack
		# kiss

		# custom
		installer # local or remote installer
		github    # remote executable download from github, supports zip, appimage
		download  # remote executable download, supports zip
		'eval'    # run a function or another script
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Install a utility with support for several package managers.

			USAGE:
			setup-util [...options]

			OPTIONS:
			--order=<...installers>
			    Used to override the preferred order of installers, space separated.

			--installer=<installer> -- <...packages>
			    Used to override the preferred order of installers.

			--cli=<cli>
			    Used to check if the utility is already installed.

			--app=<app>
			    Used to check if the utility is already installed.

			--name=<name>
			    The name to use for the utility in human readable output, such as log messages.

			--confirm
			    Confirm installation of the utility before installing it.

			--optional
			    If truthy, do not return a failure code if the utility was unable to be installed.

			--no-fallback
			    If truthy, do not install a package system in order to install the package.

			--force
			    If truthy, use the installer's force mode if supported.

			--upgrade
			    If omitted, do not reinstall if already installed.
			    Not all installers support this.

			--uninstall | --action=uninstall
			    If truthy, if the utility is already installed then uninstall it.
			    Not all installers support this.

			--quiet
			    If unspecified, outputs only useful things.
			    If truthy, don't output anything that isn't an error message.
			    If falsey, output everything.

			... <installers> provide the remaining arguments,
			for now they are only documented in the source code.

			INSTALLERS:
			The following installers are supported, in this default order of preference:

			    ${installers[*]}

			EXAMPLE:

			setup-util --name='bottom' --cli='btm' --order='brew cargo aur' \
			    AUR='bottom-bin' \
			    BREW='bottom' \
			    CARGO='bottom'
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# installer options
	local APK=()
	local APT=() APT_REPO='' APT_KEY='' APT_ID=''
	local AUR=()
	local AURUTILS=()
	local BREW=() BREW_TAP=()
	local BSD=()
	local CABAL=()
	local CARGO=() RUST=()
	local CASK=() CASK_TAP=()
	local CHOCO=() CHOCOLATEY=() CINST=()
	local CONDA=() CONDA_CHANNEL=''
	local DNF=() DNF_GROUP=() DNF_COPR=() DNF_REPO=()
	local DOWNLOAD='' DOWNLOAD_FILENAME='' DOWNLOAD_UNZIP_FORMAT='' DOWNLOAD_UNZIP_FILTER=''
	local DPKG=() DEB=()
	local EMERGE=() EMERGE_REPO=()
	local EOPKG=() SOLUS=()
	local EVAL=()
	local FLATPAK=() FLATPAK_REPO=()
	local GEM=() RUBY=()
	local GITHUB_SLUG='' GITHUB_FILENAME='' GITHUB_REF='' GITHUB_RELEASE='' GITHUB_PATHNAME='' GITHUB_ASSET_FILTER='' GITHUB_UNZIP_FORMAT='' GITHUB_UNZIP_FILTER=''
	local GO=()
	local GUIX=()
	local INSTALLER='' INSTALLER_FILENAME='' INSTALLER_OPEN=''
	local MAS=()
	local NIX=()
	local NPM=() NODE=()
	local PACMAN=()
	local PAKKU=()
	local PAMAC=()
	local PARU=()
	local PIPX=() PIP=() PYTHON=()
	local PKG=()
	local PKGADD=()
	local PKGIN=()
	local PORT=()
	local RPM=()
	local SCOOP=()
	local SNAP=() SNAP_CHANNEL=''
	local TEA=()
	local URPMI=()
	local WINGET=()
	local XBPS=()
	local YAY=()
	local YUM=() YUM_REPO=()
	local ZYPPER=() ZYPPER_REPO='' ZYPPER_REPO_ALIAS=''

	# process
	local item action='install' installer='' app='' cli='' name='' quiet confirm='no' optional='no' fallback='yes' upgrade='no' force='no' order=()
	quiet="$(echo-quiet -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--install') action='install' ;;
		'--uninstall') action='uninstall' ;;
		'--action='*) action="${item#*--action=}" ;;
		'--order='*) mapfile -t order < <(echo-split ' ' -- "${item#--order=}") ;;
		'--installer='*) installer="${item#--installer=}" ;;
		'--app='*) app="${item#--app=}" ;;
		'--cli='*) cli="${item#--cli=}" ;;
		'--name='*) name="${item#--name=}" ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		'--no-confirm'* | '--confirm'*)
			confirm="$(
				get-flag-value confirm --missing="$confirm" -- "$item" | echo-affirmative
			)"
			;;
		'--no-optional'* | '--optional'*)
			optional="$(
				get-flag-value optional --missing="$optional" -- "$item" | echo-affirmative
			)"
			;;
		'--no-fallback'* | '--fallback'*)
			fallback="$(
				get-flag-value fallback --missing="$fallback" -- "$item" | echo-affirmative
			)"
			;;
		'--no-force'* | '--force'*)
			force="$(
				get-flag-value force --missing="$force" -- "$item" | echo-affirmative
			)"
			;;
		'--no-upgrade'* | '--upgrade'*)
			upgrade="$(
				get-flag-value upgrade --missing="$upgrade" -- "$item" | echo-affirmative
			)"
			;;
		'--')
			if test -z "$installer"; then
				help "--installer=<installer> is required when using -- <...packages>"
			fi
			if test -z "$name"; then
				name="$installer:$*"
			fi
			if test "$#" -eq 0; then
				return 0 # no packages to install
			fi
			while test "$#" -ne 0; do
				if [[ $1 == *"="* ]]; then
					break
				fi
				set -- "$@" "$installer=$1"
				shift
			done
			continue
			;;

			# installer options
		'ALPINE='*) APK+=("${item#*ALPINE=}") ;; # alias for APK
		'APK='*) APK+=("${item#*APK=}") ;;
		'APPIMAGE='*) APPIMAGE+=("${item#*APPIMAGE=}") ;;
		'APT_ID='*) APT_ID="${item#*APT_ID=}" ;;
		'APT_KEY='*) APT_KEY="${item#*APT_KEY=}" ;;
		'APT_REPO='*) APT_REPO="${item#*APT_REPO=}" ;;
		'APT='*) APT+=("${item#*APT=}") ;;
		'ARCH='*) AUR+=("${item#*ARCH=}") ;; # alias for AUR
		'AUR='*) AUR+=("${item#*AUR=}") ;;
		'AURUTILS='*) AURUTILS+=("${item#*AURUTILS=}") ;;
		'BREW_TAP='*) BREW_TAP+=("${item#*BREW_TAP=}") ;;
		'BREW='*) BREW+=("${item#*BREW=}") ;;
		'BSD='*) BSD+=("${item#*BSD=}") ;;
		'CABAL='*) CABAL+=("${item#*CABAL=}") ;;
		'CARGO='*) CARGO+=("${item#*CARGO=}") ;;
		'CASK_TAP='*) CASK_TAP+=("${item#*CASK_TAP=}") ;;
		'CASK='*) CASK+=("${item#*CASK=}") ;;
		'CHOCO='*) CHOCO+=("${item#*CHOCO=}") ;;
		'CHOCOLATEY='*) CHOCOLATEY+=("${item#*CHOCOLATEY=}") ;;
		'CINST='*) CINST+=("${item#*CINST=}") ;;
		'CONDA_CHANNEL='*) CONDA_CHANNEL="${item#*CONDA_CHANNEL=}" ;;
		'CONDA='*) CONDA+=("${item#*CONDA=}") ;;
		'DEB='*) DEB+=("${item#*DEB=}") ;;
		'DEBIAN='*) DEB+=("${item#*DEBIAN=}") ;; # alias for DEB
		'DNF_COPR='*) DNF_COPR+=("${item#*DNF_COPR=}") ;;
		'DNF_GROUP='*) DNF_GROUP+=("${item#*DNF_GROUP=}") ;;
		'DNF_REPO='*) DNF_REPO+=("${item#*DNF_REPO=}") ;;
		'DNF='*) DNF+=("${item#*DNF=}") ;;
		'DOWNLOAD_FILENAME='*) DOWNLOAD_FILENAME="${item#*DOWNLOAD_FILENAME=}" ;;
		'DOWNLOAD_UNZIP_FILTER='*) DOWNLOAD_UNZIP_FILTER="${item#*DOWNLOAD_UNZIP_FILTER=}" ;;
		'DOWNLOAD_UNZIP_FORMAT='*) DOWNLOAD_UNZIP_FORMAT="${item#*DOWNLOAD_UNZIP_FORMAT=}" ;;
		'DOWNLOAD='*) DOWNLOAD="${item#*DOWNLOAD=}" ;;
		'DPKG='*) DPKG+=("${item#*DPKG=}") ;;
		'EMERGE_REPO='*) EMERGE+=("${item#*EMERGE_REPO=}") ;;
		'EMERGE='*) EMERGE+=("${item#*EMERGE=}") ;;
		'EOPKG='*) EOPKG+=("${item#*EOPKG=}") ;;
		'EVAL='*) EVAL+=("${item#*EVAL=}") ;;
		'FEDORA='*) DNF+=("${item#*FEDORA=}") ;; # alias for DNF
		'FLATPAK_REPO='*) FLATPAK_REPO+=("${item#*FLATPAK_REPO=}") ;;
		'FLATPAK='*) FLATPAK+=("${item#*FLATPAK=}") ;;
		'GEM='*) GEM+=("${item#*GEM=}") ;;
		'GENTOO='*) EMERGE+=("${item#*GENTOO=}") ;; # alias for EMERGE
		'GITHUB_ASSET_FILTER='*) GITHUB_ASSET_FILTER="${item#*GITHUB_ASSET_FILTER=}" ;;
		'GITHUB_FILENAME='*) GITHUB_FILENAME="${item#*GITHUB_FILENAME=}" ;;
		'GITHUB_PATHNAME='*) GITHUB_PATHNAME="${item#*GITHUB_PATHNAME=}" ;;
		'GITHUB_REF='*) GITHUB_REF="${item#*GITHUB_REF=}" ;;
		'GITHUB_RELEASE='*) GITHUB_RELEASE="${item#*GITHUB_RELEASE=}" ;;
		'GITHUB_SLUG='*) GITHUB_SLUG="${item#*GITHUB_SLUG=}" ;;
		'GITHUB_UNZIP_FILTER='*) GITHUB_UNZIP_FILTER="${item#*GITHUB_UNZIP_FILTER=}" ;;
		'GITHUB_UNZIP_FORMAT='*) GITHUB_UNZIP_FORMAT="${item#*GITHUB_UNZIP_FORMAT=}" ;;
		'GO='*) GO+=("${item#*GO=}") ;;
		'GUIX='*) GUIX+=("${item#*GUIX=}") ;;
		'INSTALLER_FILENAME='*) INSTALLER_FILENAME="${item#*INSTALLER_FILENAME=}" ;;
		'INSTALLER_OPEN='*) INSTALLER_OPEN="${item#*INSTALLER_OPEN=}" ;;
		'INSTALLER='*) INSTALLER="${item#*INSTALLER=}" ;;
		'MAGEIA='*) URPMI+=("${item#*MAGEIA=}") ;; # alias for URPMI
		'MAS='*) MAS+=("${item#*MAS=}") ;;
		'NIX='*) NIX+=("${item#*NIX=}") ;;
		'NODE='*) NODE+=("${item#*NODE=}") ;;
		'NPM='*) NPM+=("${item#*NPM=}") ;;
		'OPENSUSE='*) ZYPPER+=("${item#*OPENSUSE=}") ;; # alias for ZYPPER
		'PACMAN='*) PACMAN+=("${item#*PACMAN=}") ;;
		'PAKKU='*) PAKKU+=("${item#*PAKKU=}") ;;
		'PAMAC='*) PAMAC+=("${item#*PAMAC=}") ;;
		'PARU='*) PARU+=("${item#*PARU=}") ;;
		'PIP='*) PIP+=("${item#*PIP=}") ;;
		'PIPX='*) PIPX+=("${item#*PIPX=}") ;;
		'PKG='*) PKG+=("${item#*PKG=}") ;;
		'PKGADD='*) PKGADD+=("${item#*PKGADD=}") ;;
		'PKGIN='*) PKGIN+=("${item#*PKGIN=}") ;;
		'PORT='*) PORT+=("${item#*PORT=}") ;;
		'PYTHON='*) PYTHON+=("${item#*PYTHON=}") ;;
		'RPM='*) RPM+=("${item#*RPM=}") ;;
		'RUBY='*) RUBY+=("${item#*RUBY=}") ;;
		'RUST='*) RUST+=("${item#*RUST=}") ;;
		'SCOOP='*) SCOOP+=("${item#*SCOOP=}") ;;
		'SNAP_CHANNEL='*) SNAP_CHANNEL="${item#*SNAP_CHANNEL=}" ;;
		'SNAP='*) SNAP+=("${item#*SNAP=}") ;;
		'SOLUS='*) SOLUS+=("${item#*SOLUS=}") ;;
		'SUSE='*) ZYPPER+=("${item#*SUSE=}") ;; # alias for ZYPPER
		'TEA='*) TEA+=("${item#*TEA=}") ;;
		'UBUNTU='*) APT+=("${item#*UBUNTU=}") ;; # alias for APT
		'URPMI='*) URPMI+=("${item#*URPMI=}") ;;
		'VOID='*) XBPS+=("${item#*VOID=}") ;; # alias for XBPS
		'WINGET='*) WINGET+=("${item#*WINGET=}") ;;
		'XBPS='*) XBPS+=("${item#*XBPS=}") ;;
		'YAY='*) YAY+=("${item#*YAY=}") ;;
		'YUM_REPO='*) YUM_REPO+=("${item#*YUM_REPO=}") ;;
		'YUM='*) YUM+=("${item#*YUM=}") ;;
		'ZYPPER_REPO_ALIAS='*) ZYPPER_REPO_ALIAS="${item#*ZYPPER_REPO_ALIAS=}" ;;
		'ZYPPER_REPO='*) ZYPPER_REPO="${item#*ZYPPER_REPO=}" ;;
		'ZYPPER='*) ZYPPER+=("${item#*ZYPPER=}") ;;
		'--'*) ;; # passively ignore, could be custom arg, such as --paths for setup-util-plex
		*) help "An unrecognised flag was provided: $item" ;;
		esac
	done

	# ensure action
	if test -z "$action"; then
		action='install'
	fi
	if ! [[ $action =~ install|uninstall|upgrade ]]; then
		help 'Invalid <action>, must be [install], [uninstall], or [upgrade].'
	fi

	# if uninstall, disable upgrade
	if test "$action" = 'uninstall'; then
		upgrade='no'
	fi

	# ensure name fallback
	if test -z "$name" -a -n "$app"; then
		name="$app"
	fi
	if test -z "$name" -a -n "$cli"; then
		name="$cli"
	fi
	if test -z "$name" -a -n "$installer"; then
		name="$installer"
	fi
	if test -z "$name"; then
		echo-style --error="Either <name>, <cli>, <app> must be provided. See [$0 --help] for usage." >/dev/stderr
		return 22 # EINVAL 22 Invalid argument
	fi

	# ensure order
	local temp_order installer inject_installer
	if test "${#order[@]}" -eq 0; then
		order=("${installers[@]}")
	else
		# custom order, handle ...
		# so [snap ...] means snap first, then everything else, whereas [... apt] means everyting then apt
		# as such, the specified installers need to be trimmed from the ... substitution
		# @todo this will currently hard fail if there is two ... occurences
		temp_order=()
		for installer in "${order[@]}"; do
			if test "$installer" = '...'; then
				for inject_installer in "${installers[@]}"; do
					if is-needle "$inject_installer" "${order[@]}"; then
						continue
					else
						temp_order+=("$inject_installer")
					fi
				done
			else
				temp_order+=("$installer")
			fi
		done
		order=("${temp_order[@]}")
	fi

	# =====================================
	# Process

	function maybe-echo-style {
		if test "$quiet" != 'yes'; then
			echo-style "$@"
		fi
	}

	# prepare fallbacks, for when the package could be installed, but requires the package system to sshe installed first
	# which will be used, if none of the package systems were present, as such proceed in order of preference for installation of package systems
	local fallbacks=()

	# check if exists
	local app_exists='' cli_exists='' cli_working=''
	if test -n "$app"; then
		if get-app --quiet "$app"; then
			app_exists='yes'
		else
			app_exists='no'
		fi
	fi
	if test -n "$cli"; then
		if command-exists "$cli"; then
			cli_exists='yes'
			if command-working "$cli"; then
				cli_working='yes'
			else
				cli_working='no'
			fi
		else
			cli_exists='no'
			cli_working='no'
		fi
	fi

	# check if necessary
	if test -n "$app" -o -n "$cli"; then
		if test "$app_exists" != 'yes' -a "$cli_exists" != 'yes'; then
			# neither installed
			if test "$action" = 'uninstall'; then
				# already uninstalled, so no need to uninstall
				maybe-echo-style --g3="The [$name] utility was not found. Already uninstalled. ✅"
				# exit
				return 0
			fi
			upgrade='no' # note that we aren't upgrading, which is used for logging
			# perform install
			maybe-echo-style --h3="The [$name] utility was not found. Installing automatically... ⏲"
		elif test "$action" = 'uninstall'; then
			# exists, uninstall enabled
			upgrade='no' # note that we aren't upgrading, which is used for logging
			# perform uninstall
			maybe-echo-style --h3="The [$name] utility is marked for uninstall. Uninstalling... ⏲"
		elif test "$upgrade" = 'yes'; then
			# exists, upgrade enabled
			# perform upgrade
			maybe-echo-style --h3="The [$name] utility is marked for upgrade. Upgrading... ⏲"
		elif test "$cli_working" = 'fail'; then
			# exists, not working
			# perform reinstall
			maybe-echo-style --h3="The [$name] utility via [$cli] is misbehaving. Reinstalling automatically... ⏲"
		else
			# exists, no upgrade, is working
			# already installed, so no need to install again
			maybe-echo-style --g3="The [$name] utility is already installed. ✅"
			return 0
		fi
	fi

	# remove xdg bin if it exists, as we don't want conflicts if it is deprecated
	if test "$upgrade" = 'yes' -o "$action" = 'uninstall'; then
		if test -n "$cli" -a -e "$XDG_BIN_HOME/$cli"; then
			rm -f "$XDG_BIN_HOME/$cli"
		fi
	fi

	# confirm if necessary
	if test "$confirm" = 'yes'; then
		if ! confirm --positive --ppid=$$ -- "Do you want to setup the [$name] utility?"; then
			# we don't want to modify it
			if test "$optional" = 'yes'; then
				# it was optional, so success case
				return 0
			else
				# it was not optional, so abort
				return 2
			fi
		fi
	fi

	# log helpers
	function get_completion_action {
		if test "$action" = 'uninstall'; then
			echo 'uninstalled'
		elif test "$upgrade" = 'yes'; then
			echo 'upgraded'
		else
			echo 'installed'
		fi
	}
	function won {
		local method="$1"
		maybe-echo-style --g3="The [$name] utility was $(get_completion_action) via [$method]. ✅"
	}
	function lost {
		if test "$optional" = 'yes'; then
			maybe-echo-style --n3="The [$name] optional utility was not $(get_completion_action). ⚠️"
			return 0 # optional so ok
		else
			echo-style --e3="The [$name] required utility was not $(get_completion_action). ❌"
			return 1 # propagate the failure
		fi
	}

	# =====================================
	# Ecosystem Installers, groups sorted alphabetically, then installers sorted alphabetically

	# -------------------------------------
	# Alpine

	# apk / Alpine Linux
	# https://wiki.alpinelinux.org/wiki/Package_management
	# https://pkgs.alpinelinux.org/packages
	function do_apk {
		local args=() packages=()
		if test "${#APK[@]}" -ne 0; then
			packages+=("${APK[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing apk; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'apk'
				'del'
			)
		else
			# install / upgrade
			args+=(
				'apk'
				'add'
			)
		fi
		args+=('--update-cache')

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper -- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Anaconda

	# conda / Anaconda
	# https://docs.anaconda.com/anaconda/install/index.html
	# https://docs.conda.io/projects/conda/en/latest/commands.html
	# https://docs.conda.io/projects/conda/en/latest/commands/install.html
	# https://docs.conda.io/projects/conda/en/latest/commands/remove.html
	# https://docs.conda.io/projects/conda/en/latest/commands/update.html
	function do_conda {
		local args=() packages=() channel="$CONDA_CHANNEL"
		if test "${#CONDA[@]}" -ne 0; then
			packages+=("${CONDA[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing conda; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'conda'
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'conda'
				'update'
			)
		else
			args+=(
				'conda'
				'install'
			)
		fi
		if test -n "$channel"; then
			args+=(
				'--channel'
				"$channel"
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# AUR, Arch Linux

	# To determine which aur handler to use
	# Search https://archlinux.org/packages/
	# If it appears, use AUR
	# If it does not appear, use PAMAC as it is a manjaro repo

	# aurutils / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	# https://github.com/AladW/aurutils
	function do_aurutils {
		local args=() packages=() package
		if test "${#AURUTILS[@]}" -ne 0; then
			packages+=("${AURUTILS[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing aurutils; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		else
			# install / upgrade
			args+=(
				'aurutils'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# pacman / Arch Linux / Manjaro
	function do_pacman {
		local opts=() args=() packages=()
		if test "${#PACMAN[@]}" -ne 0; then
			packages=("${PACMAN[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pacman; then
			return 1 # not applicable
		fi

		# --noconfirm
		#   Bypass any and all “Are you sure?” messages. It’s not a good idea to do this unless you want to run pacman from a script.

		# -q, --quiet
		#   Show less information for certain query operations.

		# -y, --refresh
		#   Download fresh package databases from the server. Use twice to force a refresh even if databases are up to date.

		# -S, --sync
		#   Synchronize packages. Packages are installed directly from the remote repositories, including all dependencies required to run the packages.

		# -R, --remove
		#   Either a URL or file path can be specified. This is a “remove-then-add” process.

		# --needed
		#   Do not reinstall the targets that are already up-to-date.

		#  -U, --upgrade
		#   Upgrade or add package(s) to the system and install the required dependencies from sync repositories.

		# init the local database
		eval-helper --quiet="$quiet" \
			-- sudo-helper -- pacman-key --init

		# opts
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi
		opts+=('--noconfirm')

		# refresh the local database
		eval-helper --quiet="$quiet" \
			-- sudo-helper -- pacman "${opts[@]}" --refresh --sync

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pacman'
				'--remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'pacman'
				'--upgrade'
				'--needed'
			)
		else
			args+=(
				'pacman'
				'--sync'
				'--needed'
			)
		fi
		args+=("${opts[@]}")

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper -- "${args[@]}" "${packages[@]}"
	}

	# pakku / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	# https://github.com/kitsunyan/pakku
	function do_pakku {
		local args=() packages=() package
		if test "${#PAKKU[@]}" -ne 0; then
			packages+=("${PAKKU[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pakku; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		else
			# install / upgrade
			args+=(
				'pakku'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# pamac / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	# https://linuxcommandlibrary.com/man/pamac
	# sudo with pamac avoids gui sudo prompt
	function do_pamac {
		local args=() packages=()
		if test "${#PAMAC[@]}" -ne 0; then
			packages+=("${PAMAC[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pamac; then
			fallbacks+=('pamac')
			return 1 # required fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pamac'
				'remove'
			)
		else
			# install / reinstall / upgrade
			if test "$force" = 'yes'; then
				args+=(
					'pamac'
					'reinstall'
				)
			else
				args+=(
					'pamac'
					'install'
				)
			fi

			# without [--no-upgrade] pamac upgrades everything on the system, which can be over 40GB on initial upgrades
			args+=('--no-upgrade')
		fi
		args+=('--no-confirm')

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper -- "${args[@]}" "${packages[@]}"
	}
	function do_pamac_fallback {
		if ! is-manjaro; then
			return 1 # not applicable
		fi
		setup-util-pamac
		do_pamac "$@"
	}

	# paru / AUR / Arch Linux
	# https://itsfoss.com/paru-aur-helper/
	# https://github.com/Morganamilo/paru
	function do_paru {
		local args=() packages=() package
		if test "${#PARU[@]}" -ne 0; then
			packages+=("${PARU[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing paru; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		elif test "$upgrade" = 'yes'; then
			args+=(
				'paru'
				'-Sua'
			)
		else
			args+=(
				'paru'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# yay / AUR / Arch Linux
	# https://github.com/Jguer/yay
	function do_yay {
		local args=() packages=() package
		if test "${#YAY[@]}" -ne 0; then
			packages+=("${YAY[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing yay; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		else
			# install / upgrade
			args+=(
				'yay'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# -------------------------------------
	# BSD / Solaris

	# `doas` is a `sudo` replacement for OpenBSD
	# https://www.openbsdhandbook.com/openbsd_for_linux_users/

	# pkg / FreeBSD / Termux
	# https://www.freebsd.org/cgi/man.cgi?query=pkg&sektion=&n=1
	# https://www.freebsd.org/cgi/man.cgi?query=pkg-install
	function do_pkg {
		local args=() packages=()
		if test "${#PKG[@]}" -ne 0; then
			packages+=("${PKG[@]}")
		elif test "${#BSD[@]}" -ne 0; then
			packages+=("${BSD[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pkg; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pkg'
				'autoremove'
				'--yes'
			)
		else
			# install / upgrade
			args+=(
				'pkg'
				'install'
				'--yes'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# pkgadd / pkg_add / OpenBSD
	# https://docs.oracle.com/cd/E19455-01/806-0625/6j9vfilsu/index.html
	function do_pkgadd {
		local packages=() package
		if test "${#PKGADD[@]}" -ne 0; then
			packages+=("${PKGADD[@]}")
		elif test "${#BSD[@]}" -ne 0; then
			packages+=("${BSD[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pkgadd; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- pkgadd "$package"
		done
	}

	# pkgin / NetBSD
	# successor to pkg_in, pkg_add
	# https://pkgin.net/
	function do_pkgin {
		local args=() packages=() package
		if test "${#PKGIN[@]}" -ne 0; then
			packages+=("${PKGIN[@]}")
		elif test "${#BSD[@]}" -ne 0; then
			packages+=("${BSD[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pkgin; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pkgin'
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'pkgin'
				'upgrade'
			)
		else
			args+=(
				'pkgin'
				'install'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# -------------------------------------
	# Debian

	# apt / Ubuntu / Debian / Linux Mint / elementary OS / etc
	# installs remote .deb packages
	# sucessor to aptitude
	# https://wiki.debian.org/Apt
	function do_apt_key_fetch {
		local key="$1"
		if [[ $key == *'.asc' ]]; then
			# .asc files
			fetch "$key" | gpg --dearmor
		else
			# .key and unknown files
			fetch "$key"
		fi
	}
	function do_apt {
		local args=() packages=() repo="$APT_REPO" key="$APT_KEY" id="$APT_ID" keyring=''
		if test "${#APT[@]}" -ne 0; then
			packages+=("${APT[@]}")
		elif test "${#DEB[@]}" -ne 0; then
			packages+=("${DEB[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing apt-get; then
			return 1 # not applicable
		fi

		# if APT_REPO or APT_KEY are used, then determine APT_ID automatically, and fail if it couldn't be determined
		if test -n "$repo" -o -n "$key"; then
			if test -z "$id"; then
				if test "${#packages[@]}" -gt 1; then
					cat <<-EOF >/dev/stderr
						$(echo-style --error="If APT has multiple packages, then APT_ID must be specified.")

						APT: ${packages[*]}
					EOF
					return 1
				else
					id="${packages[*]}" # needed for the rm commands
				fi
			fi
		fi

		# ensure key has repo correctly set
		if test -n "$key"; then
			if test -z "$repo"; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_KEY is set, APT_REPO must also be set.")

					APT: ${packages[*]}
				EOF
				return 1
			fi
			if [[ $repo != *'signed-by'* ]]; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_KEY is set, APT_REPO must contain:")
					$(echo-style --code="deb [signed-by={KEY}] https://...")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
				return 1
			fi
		fi

		# ensure repo is correct for non deb urls
		if test -n "$repo" && [[ $repo == 'deb '* ]]; then
			if [[ $repo != *'arch={ARCH}'* ]]; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_REPO is set, arch must be set to {ARCH}")
					$(echo-style --code="deb [arch={ARCH}] https://...")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
				return 1
			fi
			if test -n "$key" && [[ $repo != *'signed-by={KEY}'* ]]; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_REPO and APT_KEY is set, signed-by must be set to {KEY}")
					$(echo-style --code="deb [signed-by={KEY}] https://...")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
				return 1
			fi
			if [[ $repo == *'http:'* ]]; then
				# warn
				cat <<-EOF >/dev/stderr
					$(echo-style --notice="APT_REPO contained " --code="http:" --notice=" instead of " --code="https:" --notice=" this may be an oversight.")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
			fi
		fi

		# prepare APT with APT_KEY
		if test -n "$key"; then
			# Deprecated technique is:
			# fetch ... | sudo-helper -- apt-key add -
			# Modern and working technique is what we do below...
			# which improves upon these incomplete and non-working suggestions:
			# https://blog.jak-linux.org/2021/06/20/migrating-away-apt-key/
			# https://packagecloud.io/blog/what-does-it-mean-to-add-a-repository-to-my-sources/#strongaddaptrepositorystrong
			# https://linuxize.com/post/how-to-add-apt-repository-in-ubuntu/
			# https://www.techrepublic.com/article/how-to-add-an-openpgp-repository-key-now-that-apt-key-is-deprecated/
			# https://stackoverflow.com/a/69015383/130638
			# https://askubuntu.com/a/1307181
			# https://askubuntu.com/a/1306494

			# prepare new location
			sudo-helper -- mkdir -p /usr/local/share/keyrings/
			keyring="/usr/local/share/keyrings/$id.gpg"

			# remove old keys if they exist
			sudo-helper -- rm -f /usr/local/share/keyrings/*"$id"* || :
			sudo-helper -- rm -f /etc/apt/trusted.gpg.d/*"$id"* || :

			# helper for quiet output
			function do_apt_key_add {
				# fetch and convert format, then import with export into correct format
				do_apt_key_fetch "$key" | sudo-helper -- gpg \
					--no-default-keyring \
					--keyring="gnupg-ring:$keyring" \
					--import # uses stdin
				# [gnupg-ring:] prefix creates keyring in apt compatible (legacy) v4 format

				# adjust permission to fix [_apt access error] on ubuntu 21.10
				sudo-helper -- chmod a+r "$keyring"
			}
			if test "$action" != 'uninstall'; then
				eval-helper --quiet="$quiet" \
					-- do_apt_key_add
			fi
		fi

		# prepare APT with APT_REPO
		if test -n "$repo"; then
			# remove old listings if they exist
			sudo-helper -- rm -f /etc/apt/sources.list.d/*"$id"* || :

			# add the repo with appropriate technique for the repo type
			if [[ $repo == 'deb '* ]]; then
				# adjust key modifier
				repo="${repo/"{KEY}"/"$keyring"}"

				# adjust arch modifier
				repo="${repo/"{ARCH}"/"$(
					dpkg --print-architecture
				)"}"

				# adjust release modifier
				repo="${repo/"{RELEASE}"/"$(
					lsb_release --codename --short
				)"}"

				# use a non-deprecated technique that supports the deb modifiers
				if test "$action" != 'uninstall'; then
					echo "$repo" | sudo-helper -- tee "/etc/apt/sources.list.d/$id.list" >/dev/null
				fi
			else
				# @todo consider automatic rewrites to the above
				# ppa:transmissionbt/ppa =>
				# deb https://ppa.launchpadcontent.net/transmissionbt/ppa/ubuntu/ jammy main

				# [apt-add-repository --help] notes [sudo apt-add-repository -y "$repo"] is deprecated
				# however the alternative for `ppa:` and other syntax is too complicated
				if test "$action" != 'uninstall'; then
					eval-helper --quiet="$quiet" \
						-- sudo-helper \
						-- apt-add-repository -y --enable-source "$repo"
				fi
			fi

			# to debug:
			# sudo apt-add-repository --list
		fi

		# if we added a new repo or key, we need to refresh the apt references
		if test -n "$repo" -o -n "$key"; then
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- apt-get update -y
		fi

		# action args
		if test "$action" = 'uninstall'; then
			# don't use `apt remove --purge` as it is equivalent to `apt purge`
			# and purge removing python will also remove ufw and samba and a whole bunch of other things that depend on python
			# as such, only use `--auto-remove` as that is safer
			args+=(
				'apt-get'
				'remove'
				'-y'
				'--auto-remove'
			)
		else
			# install / upgrade
			args+=(
				'apt-get'
				'install'
				'-y'
				'--fix-broken'
			)
		fi

		# packages
		# use `apt-get`, as `apt` produces this warning on Ubuntu 20.04.3 LTS
		# WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# dpkg / Debian / Ubuntu / Linux Mint / elementary OS / etc
	# installs local .deb files, and with our helper, remote .deb files
	# https://man7.org/linux/man-pages/man1/dpkg.1.html
	function do_dpkg {
		local args=() packages=() i=0 path='' url=''
		if test "${#DPKG[@]}" -ne 0; then
			packages+=("${DPKG[@]}")
		elif test "${#DEB[@]}" -ne 0; then
			packages+=("${DEB[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing dpkg; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'dpkg'
				'--remove'
			)
		else
			# install / upgrade
			args+=(
				'dpkg'
				'--install'
			)
		fi

		# convert urls to local
		for i in "${!packages[@]}"; do
			url="${packages[i]}"
			if [[ $url == 'http'* ]]; then
				# fetch temp path
				path="$(fs-temp --touch --directory='setup-util' --file="$name.deb")"
				# download to temp path
				down --path="$path" "$url"
				# update packge with its download path
				packages[i]="$path"
			fi
		done

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Flatpak

	# flatpak / Arch Linux / Manjaro
	# https://manpages.org/flatpak-install
	# https://wiki.debian.org/FlatPak
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-install
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-remote-add
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-remote-delete
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-uninstall
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-update
	# sudo with flatpak avoids gui sudo prompt
	function do_flatpak {
		local args=() packages=() repos=() package repo
		if test "${#FLATPAK[@]}" -ne 0; then
			packages+=("${FLATPAK[@]}")
		fi
		if test "${#FLATPAK_REPO[@]}" -ne 0; then
			repos+=("${FLATPAK_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing flatpak; then
			fallbacks+=('flatpak')
			return 1 # required fallback
		fi

		# repos
		args=()
		if test "$action" = 'uninstall'; then
			args+=(
				'flatpak'
				'remote-delete'
			)
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
		else
			args+=(
				'flatpak'
				'remote-add'
				'--if-not-exists'
			)
		fi
		for repo in "${repos[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$repo"
		done

		# args
		args=()
		if test "$action" = 'uninstall'; then
			args+=(
				'flatpak'
				'uninstall'
			)
			if test "$force" = 'yes'; then
				args+=('--force-remove')
			fi
		else
			# install / upgrade
			args+=(
				'flatpak'
				'install'
				'--or-update'
			)
			if test "$force" = 'yes'; then
				args+=('--reinstall')
			fi
		fi
		args+=(
			'--assumeyes'
			'--noninteractive'
		)

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}
	function do_flatpak_fallback {
		setup-util-flatpak
		do_flatpak "$@"
	}

	# ---------------------------------
	# GNU Guix System

	# guix / GNU Guix
	# https://linuxcommandlibrary.com/man/guix-package
	function do_guix {
		local args=() packages=()
		if test "${#GUIX[@]}" -ne 0; then
			packages+=("${GUIX[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing guix; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'guix'
				'package'
				'--remove'
			)
		else
			# install / upgrade
			args+=(
				'guix'
				'package'
				'--install'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Golang

	# go
	# https://helpmanual.io/man1/go-install/
	function do_go {
		local args=() packages=() package i
		if test "${#GO[@]}" -ne 0; then
			packages+=("${GO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing go; then
			fallbacks+=('go')
			return 1 # required fallback
		fi

		# uninstall for go get, which is no longer relevant
		# as go install is now the way it is done
		# https://stackoverflow.com/a/67620609/130638
		# args+=('go' 'get')
		# for i in "${!packages[@]}"; do
		# 	package="${packages[i]}"
		# 	package="${package%%@*}" # trim version suffix
		# 	packages[i]="${package}@none"
		# done

		# args
		if test "$action" = 'uninstall'; then
			# go install installs a single binary file
			if test -n "$cli" -a -n "${GOPATH-}"; then
				fs-rm --no-confirm --quiet="$quiet" -- "$GOPATH/bin/$cli"
				return "$?"
			else
				return 1 # unsupported, as GO is not CLI
			fi
		else
			# install / upgrade
			# GO='github.com/rfjakob/gocryptfs'
			args+=(
				'go'
				'install'
				'-v'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			if [[ $package != *'@'* ]]; then
				# append version if not there
				package="${package}@latest"
			fi
			eval-helper --quiet="$quiet" \
				-- "${args[@]}" "$package"
			# ^ don't use sudo, not needed, and requires env vars to function
		done
	}
	function do_go_fallback {
		setup-go
		source "$DOROTHY/sources/environment.sh"
		do_go "$@"
	}

	# -------------------------------------
	# Haskell

	# cabal / Haskell
	# https://www.haskell.org/cabal/
	# https://hackage.haskell.org/package/cabal-install
	# https://cabal.readthedocs.io/en/stable/
	# https://cabal.readthedocs.io/en/stable/cabal-commands.html
	# https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-update
	# https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-install
	function do_cabal {
		local args=() packages=()
		if test "${#CABAL[@]}" -ne 0; then
			packages+=("${CABAL[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing cabal; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		elif test "$upgrade" = 'yes'; then
			args+=(
				'conda'
				'update'
			)
		else
			args+=(
				'conda'
				'install'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# MacOS

	# brew / Homebrew / macOS
	function do_brew {
		local args=() opts=() packages=() taps=() tap
		if test "${#BREW[@]}" -ne 0; then
			packages+=("${BREW[@]}")
		fi
		if test "${#BREW_TAP[@]}" -ne 0; then
			taps+=("${BREW_TAP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if ! is-mac; then
			return 1 # not applicable
		fi
		if ! is-brew; then
			fallbacks+=('brew')
			return 1 # required fallback
		fi

		# opts
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# taps
		for tap in "${taps[@]}"; do
			eval-helper --quiet="$quiet" \
				-- brew tap "${opts[@]}" "$tap"
		done

		# args
		if test "$action" = 'uninstall'; then
			if brew-installed --formula -- "${packages[@]}" &>/dev/null; then
				args+=(
					'brew'
					'uninstall'
				)
			else
				return 0 # already uninstalled
			fi
		else
			# install / upgrade
			args+=(
				'brew'
				'install'
			)
		fi
		if test "$force" = 'yes'; then
			args+=('--force')
		fi
		args+=("${opts[@]}")

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_brew_fallback {
		if ! is-mac; then
			return 1 # not applicable
		fi
		setup-mac-brew install # don't do --configure, as setup-util should be as automated as possible
		source "$DOROTHY/sources/environment.sh"
		do_brew "$@"
	}

	# brew / Homebrew Casks / macOS
	# some packages are available as both brew, and cask
	# ... so provide both independently as they are alternatives
	function do_cask {
		local args=() opts=() packages=() taps=() tap
		if test "${#CASK[@]}" -ne 0; then
			packages+=("${CASK[@]}")
		fi
		if test "${#CASK_TAP[@]}" -ne 0; then
			taps+=("${CASK_TAP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if ! is-mac; then
			return 1 # not applicable
		fi
		if ! is-brew; then
			fallbacks+=('cask')
			return 1 # required fallback
		fi

		# opts
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# taps
		for tap in "${taps[@]}"; do
			eval-helper --quiet="$quiet" \
				-- brew tap "${opts[@]}" "$tap"
		done

		# args
		if test "$action" = 'uninstall'; then
			if brew-installed --cask -- "${packages[@]}" &>/dev/null; then
				args+=(
					'brew'
					'uninstall'
				)
			else
				return 0 # already uninstalled
			fi
		elif test "$upgrade" = 'yes'; then
			# upgrade
			args+=(
				'brew'
				'reinstall'
			)
		else
			# install
			args+=(
				'brew'
				'install'
			)
		fi
		if test "$force" = 'yes'; then
			args+=('--force')
		fi
		args+=(
			'--cask'
			"${opts[@]}"
		)

		# packages
		eval-helper --quiet="$quiet" --shapeshifter -- \
			"${args[@]}" "${packages[@]}"
		# ^ --shapeshifter required as casks (not formulas) can require sudo
		# which will cause echo-revolving-door to behave oddly
		#
		# > brew uninstall --cask --quiet cloudflare-warp | echo-revolving-door
		# pp
		# Password:
		#
		# < 'brew' 'uninstall' '--cask' '--quiet' 'cloudflare-warp' >
		# pp
		# Password:
	}
	function do_cask_fallback {
		if ! is-mac; then
			return 1 # not applicable
		fi
		setup-mac-brew install # don't do --configure, as setup-util should be as automated as possible
		source "$DOROTHY/sources/environment.sh"
		do_cask "$@"
	}

	# mas / Mac App Store
	# https://github.com/mas-cli/mas/issues
	# only use sudo on uninstall
	function mas_search {
		local package="$1" exact=() options=() id name
		while read -r id name; do
			# trim version from the name, it doesn't work in the `read` arguments, as spaces inside name will be considered the version
			name="${name%%  *}"
			if test "$(lc "$name")" = "$(lc "$arg")"; then
				exact+=("$id" "$name")
			else
				options+=("$id" "$name")
			fi
			# ^ append the id and name (which are space and tab separated)
		done < <(mas search "$arg" | env TIMEOUT=0 echo-trim-each-line | sort --ignore-case -k 2)
		# ^ trim superflous padding that will cause confusion to IFS

		# ensure exact match is first
		options=("${exact[@]}" "${options[@]}")

		# return the selection
		choose-option \
			--question="Which Mac App Store app was intended for $package?" \
			--label -- "${options[@]}"
	}
	function do_mas {
		local args=() packages=() package
		if test "${#MAS[@]}" -ne 0; then
			packages+=("${MAS[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if ! is-mac; then
			return 1 # not applicable
		fi
		if command-missing mas; then
			fallbacks+=('mas')
			return 1 # required fallback
		fi

		# action args
		if test "$action" = 'uninstall'; then
			# currently broken
			# https://github.com/mas-cli/mas/issues/313
			return 1 # unsupported
			# args+=(
			# 	'sudo-helper'
			# 	'--inherit'
			# 	'--'
			# 	'mas'
			# 	'uninstall'
			# )
		else
			# install / upgrade
			args+=(
				'mas'
				'install'
			)
		fi

		# signin, signout, no longer supported
		# local signed_in='maybe'
		# function mas_signin {
		# 	local email
		# 	if test "$signed_in" = 'yes'; then
		# 		return 0
		# 	fi
		# 	email="$(
		# 		ask --required \
		# 			--question="The Mac App Store requires your email, enter it now."
		# 	)"
		# 	if is-value "$email"; then
		# 		# mas signout || :
		# 		mas signin --dialog "$email" || {
		# 			echo-style --notice="Failed to signin to the Mac App Store."
		# 			return 1
		# 		}
		# 		signed_in='yes'
		# 	else
		# 		signed_in='no'
		# 		return 1
		# 	fi
		# }
		# function mas_action {
		# 	eval-helper --quiet="$quiet" \
		# 		-- "${args[@]}" "${packages[@]}"
		# }
		# mas_action || {
		# 	mas_signin && mas_action
		# }

		# packages
		for package in "${packages[@]}"; do
			# convert labels into ids
			if ! is-number "$package"; then
				package="$(mas_search "$package")"
			fi

			# action
			eval-helper --quiet="$quiet" \
				-- "${args[@]}" "$package"
		done
	}
	function do_mas_fallback {
		if ! is-mac; then
			return 1 # not applicable
		fi
		setup-util-mas
		do_mas "$@"
	}

	# port / MacPorts
	# https://guide.macports.org/#using.port.install
	# https://guide.macports.org/#using.port.uninstall
	# https://guide.macports.org/#using.port.upgrade
	function do_port {
		local args=() packages=() package
		if test "${#PORT[@]}" -ne 0; then
			packages+=("${PORT[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing port; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'port'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'port'
				'upgrade'
			)
		else
			args+=(
				'port'
				'install'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# ---------------------------------
	# Nix

	# nix
	# https://www.mankier.com/1/nix-env
	# https://nixos.org/manual/nix/stable/command-ref/nix-env.html
	# https://search.nixos.org/packages
	function do_nix {
		local args=() packages=()
		if test "${#NIX[@]}" -ne 0; then
			packages+=("${NIX[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing nix-env; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'nix-env'
				'--uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'nix-env'
				'--upgrade'
			)
		else
			args+=(
				'nix-env'
				'--install'
				'--attr'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Node.js

	# npm / Node.js
	function do_npm {
		local args=() packages=()
		if test "${#NPM[@]}" -ne 0; then
			packages+=("${NPM[@]}")
		elif test "${#NODE[@]}" -ne 0; then
			packages+=("${NODE[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi

		# source nvm if it exists
		set +e # nvm prevents strict from working: .nvm/nvm.sh: line 1966: TMPDIR: unbound variable
		source "$DOROTHY/sources/nvm.sh"

		# checks
		if command-missing npm; then
			fallbacks+=('npm')
			return 1 # required fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'npm'
				'uninstall'
				'--global'
			)
		else
			# install / upgrade
			args+=(
				'npm'
				'install'
				'--global'
			)
		fi
		if test "$force" = 'yes'; then
			args+=('--force')
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_npm_fallback {
		setup-node
		source "$DOROTHY/sources/environment.sh"
		do_npm "$@"
	}

	# @todo add yarn
	# https://github.com/yarnpkg/yarn/issues/2993

	# -------------------------------------
	# Python

	# pip / Python
	# https://man.archlinux.org/man/extra/python-pip/pip.1.en
	function pip_helper {
		# Use the correct [pip] executable for the user's environment, as there may be many or multiple installed, such as one for Python v2 and one for Python v3.
		if command-exists pip; then
			pip "$@"
		elif python -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists pip3; then
			pip3 "$@"
		elif python3 -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists pip2; then
			pip2 "$@"
		elif python2 -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists /usr/local/bin/pip; then
			/usr/local/bin/pip "$@"
		elif test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/pip"; then
			"${HOMEBREW_PREFIX}/bin/pip" "$@"
		else
			echo-style --error="[pip] nor its variations were found" >/dev/stderr
			return 1
		fi
	}
	function do_pip {
		local args=() packages=()
		if test "${#PIP[@]}" -ne 0; then
			packages+=("${PIP[@]}")
		elif test "${#PYTHON[@]}" -ne 0; then
			packages+=("${PYTHON[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if ! pip_helper --version &>/dev/null; then
			fallbacks+=('pip')
			return 1 # required fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pip_helper'
				'uninstall')
		else
			args+=(
				'pip_helper'
				'install'
			)
			if test "$upgrade" = 'yes'; then
				args+=('--upgrade')
			fi
			if test "$force" = 'yes'; then
				args+=('--force-reinstall ')
			fi
		fi
		args+=(
			'--user'
			'--no-warn-script-location'
		)

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_pip_fallback {
		setup-python
		source "$DOROTHY/sources/environment.sh"
		do_pip "$@"
	}

	# pipx / Python
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_install'
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_upgrade'
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_uninstall'
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_reinstall'
	function do_pipx {
		local args=() packages=()
		if test "${#PIPX[@]}" -ne 0; then
			packages+=("${PIPX[@]}")
		elif test "${#PYTHON[@]}" -ne 0; then
			packages+=("${PYTHON[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing pipx; then
			fallbacks+=('pipx')
			return 1 # required fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pipx'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'pipx'
				'upgrade'
			)
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
		else
			# if test "$force" = 'yes'; then
			#	args+=('reinstall')
			args+=(
				'pipx'
				'install'
			)
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_pipx_fallback {
		if ! pip_helper --version &>/dev/null; then
			setup-python
		fi
		setup-util-pipx
		source "$DOROTHY/sources/environment.sh"
		do_pipx "$@"
	}

	# -------------------------------------
	# RPM

	# dnf / COPR / Fedora / CentOS / RHEL
	# installs RPM files and remote RPM packages
	# successor to yum (same api)
	# uses rpm behind the scenes
	# https://dnf.readthedocs.io/en/latest/command_ref.html
	# https://opensource.com/article/18/8/guide-yum-dnf
	# https://docs.fedoraproject.org/en-US/quick-docs/dnf/
	function do_dnf {
		local opts=() args=() packages=() groups=() copr=() repos=()
		if test "${#DNF[@]}" -ne 0; then
			packages+=("${DNF[@]}")
		elif test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi
		if test "${#DNF_GROUP[@]}" -ne 0; then
			groups+=("${DNF_GROUP[@]}")
		fi
		if test "${#DNF_COPR[@]}" -ne 0; then
			copr+=("${DNF_COPR[@]}")
		fi
		if test "${#DNF_REPO[@]}" -ne 0; then
			repos+=("${DNF_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0 -a "${#groups[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing dnf; then
			return 1 # not applicable
		fi

		# opts
		opts+=(
			'-y'
			'--best'
			'--refresh'
		)
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# copr
		if test "${#copr[@]}" -ne 0; then
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- dnf "${opts[@]}" copr enable "${copr[@]}"
		fi

		# repos
		if test "${#repos[@]}" -ne 0; then
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- dnf "${opts[@]}" config-manager --add-repo "${repos[@]}"
		fi

		# groups
		if test "${#groups[@]}" -ne 0; then
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- dnf "${opts[@]}" groupinstall "${groups[@]}"
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'dnf'
				"${opts[@]}"
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'dnf'
				"${opts[@]}"
				'upgrade'
			)
		else
			args+=(
				'dnf'
				"${opts[@]}"
				'install'
			)
		fi

		# packages
		if test "${#packages[@]}" -ne 0; then
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "${packages[@]}"
		fi
	}

	# rpm / RedHat / Fedora / CentOS / etc
	# installs RPM files
	# does exist on OpenSUSE, even though yum and dnf do not
	function do_rpm {
		local args=() packages=() package
		if test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing rpm; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'rpm'
				'--erase'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'rpm'
				'--upgrade'
			)
		else
			args+=(
				'rpm'
				'--install'
			)
		fi
		if test "$quiet" != 'no'; then
			args+=('--quiet')
		fi

		# packages
		for package in "${packages[@]}"; do
			# verify it is a rpm file and was not inherted from DNF or YUM
			if test ! -f "$package"; then
				# it was not a file, so this is not a suitable combination
				return 1
			fi
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# urpmi / Mageia
	# installs RPMs
	# https://wiki.mageia.org/en/URPMI
	# https://wiki.mageia.org/en/URPMI#Basic_commands:_Install.2C_remove.2C_update
	function do_urpmi {
		local args=() packages=()
		if test "${#URPMI[@]}" -ne 0; then
			packages+=("${URPMI[@]}")
		elif test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing urpmi || command-missing urpme; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'urpme'
			)
		else
			# install / upgrade
			args+=(
				'urpmi'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# yum / rpm / RedHat / Fedora / CentOS / etc
	# installs RPM files and remote RPM packages
	# predecessor to dnf (same api)
	# uses rpm behind the scenes
	# https://man7.org/linux/man-pages/man8/yum.8.html#COMMANDS
	# autoremove                remove all unneeded packages that were originally installed as dependencies
	# check-update              check for available package upgrades
	# clean                     remove cached data
	# distro-sync               synchronize installed packages to the latest available versions
	# install                   install a package or packages on your system
	# reinstall                 reinstall a package
	# remove                    remove a package or packages from your system
	# upgrade                   upgrade a package or packages on your system
	# upgrade-minimal           upgrade, but only 'newest' package match which fixes a problem that affects your system
	# -b, --best                try the best available package versions in transactions.
	# -q, --quiet               quiet operation
	# -y, --assumeyes           automatically answer yes for all questions
	function do_yum {
		local opts=() args=() packages=() repos=() repo
		if test "${#YUM[@]}" -ne 0; then
			packages+=("${YUM[@]}")
		elif test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi
		if test "${#YUM_REPO[@]}" -ne 0; then
			repos+=("${YUM_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing yum; then
			return 1 # not applicable
		fi

		# opts
		opts+=(
			'-y'
			'--best'
		)
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# prepare YUM with YUM_REPO
		for repo in "${repos[@]}"; do
			eval-helper --quiet="$quiet" \
				-- down --directory='/etc/yum.repos.d/' "$repo"
		done

		if test "$action" = 'uninstall'; then
			args+=(
				'yum'
				"${opts[@]}"
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'yum'
				"${opts[@]}"
				'upgrade'
			)
		else
			args+=(
				'yum'
				"${opts[@]}"
				'install'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# zypper / openSUSE / SLES
	# installs RPM files and remote YaST2 and RPM packages
	# zypper needs sudo
	# https://www.mankier.com/8/zypper
	# https://www.mankier.com/8/zypper#Commands-Package_Management_Commands
	# https://en.opensuse.org/Portal:Zypper
	# https://documentation.suse.com/smart/linux/single-html/reference-zypper-install/index.html
	# https://en.opensuse.org/Snap
	function do_zypper {
		local opts=() args=() packages=() repo="$ZYPPER_REPO" alias="$ZYPPER_REPO_ALIAS"
		if test "${#ZYPPER[@]}" -ne 0; then
			packages+=("${ZYPPER[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing zypper; then
			return 1 # not applicable
		fi

		# opts
		opts=(
			'--non-interactive'
			'--gpg-auto-import-keys'
		)

		# repos
		if test -n "$repo"; then
			if test -n "$alias"; then
				eval-helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					addrepo --refresh "$repo" "$alias"

				eval-helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					dist-upgrade --auto-agree-with-licenses --no-confirm --from "$alias"
			else
				eval-helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					addrepo --refresh "$repo"

				eval-helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					refresh
			fi
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'zypper'
				"${opts[@]}"
				'remove'
			)
		else
			# install / upgrade
			args+=(
				'zypper'
				"${opts[@]}"
				'install'
			)
		fi
		args+=('--no-confirm')

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Ruby

	# gem / Ruby
	# we use --user-install because of:
	# https://github.com/ffi/ffi/issues/631
	function do_gem {
		local opts=() args=() packages=() package parts
		if test "${#GEM[@]}" -ne 0; then
			packages+=("${GEM[@]}")
		elif test "${#RUBY[@]}" -ne 0; then
			packages+=("${RUBY[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing gem; then
			fallbacks+=('gem')
			return 1 # required fallback
		fi

		# always uninstall
		# support multiple args inside RUBY, such as [--version ...]
		for package in "${packages[@]}"; do
			mapfile -t parts < <(echo-split ' ' -- "$package")
			eval-helper --quiet="$quiet" \
				-- gem uninstall -axI "${parts[0]}"
		done

		# args
		if test "$action" = 'uninstall'; then
			return 0 # already uninstalled above
		else
			# install / upgrade
			args+=(
				'gem'
				'install'
				"${opts[@]}"
			)
		fi

		# packages
		# support multiple args inside RUBY, such as [--version ...]
		for package in "${packages[@]}"; do
			mapfile -t parts < <(echo-split ' ' -- "$package")
			eval-helper --quiet="$quiet" \
				-- "${args[@]}" "${parts[@]}"
		done
	}
	function do_gem_fallback {
		setup-ruby
		source "$DOROTHY/sources/environment.sh"
		do_gem "$@"
	}

	# -------------------------------------
	# Rust

	# cargo / Crates.io / Rust
	# https://manpages.debian.org/testing/cargo/cargo-install.1.en.html
	# https://manpages.debian.org/testing/cargo/cargo-uninstall.1.en.html
	function do_cargo {
		local args=() packages=() package
		if test "${#CARGO[@]}" -ne 0; then
			packages+=("${CARGO[@]}")
		elif test "${#RUST[@]}" -ne 0; then
			packages+=("${RUST[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing cargo; then
			fallbacks+=('cargo')
			return 1 # required fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'cargo'
				'uninstall'
			)
		else
			# install / upgrade
			args+=(
				'cargo'
				'install'
			)
			if test "$force" != 'no'; then
				args+=('--force')
			fi
		fi
		if test "$quiet" != 'no'; then
			args+=('--quiet')
		fi

		# note cargo installs take a while
		if test "$action" = 'install' -a "$quiet" != 'yes'; then
			log-performance
		fi

		# packages
		# support multiple args inside CARGO
		for package in "${packages[@]}"; do
			mapfile -t parts < <(echo-split ' ' -- "$package")
			if test "$action" = 'uninstall' -a "${parts[0]}" = '--git'; then
				parts=("$cli")
			fi
			eval-helper --quiet="$quiet" \
				-- "${args[@]}" "${parts[@]}"
		done
	}
	function do_cargo_fallback {
		setup-rust
		source "$DOROTHY/sources/environment.sh"
		do_cargo "$@"
	}

	# -------------------------------------
	# Snap

	# snap / Snap Craft / Ubuntu
	# needs sudo, otherwise: error: access denied (try with sudo)
	function do_snap {
		local args=() packages=() channel="$SNAP_CHANNEL" package parts
		if test "${#SNAP[@]}" -ne 0; then
			packages+=("${SNAP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing snap; then
			fallbacks+=('snap')
			return 1 # required fallback
		fi
		if ! is-snap; then
			return 1 # not configured correctly
		fi

		# action args
		if test "$action" = 'uninstall'; then
			args+=(
				'snap'
				'remove'
			)
		else
			# install / upgrade
			args+=(
				'snap'
				'install'
			)
			if test -n "$channel"; then
				args+=("--channel=$channel")
			fi
		fi

		# packages
		# support multiple args inside SNAP
		for package in "${packages[@]}"; do
			mapfile -t parts < <(echo-split ' ' -- "$package")
			if test "$action" = 'uninstall'; then
				parts=("${parts[0]}") # if uninstalling, trim --classic
			fi
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "${parts[@]}"
		done

	}
	function do_snap_fallback {
		setup-util-snap
		do_snap "$@"
	}

	# -------------------------------------
	# Solus

	# eopkg / Solus
	# https://github.com/solus-project/package-management/blob/master/man/eopkg.1.md
	# @todo support repos
	function do_eopkg {
		local args=() packages=()
		if test "${#EOPKG[@]}" -ne 0; then
			packages+=("${EOPKG[@]}")
		elif test "${#SOLUS[@]}" -ne 0; then
			packages+=("${SOLUS[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing eopkg; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'eopkg'
				'autoremove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'eopkg'
				'upgrade'
			)
		else
			args+=(
				'eopkg'
				'install'
			)
		fi
		args+=('--yes-all')

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# ---------------------------------
	# Tea

	# tea, embedded, doesn't install man pages, even via [tea man bat]
	function do_tea {
		local args=() packages=()
		if test "${#TEA[@]}" -ne 0; then
			packages+=("${TEA[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if ! command-exists tea; then
			fallbacks+=('tea')
			return 1 # required fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			# remove tea aliases
			for package in "${packages[@]}"; do
				if test ! -e "$XDG_BIN_HOME/$package"; then
					return 0 # already uninstalled
				elif test "$(fs-realpath -- "$XDG_BIN_HOME/$package")" = "$(command -v tea)"; then
					rm -f "$XDG_BIN_HOME/$package"
				else
					return 1 # not applicable
				fi
			done
			return 0
		else
			# install / upgrade
			args+=('tea')
		fi

		# packages
		for package in "${packages[@]}"; do
			# install it by doing [tea $package --version]
			# it would be nice to use [command-working] however [command-working] currently expects multiple commands as arguments so it would become [command-working tea, command-working $package, command-working --version]
			eval-helper --quiet="$quiet" \
				-- "${args[@]}" "$package" --version

			# make tea alias available
			mkdir -p "$XDG_BIN_HOME"
			symlink-helper --quiet="$quiet" --existing="$(command -v tea)" --symlink="$XDG_BIN_HOME/$package"
		done
	}
	function do_tea_fallback {
		setup-util-tea
		source "$DOROTHY/sources/environment.sh"
		do_tea "$@"
	}

	# ---------------------------------
	# Void Linux

	# xbps / Void Linux
	# https://github.com/void-linux/xbps
	function do_xbps {
		local args=() packages=()
		if test "${#XBPS[@]}" -ne 0; then
			packages+=("${XBPS[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing xbps-remove || command-missing xbps-install; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'xbps-remove'
				'-R'
				'-O'
				'-o'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'xbps-install'
				'-u'
			)
		else
			args+=(
				'xbps-install'
				'--sync'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Windows

	# choco / cinst / Chocolatey / Windows
	# https://docs.chocolatey.org/en-us/choco/setup
	# https://docs.chocolatey.org/en-us/choco/commands/
	# https://community.chocolatey.org/packages
	# https://docs.chocolatey.org/en-us/choco/commands/uninstall
	# https://docs.chocolatey.org/en-us/choco/commands/upgrade
	# https://docs.chocolatey.org/en-us/choco/commands/install
	function do_choco {
		local cmd args=() packages=()
		if test "${#CHOCO[@]}" -ne 0; then
			packages+=("${CHOCO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-exists choco; then
			cmd='choco'
		elif command-exists cinst; then
			cmd='cinst'
		else
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				"$cmd"
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				"$cmd"
				'upgrade'
			)
		else
			args+=(
				"$cmd"
				'install'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}

	# scoop / Windows
	# https://scoop.sh/
	# https://github.com/ScoopInstaller/Scoop/wiki/Commands
	# https://github.com/ScoopInstaller/Scoop/wiki/Example-Setup-Scripts
	function do_scoop {
		local args=() packages=()
		if test "${#SCOOP[@]}" -ne 0; then
			packages+=("${SCOOP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing scoop; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'scoop'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'scoop'
				'update'
			)
		else
			args+=(
				'scoop'
				'install'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}

	# winget / Windows Package Manager Client
	# https://docs.microsoft.com/en-us/windows/package-manager/winget/
	# https://docs.microsoft.com/en-us/windows/package-manager/winget/install
	function do_winget {
		local args=() packages=()
		if test "${#WINGET[@]}" -ne 0; then
			packages+=("${WINGET[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing winget; then
			return 1 # not applicable
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'winget'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'winget'
				'upgrade'
			)
		else
			args+=(
				'winget'
				'install'
			)
		fi

		# packages
		eval-helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}

	# emerge / Portage / GURU / Gentoo Linux
	# https://en.wikipedia.org/wiki/Gentoo_Linux
	# https://wiki.gentoo.org/wiki/Emerge
	# https://wiki.gentoo.org/wiki/Portage
	# https://wiki.gentoo.org/wiki/Gentoo_Cheat_Sheet#Package_installation
	# https://dev.gentoo.org/~zmedico/portage/doc/man/emerge.1.html
	# https://packages.gentoo.org/categories
	function do_emerge {
		local args=() packages=() repos=() package repo
		if test "${#EMERGE[@]}" -ne 0; then
			packages+=("${EMERGE[@]}")
		fi
		if test "${#EMERGE_REPO[@]}" -ne 0; then
			repos=("${EMERGE_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 1 # not needed
		fi
		if command-missing emerge || command-missing eselect; then
			return 1 # not applicable
		fi

		# repos
		for repo in "${repos[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- eselect repository enable "$repo"
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- emerge --sync guru
		done

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'emerge'
				'--depclean'
			)
		else
			# install / upgrade
			args+=(
				'emerge'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval-helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# =====================================
	# Custom Installers

	function get_path_from_filename {
		local filename="$1"
		# only place in appimage_home if it keeps the appimage extension
		if [[ $filename == *'.app' ]]; then
			# macos /Applications/$filename.app
			echo "$HOME/Applications/$filename"
		elif [[ $filename == *'.appimage' ]]; then
			# macos $HOME/Applications/$filename.appimage
			mkdir -p "$APPIMAGE_HOME"
			echo "$APPIMAGE_HOME/$filename"
		else
			# macos $HOME/.local/bin/$filename
			mkdir -p "$XDG_BIN_HOME"
			echo "$XDG_BIN_HOME/$filename"
		fi
	}
	function verify_saved_path {
		local path="$1"

		# verify
		if test ! -e "$path"; then
			echo-style --error='Failed to install:' ' ' --code="$path"
			return 1
		fi

		# adjust
		fs-own --permissions='+x' -- "$path"

		# verify
		if [[ $path == *'.app' ]] && test -d "$path"; then
			return 0
		elif command-working "$path"; then
			return 0
		else
			echo-style --error='Failed to verify:' ' ' --code="$path"
			rm -f "$path" # remove so it doesn't interfere with other install methods and other processes
			return 1
		fi
	}

	# installer
	function do_installer {
		local args=() file file_or_url="$INSTALLER" filename="$INSTALLER_FILENAME" __open="$INSTALLER_OPEN"

		# check applicabile
		if test -n "$file_or_url"; then
			# optional filename
			if test -z "$filename"; then
				# include extension
				filename="$(basename "$file_or_url")"
			fi

			# check if it is local, or remote
			if test -e "$file_or_url"; then
				file="$file_or_url"
			else
				# it is remote
				# download it to a temporary location and use that
				file="$(
					fs-temp \
						--directory='setup-util' \
						--directory="$name" \
						--file="$filename"
				)"
				down "$file_or_url" --path="$file"
			fi

			# ensure it is executable, then open or run it
			chmod +x "$file"
			if test "$__open" = 'yes'; then
				open "$file"
			elif [[ $file == *'/setup-util-'* ]]; then
				# dorothy installer
				# in which case forward the arguments
				# and note SETUP_UTIL=yes to prevent recursion
				# but do not forward order, as the installer may have custom arguments
				eval-helper --quiet="$quiet" \
					-- env SETUP_UTIL=yes "$file" \
					--action="$action" \
					--confirm="$confirm" \
					--force="$force" \
					--optional="$optional" \
					--quiet="$quiet" \
					--upgrade="$upgrade"
			else
				# external installer script
				eval-helper --quiet="$quiet" \
					-- "$file"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# eval
	function do_eval {
		local scripts=() script
		if test "${#EVAL[@]}" -ne 0; then
			scripts+=("${EVAL[@]}")
		fi

		# checks
		if test "${#scripts[@]}" -eq 0; then
			return 1 # not needed
		fi

		# action
		# eval-helper --quiet="$quiet" -- \
		# 	"${scripts[@]}"
		for script in "${scripts[@]}"; do
			("$script")
		done
	}

	# github
	function do_github {
		local path slug="$GITHUB_SLUG" filename="$GITHUB_FILENAME" ref="$GITHUB_REF" release="$GITHUB_RELEASE" pathname="$GITHUB_PATHNAME" asset_filter="$GITHUB_ASSET_FILTER" unzip_format="$GITHUB_UNZIP_FORMAT" unzip_filter="$GITHUB_UNZIP_FILTER"

		# check applicabile
		if test -n "$slug"; then
			# require filename
			if test -z "$filename"; then
				echo-style --error="GITHUB requires GITHUB_FILENAME"
				return 1
			fi

			# determine path
			path="$(get_path_from_filename "$filename")"

			# uninstall?
			if test "$action" = 'uninstall'; then
				rm -f "$path"
				return 0
			fi

			# download
			github-download \
				--quiet="$quiet" \
				--slug="$slug" \
				--ref="$ref" \
				--release="$release" \
				--pathname="$pathname" \
				--asset-filter="$asset_filter" \
				--unzip-format="$unzip_format" \
				--unzip-filter="$unzip_filter" \
				--path="$path"

			# verify
			verify_saved_path "$path"
		else
			# not applicable
			return 1
		fi
	}

	# download
	function do_download {
		local path download="$DOWNLOAD" filename="$DOWNLOAD_FILENAME" unzip_format="$DOWNLOAD_UNZIP_FORMAT" unzip_filter="$DOWNLOAD_UNZIP_FILTER"

		# check applicabile
		if test -n "$download"; then
			# require filename
			if test -z "$filename"; then
				echo-style --error="DOWNLOAD requires DOWNLOAD_FILENAME"
				return 1
			fi

			# determine path
			path="$(get_path_from_filename "$filename")"

			# uninstall?
			if test "$action" = 'uninstall'; then
				rm -f "$path"
				return 0
			fi

			# download
			down "$download" \
				--quiet="$quiet" \
				--unzip-format="$unzip_format" \
				--unzip-filter="$unzip_filter" \
				--path="$path"

			# verify
			verify_saved_path "$path"
		else
			# not applicable
			return 1
		fi
	}

	# =====================================
	# Action

	local installer

	# cycle through the order
	for installer in "${order[@]}"; do
		# sanity check
		if test -z "$installer"; then
			echo-style --error="an empty order argument was provided"
			echo-verbose "${order[@]}"
			return 22 # Invalid argument
		fi
		# # this installer was disabled, ignore
		# if test -z "$installer"; then
		# 	continue
		# fi
		# attempt installation
		if "do_${installer}"; then
			won "$installer"
			return 0
		fi
	done

	# fallback for failed packages which are missing their package system
	if test "$fallback" = 'yes'; then
		if test "${#fallbacks[@]}" -ne 0; then
			for installer in "${fallbacks[@]}"; do
				if "do_${installer}_fallback"; then
					won "$installer"
					return 0
				fi
			done
		fi
	fi

	# failure
	lost
	return "$?"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup-util "$@"
fi
