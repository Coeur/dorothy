#!/usr/bin/env bash

# @todo
# consider something like
# pkg=($(get-first-array "${PAMAC[@]}" -- "${AUR[@]}" -- "${ARCH[@]}"))
#
# check for leftover pkgs[@]
#
# APT='apt-transport-https ca-certificates'
# and all others need to be changed

function setup_util() (
	source "$DOROTHY/sources/bash.bash"
	require_array 'mapfile'
	source "$(type -P eval-helper)"

	# when running via fresh installer environment, ensure that environment gets configured
	if test -z "${DOROTHY_ENVIRONMENT-}"; then
		source "$DOROTHY/sources/environment.sh"
	fi

	# prefer precompiled with autoupdate with extras
	# extras = man pagages, autocompletes, etc
	local installers=(
		# +precompiled +compiling +autoupdate +extras
		brew
		cask

		# +precompiled +compiling +autoupdate +extras
		apt    # debian package manager (supports DEB, successor to aptitude)
		apk    # alpine package manager (supports APK)
		zypper # opensuse package manager (supports YaST, RPM)
		dnf    # fedora package manager (supports RPM, successor to yum)
		yum    # fedora package manager (supports RPM, predecessor to dnf)

		# +precompiled[containers] +autoupdate +extras
		snap    # dependencies are within the snap
		flatpak # dependencies are their own flatpaks, but everything is precompiled

		# +precompiled[first-class AUR support] +autoupdate +extras
		pamac  # manjaro package manager: GUI+CLI, vala, wraps libalpm, snap, flatpak: https://gitlab.manjaro.org/applications/pamac/
		pacman # arch package manager: CLI, c, wraps libalpm: https://wiki.archlinux.org/title/pacman

		# +precompiled[third-party AUR wrappers] +autoupdate +extras
		# https://wiki.archlinux.org/title/AUR_helpers
		# https://wiki.manjaro.org/index.php?title=Pamac
		# https://wiki.manjaro.org/index.php/Arch_User_Repository
		# https://itsfoss.com/paru-aur-helper/
		# https://itsfoss.com/best-aur-helpers/
		yay      # GUI, go, wraps pacman: https://github.com/Jguer/yay
		paru     # CLI, rust, wraps pacman: https://github.com/Morganamilo/paru
		pakku    # CLI, nim, wraps pacman: https://github.com/kitsunyan/pakku
		aurutils # CLI, shell, wraps pacman: https://github.com/AladW/aurutils

		# +precompiled -autoupdate +extras
		dpkg # is available on debian, however apt is preferred
		rpm  # is available on opensuse, however zypper is preferred

		# +precompiled -autoupdate -extras
		download # remote download from url

		# +compiling +autoupdate
		cargo # prefer over go
		go

		# +jit +autoupdate
		npm  # prefer over python and ruby
		gem  # prefer over python
		pipx # prefer over pip
		pip

		# +precompiled +autoupdate
		mas

		# windows, unknown features
		scoop
		winget
		choco # choco/chocolatey/cinst, interferes with WSL, so should be last preference on windows

		# solaris/bsd, unknown features
		pkgin
		pkgadd
		pkg

		# unknown features
		cabal
		conda
		emerge
		eopkg
		guix
		nix
		port
		xbps
		urpmi

		# disable/removed as no documentation
		# pkgutil
		# pkgman
		# huber
		# eget
		# stack
		# kiss

		# these just trigger one of the above with special wrapping
		tea       # +precompiled -autoupdate -extras +experimental
		installer # local or remote installer
		'eval'    # run a function or another script
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Install a utility with support for several package managers.

			USAGE:
			setup-util [...options]

			OPTIONS:
			--order=<...installers>
			    Used to override the preferred order of installers, space separated.

			--installer=<installer> -- <...packages>
			    Used to override the preferred order of installers.

			--cli=<cli>
			    Used to check if the utility is already installed.

			--app=<app>
			    Used to check if the utility is already installed.

			--name=<name>
			    The name to use for the utility in human readable output, such as log messages.

			--confirm
			    Confirm installation of the utility before installing it.

			--optional
			    If truthy, do not return a failure code if the action was unable to be performed.

			--no-fallback
			    If truthy, do not install a package system in order to install the package.

			--force
			    If truthy, use the installer's force mode if supported.

			--upgrade
			    If omitted, do not reinstall if already installed.
			    Not all installers support this.

			--uninstall | --action=uninstall
			    If truthy, if the utility is already installed then uninstall it.
			    Not all installers support this.

			--quiet
			    If unspecified, outputs only useful things.
			    If truthy, don't output anything that isn't an error message.
			    If falsey, output everything.

			... <installers> provide the remaining arguments,
			for now they are only documented in the source code.

			INSTALLERS:
			The following installers are supported, in this default order of preference:

			    ${installers[*]}

			EXAMPLE:

			setup-util --name='bottom' --cli='btm' --order='brew cargo aur' \
			    AUR='bottom-bin' \
			    BREW='bottom' \
			    CARGO='bottom'
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# installer options
	local APK=()
	local APT=() APT_REPO='' APT_KEY='' APT_ID=''
	local AUR=()
	local AURUTILS=()
	local BREW=() BREW_TAP=()
	local BSD=()
	local CABAL=()
	local CARGO=() RUST=()
	local CASK=() CASK_TAP=()
	local CHOCO=() CHOCOLATEY=() CINST=()
	local CONDA=() CONDA_CHANNEL=''
	local DNF=() DNF_GROUP=() DNF_COPR=() DNF_REPO=()
	local DOWNLOAD='' DOWNLOAD_FILENAME='' DOWNLOAD_UNZIP_FORMAT='' DOWNLOAD_UNZIP_FILTER='' DOWNLOAD_BUILD_EVAL='' DOWNLOAD_BUILD_FILTER=''
	local DPKG=() DEB=()
	local EMERGE=() EMERGE_REPO=()
	local EOPKG=()
	local EVAL=()
	local FLATPAK=() FLATPAK_REPO=()
	local GEM=() RUBY=()
	local GO=()
	local GUIX=()
	local INSTALLER='' INSTALLER_FILENAME='' INSTALLER_OPEN=''
	local MAS=()
	local NIX=()
	local NPM=() NODE=()
	local PACMAN=()
	local PAKKU=()
	local PAMAC=()
	local PARU=()
	local PIPX=() PIP=() PYTHON=()
	local PKG=()
	local PKGADD=()
	local PKGIN=()
	local PORT=()
	local RPM=()
	local SCOOP=()
	local SNAP=() SNAP_CHANNEL=''
	local TEA=()
	local URPMI=()
	local WINGET=()
	local XBPS=()
	local YAY=()
	local YUM=() YUM_REPO=()
	local ZYPPER=() ZYPPER_REPO='' ZYPPER_REPO_ALIAS=''

	# process
	local item action='install' installer='' app='' cli='' name='' quiet confirm='no' optional='no' fallback='yes' upgrade='no' force='no' order=()
	quiet="$(echo-quiet -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--install') action='install' ;;
		'--uninstall') action='uninstall' ;;
		'--action='*) action="${item#*--action=}" ;;
		'--order='*) mapfile -t order < <(echo-split ' ' -- "${item#--order=}") ;;
		'--installer='*) installer="${item#--installer=}" ;;
		'--app='*) app="${item#--app=}" ;;
		'--cli='*) cli="${item#--cli=}" ;;
		'--name='*) name="${item#--name=}" ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		'--no-confirm'* | '--confirm'*)
			confirm="$(
				get-flag-value confirm --missing="$confirm" -- "$item" | echo-affirmative
			)"
			;;
		'--no-optional'* | '--optional'*)
			optional="$(
				get-flag-value optional --missing="$optional" -- "$item" | echo-affirmative
			)"
			;;
		'--no-fallback'* | '--fallback'*)
			fallback="$(
				get-flag-value fallback --missing="$fallback" -- "$item" | echo-affirmative
			)"
			;;
		'--no-force'* | '--force'*)
			force="$(
				get-flag-value force --missing="$force" -- "$item" | echo-affirmative
			)"
			;;
		'--no-upgrade'* | '--upgrade'*)
			upgrade="$(
				get-flag-value upgrade --missing="$upgrade" -- "$item" | echo-affirmative
			)"
			;;
		'--')
			if test -z "$installer"; then
				help "--installer=<installer> is required when using -- <...packages>"
			fi
			if test -z "$name"; then
				name="$installer:$*"
			fi
			if test "$#" -eq 0; then
				return 0 # no packages to install
			fi
			while test "$#" -ne 0; do
				if [[ $1 == *"="* ]]; then
					break
				fi
				set -- "$@" "$installer=$1"
				shift
			done
			continue
			;;

			# installer options
		'ALPINE='*) APK+=("${item#*ALPINE=}") ;; # alias for APK
		'APK='*) APK+=("${item#*APK=}") ;;
		'APPIMAGE='*) APPIMAGE+=("${item#*APPIMAGE=}") ;;
		'APT_ID='*) APT_ID="${item#*APT_ID=}" ;;
		'APT_KEY='*) APT_KEY="${item#*APT_KEY=}" ;;
		'APT_REPO='*) APT_REPO="${item#*APT_REPO=}" ;;
		'APT='*) APT+=("${item#*APT=}") ;;
		'ARCH='*) AUR+=("${item#*ARCH=}") ;; # alias for AUR
		'AUR='*) AUR+=("${item#*AUR=}") ;;
		'AURUTILS='*) AURUTILS+=("${item#*AURUTILS=}") ;;
		'BREW_TAP='*) BREW_TAP+=("${item#*BREW_TAP=}") ;;
		'BREW='*) BREW+=("${item#*BREW=}") ;;
		'BSD='*) BSD+=("${item#*BSD=}") ;;
		'CABAL='*) CABAL+=("${item#*CABAL=}") ;;
		'CARGO='*) CARGO+=("${item#*CARGO=}") ;;
		'CASK_TAP='*) CASK_TAP+=("${item#*CASK_TAP=}") ;;
		'CASK='*) CASK+=("${item#*CASK=}") ;;
		'CHOCO='*) CHOCO+=("${item#*CHOCO=}") ;;
		'CHOCOLATEY='*) CHOCOLATEY+=("${item#*CHOCOLATEY=}") ;;
		'CINST='*) CINST+=("${item#*CINST=}") ;;
		'CONDA_CHANNEL='*) CONDA_CHANNEL="${item#*CONDA_CHANNEL=}" ;;
		'CONDA='*) CONDA+=("${item#*CONDA=}") ;;
		'DEB='*) DEB+=("${item#*DEB=}") ;;
		'DEBIAN='*) DEB+=("${item#*DEBIAN=}") ;; # alias for DEB
		'DNF_COPR='*) DNF_COPR+=("${item#*DNF_COPR=}") ;;
		'DNF_GROUP='*) DNF_GROUP+=("${item#*DNF_GROUP=}") ;;
		'DNF_REPO='*) DNF_REPO+=("${item#*DNF_REPO=}") ;;
		'DNF='*) DNF+=("${item#*DNF=}") ;;
		'DOWNLOAD_BUILD_EVAL='*) DOWNLOAD_BUILD_EVAL="${item#*DOWNLOAD_BUILD_EVAL=}" ;;
		'DOWNLOAD_BUILD_FILTER='*) DOWNLOAD_BUILD_FILTER="${item#*DOWNLOAD_BUILD_FILTER=}" ;;
		'DOWNLOAD_FILENAME='*) DOWNLOAD_FILENAME="${item#*DOWNLOAD_FILENAME=}" ;;
		'DOWNLOAD_UNZIP_FILTER='*) DOWNLOAD_UNZIP_FILTER="${item#*DOWNLOAD_UNZIP_FILTER=}" ;;
		'DOWNLOAD_UNZIP_FORMAT='*) DOWNLOAD_UNZIP_FORMAT="${item#*DOWNLOAD_UNZIP_FORMAT=}" ;;
		'DOWNLOAD='*) DOWNLOAD="${item#*DOWNLOAD=}" ;;
		'DPKG='*) DPKG+=("${item#*DPKG=}") ;;
		'EMERGE_REPO='*) EMERGE+=("${item#*EMERGE_REPO=}") ;;
		'EMERGE='*) EMERGE+=("${item#*EMERGE=}") ;;
		'EOPKG='*) EOPKG+=("${item#*EOPKG=}") ;;
		'EVAL='*) EVAL+=("${item#*EVAL=}") ;;
		'FEDORA='*) DNF+=("${item#*FEDORA=}") ;; # alias for DNF
		'FLATPAK_REPO='*) FLATPAK_REPO+=("${item#*FLATPAK_REPO=}") ;;
		'FLATPAK='*) FLATPAK+=("${item#*FLATPAK=}") ;;
		'GEM='*) GEM+=("${item#*GEM=}") ;;
		'GENTOO='*) EMERGE+=("${item#*GENTOO=}") ;; # alias for EMERGE
		'GO='*) GO+=("${item#*GO=}") ;;
		'GUIX='*) GUIX+=("${item#*GUIX=}") ;;
		'INSTALLER_FILENAME='*) INSTALLER_FILENAME="${item#*INSTALLER_FILENAME=}" ;;
		'INSTALLER_OPEN='*) INSTALLER_OPEN="${item#*INSTALLER_OPEN=}" ;;
		'INSTALLER='*) INSTALLER="${item#*INSTALLER=}" ;;
		'MACPORTS='*) PORT+=("${item#*MACPORTS=}") ;; # alias for PORT
		'MAGEIA='*) URPMI+=("${item#*MAGEIA=}") ;;    # alias for URPMI
		'MAS='*) MAS+=("${item#*MAS=}") ;;
		'NIX='*) NIX+=("${item#*NIX=}") ;;
		'NODE='*) NODE+=("${item#*NODE=}") ;;
		'NPM='*) NPM+=("${item#*NPM=}") ;;
		'OPENSUSE='*) ZYPPER+=("${item#*OPENSUSE=}") ;; # alias for ZYPPER
		'PACMAN='*) PACMAN+=("${item#*PACMAN=}") ;;
		'PAKKU='*) PAKKU+=("${item#*PAKKU=}") ;;
		'PAMAC='*) PAMAC+=("${item#*PAMAC=}") ;;
		'PARU='*) PARU+=("${item#*PARU=}") ;;
		'PIP='*) PIP+=("${item#*PIP=}") ;;
		'PIPX='*) PIPX+=("${item#*PIPX=}") ;;
		'PKG='*) PKG+=("${item#*PKG=}") ;;
		'PKGADD='*) PKGADD+=("${item#*PKGADD=}") ;;
		'PKGIN='*) PKGIN+=("${item#*PKGIN=}") ;;
		'PORT='*) PORT+=("${item#*PORT=}") ;;
		'PYTHON='*) PYTHON+=("${item#*PYTHON=}") ;;
		'RPM='*) RPM+=("${item#*RPM=}") ;;
		'RUBY='*) RUBY+=("${item#*RUBY=}") ;;
		'RUST='*) RUST+=("${item#*RUST=}") ;;
		'SCOOP='*) SCOOP+=("${item#*SCOOP=}") ;;
		'SNAP_CHANNEL='*) SNAP_CHANNEL="${item#*SNAP_CHANNEL=}" ;;
		'SNAP='*) SNAP+=("${item#*SNAP=}") ;;
		'SOLUS='*) EOPKG+=("${item#*SOLUS=}") ;; # alias for EOPKG
		'SUSE='*) ZYPPER+=("${item#*SUSE=}") ;;  # alias for ZYPPER
		'TEA='*) TEA+=("${item#*TEA=}") ;;
		'UBUNTU='*) APT+=("${item#*UBUNTU=}") ;; # alias for APT
		'URPMI='*) URPMI+=("${item#*URPMI=}") ;;
		'VOID='*) XBPS+=("${item#*VOID=}") ;; # alias for XBPS
		'WINGET='*) WINGET+=("${item#*WINGET=}") ;;
		'XBPS='*) XBPS+=("${item#*XBPS=}") ;;
		'YAY='*) YAY+=("${item#*YAY=}") ;;
		'YUM_REPO='*) YUM_REPO+=("${item#*YUM_REPO=}") ;;
		'YUM='*) YUM+=("${item#*YUM=}") ;;
		'ZYPPER_REPO_ALIAS='*) ZYPPER_REPO_ALIAS="${item#*ZYPPER_REPO_ALIAS=}" ;;
		'ZYPPER_REPO='*) ZYPPER_REPO="${item#*ZYPPER_REPO=}" ;;
		'ZYPPER='*) ZYPPER+=("${item#*ZYPPER=}") ;;
		'--'*) ;; # passively ignore, could be custom arg, such as --paths for setup-util-plex
		*) help "An unrecognised flag was provided: $item" ;;
		esac
	done

	# ensure action
	if test -z "$action"; then
		action='install'
	fi
	if ! [[ $action =~ install|uninstall|upgrade ]]; then
		help 'Invalid <action>, must be [install], [uninstall], or [upgrade].'
	fi

	# if uninstall, disable upgrade
	if test "$action" = 'uninstall'; then
		upgrade='no'
	fi

	# ensure name fallback
	if test -z "$name" -a -n "$app"; then
		name="$app"
	fi
	if test -z "$name" -a -n "$cli"; then
		name="$cli"
	fi
	if test -z "$name" -a -n "$installer"; then
		name="$installer"
	fi
	if test -z "$name"; then
		echo-style --error="Either <name>, <cli>, <app> must be provided. See [$0 --help] for usage." >/dev/stderr
		return 22 # EINVAL 22 Invalid argument
	fi

	# ensure order
	local temp_order installer inject_installer
	if test "${#order[@]}" -eq 0; then
		order=("${installers[@]}")
	else
		# custom order, handle ...
		# so [snap ...] means snap first, then everything else, whereas [... apt] means everyting then apt
		# as such, the specified installers need to be trimmed from the ... substitution
		# @todo this will currently hard fail if there is two ... occurences
		temp_order=()
		for installer in "${order[@]}"; do
			if test "$installer" = '...'; then
				for inject_installer in "${installers[@]}"; do
					if is-needle "$inject_installer" "${order[@]}"; then
						continue
					else
						temp_order+=("$inject_installer")
					fi
				done
			else
				temp_order+=("$installer")
			fi
		done
		order=("${temp_order[@]}")
	fi

	# =====================================
	# Process

	function maybe_echo_style {
		if test "$quiet" != 'yes'; then
			echo-style "$@"
		fi
	}
	function get_path_from_filename {
		local filename="$1"
		# only place in appimage_home if it keeps the appimage extension
		if [[ $filename == *'.app' ]]; then
			# macos /Applications/$filename.app
			print_line "$HOME/Applications/$filename"
		elif [[ $filename == *'.appimage' ]]; then
			# macos $HOME/Applications/$filename.appimage
			mkdir -p "$APPIMAGE_HOME"
			print_line "$APPIMAGE_HOME/$filename"
		else
			# macos $HOME/.local/bin/$filename
			mkdir -p "$XDG_BIN_HOME"
			print_line "$XDG_BIN_HOME/$filename"
		fi
	}
	function verify_saved_path {
		local path="$1"

		# verify
		if test ! -e "$path"; then
			echo-style --error='Failed to install:' ' ' --code="$path"
			return 1
		fi

		# adjust
		fs-own --permissions='+x' -- "$path"

		# verify
		if [[ $path == *'.app' ]] && test -d "$path"; then
			return 0
		elif command-working "$path"; then
			return 0
		else
			echo-style --error='Failed to verify:' ' ' --code="$path"
			rm_helper "$path" # remove so it doesn't interfere with other install methods and other processes
			return 1
		fi
	}
	function exists_helper { # 👍 /docs/bash/errors: robust exit status
		local path="$1"
		test -e "$path" -o -L "$path"
	}
	function rm_helper {
		local path="$1"

		# prefer moving to trash
		# because trash allows invocations to continue
		# otherwise active invocations will crash (such as setup-util-bash unisntlling the bash it was invoked with)
		if exists_helper "$path"; then
			fs-rm --no-confirm --quiet --trash -- "$path"
		fi
	}

	# prepare fallbacks, for when the package could be installed, but requires the package system to sshe installed first
	# which will be used, if none of the package systems were present, as such proceed in order of preference for installation of package systems
	local fallbacks=()

	# check if exists
	local app_exists='' cli_exists='' cli_working=''
	if test -n "$app"; then
		if get-app --quiet "$app"; then
			app_exists='yes'
		else
			app_exists='no'
		fi
	fi
	if test -n "$cli"; then
		if command-exists "$cli"; then
			cli_exists='yes'
			if command-working "$cli"; then
				cli_working='yes'
			else
				cli_working='no'
			fi
		else
			cli_exists='no'
			cli_working='no'
		fi
	fi

	# check if necessary
	if test -n "$app" -o -n "$cli"; then
		if test "$app_exists" != 'yes' -a "$cli_exists" != 'yes'; then
			# neither installed
			if test "$action" = 'uninstall'; then
				# already uninstalled, so no need to uninstall
				maybe_echo_style --g3="The [$name] utility was not found. Already uninstalled. ✅"
				# exit
				return 0
			fi
			upgrade='no' # note that we aren't upgrading, which is used for logging
			# perform install
			maybe_echo_style --h3="The [$name] utility was not found. Installing automatically... ⏲"
		elif test "$action" = 'uninstall'; then
			# exists, uninstall enabled
			upgrade='no' # note that we aren't upgrading, which is used for logging
			# perform uninstall
			maybe_echo_style --h3="The [$name] utility is marked for uninstall. Uninstalling... ⏲"
		elif test "$upgrade" = 'yes'; then
			# exists, upgrade enabled
			# perform upgrade
			maybe_echo_style --h3="The [$name] utility is marked for upgrade. Upgrading... ⏲"
		elif test "$cli_working" = 'fail'; then
			# exists, not working
			# perform reinstall
			maybe_echo_style --h3="The [$name] utility via [$cli] is misbehaving. Reinstalling automatically... ⏲"
		else
			# exists, no upgrade, is working
			# already installed, so no need to install again
			maybe_echo_style --g3="The [$name] utility is already installed. ✅"
			return 0
		fi
	fi

	# for upgrade only, remove xdg bin if it exists, as we don't want conflicts if it is deprecated
	# do not do this for uninstall, as we want the actuall methods to handle that
	if test "$upgrade" = 'yes'; then
		if test -n "$cli" -a -e "$XDG_BIN_HOME/$cli"; then
			rm_helper "$XDG_BIN_HOME/$cli"
		fi
	fi

	# confirm if necessary
	if test "$confirm" = 'yes'; then
		if ! confirm --positive --ppid=$$ -- "Do you want to setup the [$name] utility?"; then
			# we don't want to modify it
			if test "$optional" = 'yes'; then
				# it was optional, so success case
				return 0
			else
				# it was not optional, so abort
				return 125 # ECANCELED 125 Operation cancelled
			fi
		fi
	fi

	# =====================================
	# Ecosystem Installers, groups sorted alphabetically, then installers sorted alphabetically

	# -------------------------------------
	# Alpine

	# apk / Alpine Linux
	# https://wiki.alpinelinux.org/wiki/Package_management
	# https://pkgs.alpinelinux.org/packages
	function are_any_of_these_apk_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local package packages=("$@")
		# returns 1 if any are missin
		for package in "${packages[@]}"; do
			if apk info "$package" &>/dev/null; then
				return 0
			fi
		done
		return 1
	}
	function do_apk {
		local args=() packages=()
		if test "${#APK[@]}" -ne 0; then
			packages+=("${APK[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing apk; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_apk_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'apk'
				'del'
			)
		else
			# install / upgrade
			args+=(
				'apk'
				'add'
			)
		fi
		args+=('--update-cache')

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper -- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Anaconda

	# conda / Anaconda
	# https://docs.anaconda.com/anaconda/install/index.html
	# https://docs.conda.io/projects/conda/en/latest/commands.html
	# https://docs.conda.io/projects/conda/en/latest/commands/install.html
	# https://docs.conda.io/projects/conda/en/latest/commands/remove.html
	# https://docs.conda.io/projects/conda/en/latest/commands/update.html
	function do_conda {
		local args=() packages=() channel="$CONDA_CHANNEL"
		if test "${#CONDA[@]}" -ne 0; then
			packages+=("${CONDA[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing conda; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			# @todo figure out installed check
			args+=(
				'conda'
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'conda'
				'update'
			)
		else
			args+=(
				'conda'
				'install'
			)
		fi
		if test -n "$channel"; then
			args+=(
				'--channel'
				"$channel"
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# AUR, Arch Linux

	# To determine which aur handler to use
	# Search https://archlinux.org/packages/
	# If it appears, use AUR
	# If it does not appear, use PAMAC as it is a manjaro repo

	# aurutils / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	# https://github.com/AladW/aurutils
	function do_aurutils {
		local args=() packages=() package
		if test "${#AURUTILS[@]}" -ne 0; then
			packages+=("${AURUTILS[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing aurutils; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		else
			# install / upgrade
			args+=(
				'aurutils'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# pacman / Arch Linux / Manjaro
	function are_any_of_these_pacman_packages_installed {
		local package packages=("$@")
		# returns 1 if any are missing
		for package in "${packages[@]}"; do
			if pacman -Q "$package" &>/dev/null; then
				return 0
			fi
		done
		return 1
	}
	function do_pacman {
		local opts=() args=() packages=()
		if test "${#PACMAN[@]}" -ne 0; then
			packages=("${PACMAN[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pacman; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# --noconfirm
		#   Bypass any and all “Are you sure?” messages. It’s not a good idea to do this unless you want to run pacman from a script.

		# -q, --quiet
		#   Show less information for certain query operations.

		# -y, --refresh
		#   Download fresh package databases from the server. Use twice to force a refresh even if databases are up to date.

		# -S, --sync
		#   Synchronize packages. Packages are installed directly from the remote repositories, including all dependencies required to run the packages.

		# -R, --remove
		#   Either a URL or file path can be specified. This is a “remove-then-add” process.

		# --needed
		#   Do not reinstall the targets that are already up-to-date.

		#  -U, --upgrade
		#   Upgrade or add package(s) to the system and install the required dependencies from sync repositories.

		# init the local database
		eval_helper --quiet="$quiet" \
			-- sudo-helper -- pacman-key --init

		# opts
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi
		opts+=('--noconfirm')

		# refresh the local database
		eval_helper --quiet="$quiet" \
			-- sudo-helper -- pacman "${opts[@]}" --refresh --sync

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_pacman_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'pacman'
				'--remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'pacman'
				'--upgrade'
				'--needed'
			)
		else
			args+=(
				'pacman'
				'--sync'
				'--needed'
			)
		fi
		args+=("${opts[@]}")

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper -- "${args[@]}" "${packages[@]}"
	}

	# pakku / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	# https://github.com/kitsunyan/pakku
	function do_pakku {
		local args=() packages=() package
		if test "${#PAKKU[@]}" -ne 0; then
			packages+=("${PAKKU[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pakku; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		else
			# install / upgrade
			args+=(
				'pakku'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# pamac / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	# https://linuxcommandlibrary.com/man/pamac
	# sudo with pamac avoids gui sudo prompt
	function do_pamac {
		local args=() packages=()
		if test "${#PAMAC[@]}" -ne 0; then
			packages+=("${PAMAC[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pamac; then
			fallbacks+=('pamac')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pamac'
				'remove'
			)
		else
			# install / reinstall / upgrade
			if test "$force" = 'yes'; then
				args+=(
					'pamac'
					'reinstall'
				)
			else
				args+=(
					'pamac'
					'install'
				)
			fi

			# without [--no-upgrade] pamac upgrades everything on the system, which can be over 40GB on initial upgrades
			args+=('--no-upgrade')
		fi
		args+=('--no-confirm')

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper -- "${args[@]}" "${packages[@]}"
	}
	function do_pamac_fallback {
		if ! is-manjaro; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		setup-util-pamac
		do_pamac "$@"
	}

	# paru / AUR / Arch Linux
	# https://itsfoss.com/paru-aur-helper/
	# https://github.com/Morganamilo/paru
	function do_paru {
		local args=() packages=() package
		if test "${#PARU[@]}" -ne 0; then
			packages+=("${PARU[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing paru; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		elif test "$upgrade" = 'yes'; then
			args+=(
				'paru'
				'-Sua'
			)
		else
			args+=(
				'paru'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# yay / AUR / Arch Linux
	# https://github.com/Jguer/yay
	function do_yay {
		local args=() packages=() package
		if test "${#YAY[@]}" -ne 0; then
			packages+=("${YAY[@]}")
		elif test "${#AUR[@]}" -ne 0; then
			packages+=("${AUR[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing yay; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		else
			# install / upgrade
			args+=(
				'yay'
				'-Sy'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper -- "${args[@]}" "$package"
		done
	}

	# -------------------------------------
	# BSD / Solaris

	# `doas` is a `sudo` replacement for OpenBSD
	# https://www.openbsdhandbook.com/openbsd_for_linux_users/

	# pkg / FreeBSD / Termux
	# https://www.freebsd.org/cgi/man.cgi?query=pkg&sektion=&n=1
	# https://www.freebsd.org/cgi/man.cgi?query=pkg-install
	function do_pkg {
		local args=() packages=()
		if test "${#PKG[@]}" -ne 0; then
			packages+=("${PKG[@]}")
		elif test "${#BSD[@]}" -ne 0; then
			packages+=("${BSD[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pkg; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pkg'
				'autoremove'
				'--yes'
			)
		else
			# install / upgrade
			args+=(
				'pkg'
				'install'
				'--yes'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# pkgadd / pkg_add / OpenBSD
	# https://docs.oracle.com/cd/E19455-01/806-0625/6j9vfilsu/index.html
	function do_pkgadd {
		local packages=() package
		if test "${#PKGADD[@]}" -ne 0; then
			packages+=("${PKGADD[@]}")
		elif test "${#BSD[@]}" -ne 0; then
			packages+=("${BSD[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pkgadd; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- pkgadd "$package"
		done
	}

	# pkgin / NetBSD
	# successor to pkg_in, pkg_add
	# https://pkgin.net/
	function do_pkgin {
		local args=() packages=() package
		if test "${#PKGIN[@]}" -ne 0; then
			packages+=("${PKGIN[@]}")
		elif test "${#BSD[@]}" -ne 0; then
			packages+=("${BSD[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pkgin; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'pkgin'
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'pkgin'
				'upgrade'
			)
		else
			args+=(
				'pkgin'
				'install'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# -------------------------------------
	# Debian

	# apt / Ubuntu / Debian / Linux Mint / elementary OS / etc
	# installs remote .deb packages
	# sucessor to aptitude
	# https://wiki.debian.org/Apt
	function do_apt_key_fetch {
		local key="$1"
		if [[ $key == *'.asc' ]]; then
			# .asc files
			fetch "$key" | gpg --dearmor
		else
			# .key and unknown files
			fetch "$key"
		fi
	}
	function do_apt {
		local args=() packages=() repo="$APT_REPO" key="$APT_KEY" id="$APT_ID" keyring=''
		if test "${#APT[@]}" -ne 0; then
			packages+=("${APT[@]}")
		elif test "${#DEB[@]}" -ne 0; then
			packages+=("${DEB[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing apt-get; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# if APT_REPO or APT_KEY are used, then determine APT_ID automatically, and fail if it couldn't be determined
		if test -n "$repo" -o -n "$key"; then
			if test -z "$id"; then
				if test "${#packages[@]}" -gt 1; then
					cat <<-EOF >/dev/stderr
						$(echo-style --error="If APT has multiple packages, then APT_ID must be specified.")

						APT: ${packages[*]}
					EOF
					return 1
				else
					id="${packages[*]}" # needed for the rm commands
				fi
			fi
		fi

		# ensure key has repo correctly set
		if test -n "$key"; then
			if test -z "$repo"; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_KEY is set, APT_REPO must also be set.")

					APT: ${packages[*]}
				EOF
				return 1
			fi
			if [[ $repo != *'signed-by'* ]]; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_KEY is set, APT_REPO must contain:")
					$(echo-style --code="deb [signed-by={KEY}] https://...")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
				return 1
			fi
		fi

		# ensure repo is correct for non deb urls
		if test -n "$repo" && [[ $repo == 'deb '* ]]; then
			if [[ $repo != *'arch={ARCH}'* ]]; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_REPO is set, arch must be set to {ARCH}")
					$(echo-style --code="deb [arch={ARCH}] https://...")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
				return 1
			fi
			if test -n "$key" && [[ $repo != *'signed-by={KEY}'* ]]; then
				cat <<-EOF >/dev/stderr
					$(echo-style --error="If APT_REPO and APT_KEY is set, signed-by must be set to {KEY}")
					$(echo-style --code="deb [signed-by={KEY}] https://...")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
				return 1
			fi
			if [[ $repo == *'http:'* ]]; then
				# warn
				cat <<-EOF >/dev/stderr
					$(echo-style --notice="APT_REPO contained " --code="http:" --notice=" instead of " --code="https:" --notice=" this may be an oversight.")

					APT: ${packages[*]}
					APT_REPO: $repo
				EOF
			fi
		fi

		# prepare APT with APT_KEY
		if test -n "$key"; then
			# Deprecated technique is:
			# fetch ... | sudo-helper -- apt-key add -
			# Modern and working technique is what we do below...
			# which improves upon these incomplete and non-working suggestions:
			# https://blog.jak-linux.org/2021/06/20/migrating-away-apt-key/
			# https://packagecloud.io/blog/what-does-it-mean-to-add-a-repository-to-my-sources/#strongaddaptrepositorystrong
			# https://linuxize.com/post/how-to-add-apt-repository-in-ubuntu/
			# https://www.techrepublic.com/article/how-to-add-an-openpgp-repository-key-now-that-apt-key-is-deprecated/
			# https://stackoverflow.com/a/69015383/130638
			# https://askubuntu.com/a/1307181
			# https://askubuntu.com/a/1306494

			# prepare new location
			sudo-helper -- mkdir -p /usr/local/share/keyrings/
			keyring="/usr/local/share/keyrings/$id.gpg"

			# remove old keys if they exist
			sudo-helper -- rm -f /usr/local/share/keyrings/*"$id"* || :
			sudo-helper -- rm -f /etc/apt/trusted.gpg.d/*"$id"* || :

			# helper for quiet output
			function do_apt_key_add {
				# fetch and convert format, then import with export into correct format
				do_apt_key_fetch "$key" | sudo-helper -- gpg \
					--no-default-keyring \
					--keyring="gnupg-ring:$keyring" \
					--import # uses stdin
				# [gnupg-ring:] prefix creates keyring in apt compatible (legacy) v4 format

				# adjust permission to fix [_apt access error] on ubuntu 21.10
				sudo-helper -- chmod a+r "$keyring"
			}
			if test "$action" != 'uninstall'; then
				eval_helper --quiet="$quiet" \
					-- do_apt_key_add
			fi
		fi

		# prepare APT with APT_REPO
		if test -n "$repo"; then
			# remove old listings if they exist
			sudo-helper -- rm -f /etc/apt/sources.list.d/*"$id"* || :

			# add the repo with appropriate technique for the repo type
			if [[ $repo == 'deb '* ]]; then
				# adjust key modifier
				repo="${repo/"{KEY}"/"$keyring"}"

				# adjust arch modifier
				repo="${repo/"{ARCH}"/"$(
					dpkg --print-architecture
				)"}"

				# adjust release modifier
				repo="${repo/"{RELEASE}"/"$(
					lsb_release --codename --short
				)"}"

				# use a non-deprecated technique that supports the deb modifiers
				if test "$action" != 'uninstall'; then
					print_line "$repo" | sudo-helper -- tee "/etc/apt/sources.list.d/$id.list" >/dev/null
				fi
			else
				# @todo consider automatic rewrites to the above
				# ppa:transmissionbt/ppa =>
				# deb https://ppa.launchpadcontent.net/transmissionbt/ppa/ubuntu/ jammy main

				# [apt-add-repository --help] notes [sudo apt-add-repository -y "$repo"] is deprecated
				# however the alternative for `ppa:` and other syntax is too complicated
				if test "$action" != 'uninstall'; then
					eval_helper --quiet="$quiet" \
						-- sudo-helper \
						-- apt-add-repository -y --enable-source "$repo"
				fi
			fi

			# to debug:
			# sudo apt-add-repository --list
		fi

		# if we added a new repo or key, we need to refresh the apt references
		if test -n "$repo" -o -n "$key"; then
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- apt-get update -y
		fi

		# action args
		if test "$action" = 'uninstall'; then
			# don't use `apt remove --purge` as it is equivalent to `apt purge`
			# and purge removing python will also remove ufw and samba and a whole bunch of other things that depend on python
			# as such, only use `--auto-remove` as that is safer
			args+=(
				'apt-get'
				'remove'
				'-y'
				'--auto-remove'
			)
		else
			# install / upgrade
			args+=(
				'apt-get'
				'install'
				'-y'
				'--fix-broken'
			)
		fi

		# packages
		# use `apt-get`, as `apt` produces this warning on Ubuntu 20.04.3 LTS
		# WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# dpkg / Debian / Ubuntu / Linux Mint / elementary OS / etc
	# installs local .deb files, and with our helper, remote .deb files
	# https://man7.org/linux/man-pages/man1/dpkg.1.html
	function do_dpkg {
		local args=() packages=() i=0 path='' url=''
		if test "${#DPKG[@]}" -ne 0; then
			packages+=("${DPKG[@]}")
		elif test "${#DEB[@]}" -ne 0; then
			packages+=("${DEB[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing dpkg; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'dpkg'
				'--remove'
			)
		else
			# install / upgrade
			args+=(
				'dpkg'
				'--install'
			)
		fi

		# convert urls to local
		for i in "${!packages[@]}"; do
			url="${packages[i]}"
			if [[ $url == 'http'* ]]; then
				# fetch temp path
				path="$(fs-temp --touch --directory='setup-util' --file="$name.deb")"
				# download to temp path
				down --path="$path" "$url"
				# update packge with its download path
				packages[i]="$path"
			fi
		done

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Flatpak

	# flatpak / Arch Linux / Manjaro
	# https://manpages.org/flatpak-install
	# https://wiki.debian.org/FlatPak
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-install
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-remote-add
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-remote-delete
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-uninstall
	# https://docs.flatpak.org/en/latest/flatpak-command-reference.html#flatpak-update
	# sudo with flatpak avoids gui sudo prompt
	function do_flatpak {
		local args=() packages=() repos=() package repo
		if test "${#FLATPAK[@]}" -ne 0; then
			packages+=("${FLATPAK[@]}")
		fi
		if test "${#FLATPAK_REPO[@]}" -ne 0; then
			repos+=("${FLATPAK_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing flatpak; then
			fallbacks+=('flatpak')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# repos
		args=()
		if test "$action" = 'uninstall'; then
			args+=(
				'flatpak'
				'remote-delete'
			)
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
		else
			args+=(
				'flatpak'
				'remote-add'
				'--if-not-exists'
			)
		fi
		for repo in "${repos[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$repo"
		done

		# args
		args=()
		if test "$action" = 'uninstall'; then
			args+=(
				'flatpak'
				'uninstall'
			)
			if test "$force" = 'yes'; then
				args+=('--force-remove')
			fi
		else
			# install / upgrade
			args+=(
				'flatpak'
				'install'
				'--or-update'
			)
			if test "$force" = 'yes'; then
				args+=('--reinstall')
			fi
		fi
		args+=(
			'--assumeyes'
			'--noninteractive'
		)

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}
	function do_flatpak_fallback {
		setup-util-flatpak
		do_flatpak "$@"
	}

	# ---------------------------------
	# GNU Guix System

	# guix / GNU Guix
	# https://linuxcommandlibrary.com/man/guix-package
	function do_guix {
		local args=() packages=()
		if test "${#GUIX[@]}" -ne 0; then
			packages+=("${GUIX[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing guix; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'guix'
				'package'
				'--remove'
			)
		else
			# install / upgrade
			args+=(
				'guix'
				'package'
				'--install'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Golang

	# go
	# https://helpmanual.io/man1/go-install/
	function do_go {
		local args=() packages=() package i
		if test "${#GO[@]}" -ne 0; then
			packages+=("${GO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing go; then
			fallbacks+=('go')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# uninstall for go get, which is no longer relevant
		# as go install is now the way it is done
		# https://stackoverflow.com/a/67620609/130638
		# args+=('go' 'get')
		# for i in "${!packages[@]}"; do
		# 	package="${packages[i]}"
		# 	package="${package%%@*}" # trim version suffix
		# 	packages[i]="${package}@none"
		# done

		# args
		if test "$action" = 'uninstall'; then
			# go install installs a single binary file
			if test -n "$cli" -a -n "${GOPATH-}"; then
				if ! exists_helper "$GOPATH/bin/$cli"; then
					return 200 # ECUSTOM 200 Not applicable for this package system
				fi
				rm_helper "$GOPATH/bin/$cli"
				return
			else
				return 1 # unsupported, as the package is not a CLI
			fi
		else
			# install / upgrade
			# GO='github.com/rfjakob/gocryptfs'
			args+=(
				'go'
				'install'
				'-v'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			if [[ $package != *'@'* ]]; then
				# append version if not there
				package="${package}@latest"
			fi
			eval_helper --quiet="$quiet" \
				-- "${args[@]}" "$package"
			# ^ don't use sudo, not needed, and requires env vars to function
		done
	}
	function do_go_fallback {
		setup-go
		source "$DOROTHY/sources/environment.sh"
		do_go "$@"
	}

	# -------------------------------------
	# Haskell

	# cabal / Haskell
	# https://www.haskell.org/cabal/
	# https://hackage.haskell.org/package/cabal-install
	# https://cabal.readthedocs.io/en/stable/
	# https://cabal.readthedocs.io/en/stable/cabal-commands.html
	# https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-update
	# https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-install
	function do_cabal {
		local args=() packages=()
		if test "${#CABAL[@]}" -ne 0; then
			packages+=("${CABAL[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing cabal; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			return 1 # unsupported
		elif test "$upgrade" = 'yes'; then
			args+=(
				'conda'
				'update'
			)
		else
			args+=(
				'conda'
				'install'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# MacOS

	# brew / Homebrew / macOS
	function are_all_of_these_brew_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local packages=("$@")
		brew-installed --formula -- "${packages[@]}" &>/dev/null
	}
	function do_brew {
		local args=() opts=() packages=() taps=() tap
		if test "${#BREW[@]}" -ne 0; then
			packages+=("${BREW[@]}")
		fi
		if test "${#BREW_TAP[@]}" -ne 0; then
			taps+=("${BREW_TAP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if ! is-mac; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		if ! is-brew; then
			fallbacks+=('brew')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# opts
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# taps
		for tap in "${taps[@]}"; do
			eval_helper --quiet="$quiet" \
				-- brew tap "${opts[@]}" "$tap"
		done

		# args
		if test "$action" = 'uninstall'; then
			if ! are_all_of_these_brew_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable for this package system
			fi
			args+=(
				'brew'
				'uninstall'
			)
		else
			# install / upgrade
			args+=(
				'brew'
				'install'
			)
		fi
		if test "$force" = 'yes'; then
			args+=('--force')
		fi
		args+=("${opts[@]}")

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_brew_fallback {
		if ! is-mac; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		setup-mac-brew install # don't do --configure, as setup-util should be as automated as possible
		source "$DOROTHY/sources/environment.sh"
		do_brew "$@"
	}

	# brew / Homebrew Casks / macOS
	# some packages are available as both brew, and cask
	# ... so provide both independently as they are alternatives
	function are_all_of_these_cask_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local packages=("$@")
		brew-installed --cask -- "${packages[@]}" &>/dev/null
	}
	function do_cask {
		local args=() opts=() packages=() taps=() tap
		if test "${#CASK[@]}" -ne 0; then
			packages+=("${CASK[@]}")
		fi
		if test "${#CASK_TAP[@]}" -ne 0; then
			taps+=("${CASK_TAP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if ! is-mac; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		if ! is-brew; then
			fallbacks+=('cask')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# opts
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# taps
		for tap in "${taps[@]}"; do
			eval_helper --quiet="$quiet" \
				-- brew tap "${opts[@]}" "$tap"
		done

		# args
		if test "$action" = 'uninstall'; then
			if ! are_all_of_these_cask_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable for this package system
			fi
			args+=(
				'brew'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			# upgrade
			args+=(
				'brew'
				'reinstall'
			)
		else
			# install
			args+=(
				'brew'
				'install'
			)
		fi
		if test "$force" = 'yes'; then
			args+=('--force')
		fi
		args+=(
			'--cask'
			"${opts[@]}"
		)

		# packages
		eval_helper --quiet="$quiet" --shapeshifter -- \
			"${args[@]}" "${packages[@]}"
		# ^ --shapeshifter required as casks (not formulas) can require sudo
		# which will cause echo-revolving-door to behave oddly
		#
		# > brew uninstall --cask --quiet cloudflare-warp | echo-revolving-door
		# pp
		# Password:
		#
		# < 'brew' 'uninstall' '--cask' '--quiet' 'cloudflare-warp' >
		# pp
		# Password:
	}
	function do_cask_fallback {
		if ! is-mac; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		setup-mac-brew install # don't do --configure, as setup-util should be as automated as possible
		source "$DOROTHY/sources/environment.sh"
		do_cask "$@"
	}

	# mas / Mac App Store
	# https://github.com/mas-cli/mas/issues
	# only use sudo on uninstall
	function mas_search {
		local package="$1" exact=() options=() id name
		while read -r id name; do
			# trim version from the name, it doesn't work in the `read` arguments, as spaces inside name will be considered the version
			name="${name%%  *}"
			if test "$(lowercase_string "$name")" = "$(lowercase_string "$arg")"; then
				exact+=("$id" "$name")
			else
				options+=("$id" "$name")
			fi
			# ^ append the id and name (which are space and tab separated)
		done < <(mas search "$arg" | env TIMEOUT=0 echo-trim-each-line | sort --ignore-case -k 2)
		# ^ trim superflous padding that will cause confusion to IFS

		# ensure exact match is first
		options=("${exact[@]}" "${options[@]}")

		# return the selection
		choose-option \
			--question="Which Mac App Store app was intended for $package?" \
			--label -- "${options[@]}"
	}
	function do_mas {
		local args=() packages=() package
		if test "${#MAS[@]}" -ne 0; then
			packages+=("${MAS[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if ! is-mac; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		if command-missing mas; then
			fallbacks+=('mas')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# action args
		if test "$action" = 'uninstall'; then
			# currently broken
			# https://github.com/mas-cli/mas/issues/313
			return 1 # unsupported
			# args+=(
			# 	'sudo-helper'
			# 	'--inherit'
			# 	'--'
			# 	'mas'
			# 	'uninstall'
			# )
		else
			# install / upgrade
			args+=(
				'mas'
				'install'
			)
		fi

		# signin, signout, no longer supported
		# local signed_in='maybe'
		# function mas_signin {
		# 	local email
		# 	if test "$signed_in" = 'yes'; then
		# 		return 0
		# 	fi
		# 	email="$(
		# 		ask --required \
		# 			--question="The Mac App Store requires your email, enter it now."
		# 	)"
		# 	if is-value "$email"; then
		# 		# mas signout || :
		# 		mas signin --dialog "$email" || {
		# 			echo-style --notice="Failed to signin to the Mac App Store."
		# 			return 1
		# 		}
		# 		signed_in='yes'
		# 	else
		# 		signed_in='no'
		# 		return 1
		# 	fi
		# }
		# function mas_action {
		# 	eval_helper --quiet="$quiet" \
		# 		-- "${args[@]}" "${packages[@]}"
		# }
		# mas_action || {
		# 	mas_signin && mas_action
		# }

		# packages
		for package in "${packages[@]}"; do
			# convert labels into ids
			if ! is-number "$package"; then
				package="$(mas_search "$package")"
			fi

			# action
			eval_helper --quiet="$quiet" \
				-- "${args[@]}" "$package"
		done
	}
	function do_mas_fallback {
		if ! is-mac; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi
		setup-util-mas
		do_mas "$@"
	}

	# port / MacPorts
	# https://guide.macports.org/#using.port.install
	# https://guide.macports.org/#using.port.uninstall
	# https://guide.macports.org/#using.port.upgrade
	function do_port {
		local args=() packages=() package
		if test "${#PORT[@]}" -ne 0; then
			packages+=("${PORT[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing port; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'port'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'port'
				'upgrade'
			)
		else
			args+=(
				'port'
				'install'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# ---------------------------------
	# Nix

	# nix
	# https://www.mankier.com/1/nix-env
	# https://nixos.org/manual/nix/stable/command-ref/nix-env.html
	# https://search.nixos.org/packages
	function do_nix {
		local args=() packages=()
		if test "${#NIX[@]}" -ne 0; then
			packages+=("${NIX[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing nix-env; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'nix-env'
				'--uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'nix-env'
				'--upgrade'
			)
		else
			args+=(
				'nix-env'
				'--install'
				'--attr'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Node.js

	# npm / Node.js
	function are_any_of_these_npm_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local packages=("$@")
		# returns 1 only if all are missing, returns 0 if any are installed
		npm list --global --depth 0 "${packages[@]}" &>/dev/null
	}
	function do_npm {
		local args=() packages=()
		if test "${#NPM[@]}" -ne 0; then
			packages+=("${NPM[@]}")
		elif test "${#NODE[@]}" -ne 0; then
			packages+=("${NODE[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi

		# source nvm if it exists
		set +e # nvm prevents strict from working: .nvm/nvm.sh: line 1966: TMPDIR: unbound variable
		source "$DOROTHY/sources/nvm.sh"

		# checks
		if command-missing npm; then
			fallbacks+=('npm')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_npm_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'npm'
				'uninstall'
				'--global'
			)
		else
			# install / upgrade
			args+=(
				'npm'
				'install'
				'--global'
			)
		fi
		if test "$force" = 'yes'; then
			args+=('--force')
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_npm_fallback {
		setup-node
		source "$DOROTHY/sources/environment.sh"
		do_npm "$@"
	}

	# @todo add yarn
	# https://github.com/yarnpkg/yarn/issues/2993

	# -------------------------------------
	# Python

	# pip / Python
	# https://man.archlinux.org/man/extra/python-pip/pip.1.en
	function pip_helper { # 👍 /docs/bash/errors: robust exit status
		# Use the correct [pip] executable for the user's environment, as there may be many or multiple installed, such as one for Python v2 and one for Python v3.
		if command-exists pip; then
			pip "$@" || return
		elif python -m pip --version &>/dev/null; then
			python -m pip "$@" || return
		elif command-exists pip3; then
			pip3 "$@" || return
		elif python3 -m pip --version &>/dev/null; then
			python -m pip "$@" || return
		elif command-exists pip2; then
			pip2 "$@" || return
		elif python2 -m pip --version &>/dev/null; then
			python -m pip "$@" || return
		elif command-exists /usr/local/bin/pip; then
			/usr/local/bin/pip "$@"
		elif test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/pip"; then
			"${HOMEBREW_PREFIX}/bin/pip" "$@" || return
		else
			echo-style --error="[pip] nor its variations were found" >/dev/stderr
			return 1
		fi
	}
	function are_any_of_these_pip_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local packages=("$@")
		# returns 1 only if all are missing, returns 0 if any are installed
		pip_helper show -q "${packages[@]}" &>/dev/null
	}
	function do_pip {
		local args=() packages=() pip_status
		if test "${#PIP[@]}" -ne 0; then
			packages+=("${PIP[@]}")
		elif test "${#PYTHON[@]}" -ne 0; then
			packages+=("${PYTHON[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		eval_capture --statusvar=pip_status --no-output -- pip_helper --version
		if test "$pip_status" -ne 0; then
			fallbacks+=('pip')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_pip_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'pip_helper'
				'uninstall'
				'--yes'
			)
		else
			args+=(
				'pip_helper'
				'install'
				'--user'
				'--no-warn-script-location'
			)
			if test "$upgrade" = 'yes'; then
				args+=('--upgrade')
			fi
			if test "$force" = 'yes'; then
				args+=('--force-reinstall ')
			fi
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_pip_fallback {
		setup-python
		source "$DOROTHY/sources/environment.sh"
		do_pip "$@"
	}

	# pipx / Python
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_install'
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_upgrade'
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_uninstall'
	# https://www.mankier.com/1/pipx#COMMAND_'pipx_reinstall'
	function are_any_of_these_pipx_packages_installed {
		local package packages=("$@")
		for package in "${packages[@]}"; do
			# only supports one package at a time
			if pipx list --short | grep --quiet --fixed-strings --regexp="$package "; then
				return 0
			fi
		done
		return 1
	}
	function do_pipx {
		local args=() packages=()
		if test "${#PIPX[@]}" -ne 0; then
			packages+=("${PIPX[@]}")
		elif test "${#PYTHON[@]}" -ne 0; then
			packages+=("${PYTHON[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing pipx; then
			fallbacks+=('pipx')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_pipx_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'pipx'
				'uninstall-all'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'pipx'
				'upgrade-all'
			)
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
		else
			# if test "$force" = 'yes'; then
			#	args+=('reinstall')
			args+=(
				'pipx'
				'install-all'
			)
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}
	function do_pipx_fallback {
		if ! pip_helper --version &>/dev/null; then
			setup-python
		fi
		setup-util-pipx
		source "$DOROTHY/sources/environment.sh"
		do_pipx "$@"
	}

	# -------------------------------------
	# RPM

	# dnf / COPR / Fedora / CentOS / RHEL
	# installs RPM files and remote RPM packages
	# successor to yum (same api)
	# uses rpm behind the scenes
	# https://dnf.readthedocs.io/en/latest/command_ref.html
	# https://opensource.com/article/18/8/guide-yum-dnf
	# https://docs.fedoraproject.org/en-US/quick-docs/dnf/
	function do_dnf {
		local opts=() args=() packages=() groups=() copr=() repos=()
		if test "${#DNF[@]}" -ne 0; then
			packages+=("${DNF[@]}")
		elif test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi
		if test "${#DNF_GROUP[@]}" -ne 0; then
			groups+=("${DNF_GROUP[@]}")
		fi
		if test "${#DNF_COPR[@]}" -ne 0; then
			copr+=("${DNF_COPR[@]}")
		fi
		if test "${#DNF_REPO[@]}" -ne 0; then
			repos+=("${DNF_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0 -a "${#groups[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing dnf; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# opts
		opts+=(
			'-y'
			'--best'
			'--refresh'
		)
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# copr
		if test "${#copr[@]}" -ne 0; then
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- dnf "${opts[@]}" copr enable "${copr[@]}"
		fi

		# repos
		if test "${#repos[@]}" -ne 0; then
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- dnf "${opts[@]}" config-manager --add-repo "${repos[@]}"
		fi

		# groups
		if test "${#groups[@]}" -ne 0; then
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- dnf "${opts[@]}" groupinstall "${groups[@]}"
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'dnf'
				"${opts[@]}"
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'dnf'
				"${opts[@]}"
				'upgrade'
			)
		else
			args+=(
				'dnf'
				"${opts[@]}"
				'install'
			)
		fi

		# packages
		if test "${#packages[@]}" -ne 0; then
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "${packages[@]}"
		fi
	}

	# rpm / RedHat / Fedora / CentOS / etc
	# installs RPM files
	# does exist on OpenSUSE, even though yum and dnf do not
	function do_rpm {
		local args=() packages=() package
		if test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing rpm; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'rpm'
				'--erase'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'rpm'
				'--upgrade'
			)
		else
			args+=(
				'rpm'
				'--install'
			)
		fi
		if test "$quiet" != 'no'; then
			args+=('--quiet')
		fi

		# packages
		for package in "${packages[@]}"; do
			# verify it is a rpm file and was not inherted from DNF or YUM
			if test ! -f "$package"; then
				# it was not a file, so this is not a suitable combination
				return 1
			fi
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# urpmi / Mageia
	# installs RPMs
	# https://wiki.mageia.org/en/URPMI
	# https://wiki.mageia.org/en/URPMI#Basic_commands:_Install.2C_remove.2C_update
	function do_urpmi {
		local args=() packages=()
		if test "${#URPMI[@]}" -ne 0; then
			packages+=("${URPMI[@]}")
		elif test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing urpmi || command-missing urpme; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'urpme'
			)
		else
			# install / upgrade
			args+=(
				'urpmi'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# yum / rpm / RedHat / Fedora / CentOS / etc
	# installs RPM files and remote RPM packages
	# predecessor to dnf (same api)
	# uses rpm behind the scenes
	# https://man7.org/linux/man-pages/man8/yum.8.html#COMMANDS
	# autoremove                remove all unneeded packages that were originally installed as dependencies
	# check-update              check for available package upgrades
	# clean                     remove cached data
	# distro-sync               synchronize installed packages to the latest available versions
	# install                   install a package or packages on your system
	# reinstall                 reinstall a package
	# remove                    remove a package or packages from your system
	# upgrade                   upgrade a package or packages on your system
	# upgrade-minimal           upgrade, but only 'newest' package match which fixes a problem that affects your system
	# -b, --best                try the best available package versions in transactions.
	# -q, --quiet               quiet operation
	# -y, --assumeyes           automatically answer yes for all questions
	function do_yum {
		local opts=() args=() packages=() repos=() repo
		if test "${#YUM[@]}" -ne 0; then
			packages+=("${YUM[@]}")
		elif test "${#RPM[@]}" -ne 0; then
			packages+=("${RPM[@]}")
		fi
		if test "${#YUM_REPO[@]}" -ne 0; then
			repos+=("${YUM_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing yum; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# opts
		opts+=(
			'-y'
			'--best'
		)
		if test "$quiet" != 'no'; then
			opts+=('--quiet')
		fi

		# prepare YUM with YUM_REPO
		for repo in "${repos[@]}"; do
			eval_helper --quiet="$quiet" \
				-- down --directory='/etc/yum.repos.d/' "$repo"
		done

		if test "$action" = 'uninstall'; then
			args+=(
				'yum'
				"${opts[@]}"
				'remove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'yum'
				"${opts[@]}"
				'upgrade'
			)
		else
			args+=(
				'yum'
				"${opts[@]}"
				'install'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# zypper / openSUSE / SLES
	# installs RPM files and remote YaST2 and RPM packages
	# zypper needs sudo
	# https://www.mankier.com/8/zypper
	# https://www.mankier.com/8/zypper#Commands-Package_Management_Commands
	# https://en.opensuse.org/Portal:Zypper
	# https://documentation.suse.com/smart/linux/single-html/reference-zypper-install/index.html
	# https://en.opensuse.org/Snap
	function do_zypper {
		local opts=() args=() packages=() repo="$ZYPPER_REPO" alias="$ZYPPER_REPO_ALIAS"
		if test "${#ZYPPER[@]}" -ne 0; then
			packages+=("${ZYPPER[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing zypper; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# opts
		opts=(
			'--non-interactive'
			'--gpg-auto-import-keys'
		)

		# repos
		if test -n "$repo"; then
			if test -n "$alias"; then
				eval_helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					addrepo --refresh "$repo" "$alias"

				eval_helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					dist-upgrade --auto-agree-with-licenses --no-confirm --from "$alias"
			else
				eval_helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					addrepo --refresh "$repo"

				eval_helper --quiet="$quiet" \
					-- sudo-helper \
					-- zypper "${opts[@]}" \
					refresh
			fi
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'zypper'
				"${opts[@]}"
				'remove'
			)
		else
			# install / upgrade
			args+=(
				'zypper'
				"${opts[@]}"
				'install'
			)
		fi
		args+=('--no-confirm')

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Ruby

	# gem / Ruby
	# we use --user-install because of:
	# https://github.com/ffi/ffi/issues/631
	function are_any_of_these_gem_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local packages=("$@")
		for package in "${packages[@]}"; do
			# only supports one package at a time
			if test "$(gem list -i "$package" || :)" = 'true'; then
				return 0
			fi
		done
		return 1
	}
	function do_gem {
		local opts=() args=() packages=() package parts
		if test "${#GEM[@]}" -ne 0; then
			packages+=("${GEM[@]}")
		elif test "${#RUBY[@]}" -ne 0; then
			packages+=("${RUBY[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing gem; then
			fallbacks+=('gem')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_gem_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			for package in "${packages[@]}"; do
				# support multiple args inside RUBY, such as [--version ...]
				mapfile -t parts < <(echo-split ' ' -- "$package")
				eval_helper --quiet="$quiet" \
					-- gem uninstall -axI "${parts[0]}"
			done
		else
			# install / upgrade
			args+=(
				'gem'
				'install'
				"${opts[@]}"
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			# support multiple args inside RUBY, such as [--version ...]
			mapfile -t parts < <(echo-split ' ' -- "$package")
			eval_helper --quiet="$quiet" \
				-- "${args[@]}" "${parts[@]}"
		done
	}
	function do_gem_fallback {
		setup-ruby
		source "$DOROTHY/sources/environment.sh"
		do_gem "$@"
	}

	# -------------------------------------
	# Rust

	# cargo / Crates.io / Rust
	# https://manpages.debian.org/testing/cargo/cargo-install.1.en.html
	# https://manpages.debian.org/testing/cargo/cargo-uninstall.1.en.html
	function are_any_of_these_cargo_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local package packages=("$@")
		for package in "${packages[@]}"; do
			# only supports one package at a time
			if cargo install --list | grep --quiet --fixed-strings --regexp="$package v"; then
				return 0
			fi
		done
		return 1
	}
	function do_cargo {
		local args=() packages=() package
		if test "${#CARGO[@]}" -ne 0; then
			packages+=("${CARGO[@]}")
		elif test "${#RUST[@]}" -ne 0; then
			packages+=("${RUST[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing cargo; then
			fallbacks+=('cargo')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_cargo_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'cargo'
				'uninstall'
			)
		else
			# install / upgrade
			args+=(
				'cargo'
				'install'
			)
			if test "$force" != 'no'; then
				args+=('--force')
			fi
		fi
		if test "$quiet" != 'no'; then
			args+=('--quiet')
		fi

		# note cargo installs take a while on the raspberry pi
		if test "$action" = 'install' -a "$quiet" != 'yes'; then
			if is-raspi; then
				print_line '🚸 As you are on a low-powered device (Raspberry Pi), this may take longer than anticipated, and may appear as if the system has locked up. If you suspect this has occurred, then wait 10 minutes, if nothing occurs, then try holding [Fn OR Alt] + [SysReq] then [R then E then I then S then U then B] 🚸'
			fi
		fi

		# packages
		# support multiple args inside CARGO
		for package in "${packages[@]}"; do
			mapfile -t parts < <(echo-split ' ' -- "$package")
			if test "$action" = 'uninstall' -a "${parts[0]}" = '--git'; then
				parts=("$cli")
			fi
			eval_helper --quiet="$quiet" \
				-- "${args[@]}" "${parts[@]}"
		done
	}
	function do_cargo_fallback {
		setup-rust
		source "$DOROTHY/sources/environment.sh"
		do_cargo "$@"
	}

	# -------------------------------------
	# Snap

	# snap / Snap Craft / Ubuntu
	# needs sudo, otherwise: error: access denied (try with sudo)
	function are_any_of_these_snap_packages_installed { # 👍 /docs/bash/errors: robust exit status
		local packages=("$@")
		# returns 1 only if all are missing, returns 0 if any are installed
		snap list "${packages[@]}" &>/dev/null
	}
	function do_snap {
		local args=() packages=() channel="$SNAP_CHANNEL" package parts
		if test "${#SNAP[@]}" -ne 0; then
			packages+=("${SNAP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if ! is-snap; then
			fallbacks+=('snap')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi

		# action args
		if test "$action" = 'uninstall'; then
			if ! are_any_of_these_snap_packages_installed "${packages[@]}"; then
				return 200 # ECUSTOM 200 Not applicable to this uninstallation
			fi
			args+=(
				'snap'
				'remove'
			)
		else
			# install / upgrade
			args+=(
				'snap'
				'install'
			)
			if test -n "$channel"; then
				args+=("--channel=$channel")
			fi
		fi

		# packages
		# support multiple args inside SNAP
		for package in "${packages[@]}"; do
			mapfile -t parts < <(echo-split ' ' -- "$package")
			if test "$action" = 'uninstall'; then
				parts=("${parts[0]}") # if uninstalling, trim --classic
			fi
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "${parts[@]}"
		done

	}
	function do_snap_fallback {
		setup-util-snap
		do_snap "$@"
	}

	# -------------------------------------
	# Solus

	# eopkg / Solus
	# https://github.com/solus-project/package-management/blob/master/man/eopkg.1.md
	# @todo support repos
	function do_eopkg {
		local args=() packages=()
		if test "${#EOPKG[@]}" -ne 0; then
			packages+=("${EOPKG[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing eopkg; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'eopkg'
				'autoremove'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'eopkg'
				'upgrade'
			)
		else
			args+=(
				'eopkg'
				'install'
			)
		fi
		args+=('--yes-all')

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# ---------------------------------
	# Tea

	# note that tea doesn't provide man pages, even via [tea man bat]
	function remove_tea_cache {
		local package="$1" subpath path
		# this entire cache of the package must be removed, not just [tea -n "$cli"]
		# see https://discord.com/channels/906608167901876256/906608288026734622/1134327807544135770
		subpath="${package:1}" # get everything after the +
		path="$HOME/.tea/$subpath"
		print_line "$path"
		if test -d "$path"; then
			rm_helper "$path"
			return 0
		fi
		return 200 # ECUSTOM 200 Not applicable to this package system
	}
	function remove_tea_xdg_bin_alias {
		if test -L "$XDG_BIN_HOME/$cli"; then
			if test "$(fs-realpath -- "$XDG_BIN_HOME/$cli")" = "$(type -P tea)"; then
				rm_helper "$XDG_BIN_HOME/$cli"
				return 0 # is applicable
			fi
		fi
		return 200 # ECUSTOM 200 Not applicable to this package system
	}
	function remove_tea_package {
		local package="$1" ec1 ec2
		eval_capture --statusvar=ec1 -- remove_tea_xdg_bin_alias
		eval_capture --statusvar=ec2 -- remove_tea_cache "$package"
		if test "$ec1" -ne 0 -a "$ec1" -ne 200; then
			return "$ec1" # error
		elif test "$ec2" -ne 0 -a "$ec2" -ne 200; then
			return "$ec2" # error
		elif test "$ec1" -eq 0 || test "$ec2" -eq 0; then
			return 0 # was applicable
		else
			return 200 # ECUSTOM 200 Not applicable to this package system
		fi
	}
	function do_tea {
		local packages=()
		if test "${#TEA[@]}" -ne 0; then
			packages+=("${TEA[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if ! command-exists tea; then
			fallbacks+=('tea')
			return 200 # ECUSTOM 200 Not applicable yet but provided fallback
		fi
		if test -z "$cli"; then
			echo-style --error="TEA requires <cli>"
			return 22 # EINVAL 22 Invalid argument
		fi
		if test -z "$cli"; then
			echo-style --error="TEA requires <cli>"
			return 22 # EINVAL 22 Invalid argument
		fi

		# handle each package
		local repo tea_status result=200
		for package in "${packages[@]}"; do
			# check
			if [[ $package != '+'* ]]; then
				echo-style --error="TEA packages must begin with +" ', e.g. ' --code="--cli='jq' TEA='+stedolan.github.io/jq'"
				return 22 # EINVAL 22 Invalid argument
			fi

			# uninstall
			if test "$action" = 'uninstall'; then
				eval_capture --statusvar=tea_status -- remove_tea_package "$package"
				if test "$tea_status" -eq 0; then
					result=0
				fi
			else
				# install / upgrade
				result=0

				# install it by doing [tea $package --version]
				# it would be nice to use [command-working] however [command-working] currently expects multiple commands as arguments so it would become [command-working tea, command-working $package, command-working --version]
				eval_helper --quiet="$quiet" --shapeshifter \
					-- tea "$package" "$cli" --version

				# make tea alias available
				mkdir -p "$XDG_BIN_HOME"
				symlink-helper --quiet="$quiet" --existing="$(type -P tea)" --symlink="$XDG_BIN_HOME/$cli"
			fi
		done
		return "$result"
	}
	function do_tea_fallback {
		setup-util-tea
		source "$DOROTHY/sources/environment.sh"
		do_tea "$@"
	}

	# ---------------------------------
	# Void Linux

	# xbps / Void Linux
	# https://github.com/void-linux/xbps
	function do_xbps {
		local args=() packages=()
		if test "${#XBPS[@]}" -ne 0; then
			packages+=("${XBPS[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing xbps-remove || command-missing xbps-install; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'xbps-remove'
				'-R'
				'-O'
				'-o'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'xbps-install'
				'-u'
			)
		else
			args+=(
				'xbps-install'
				'--sync'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- sudo-helper \
			-- "${args[@]}" "${packages[@]}"
	}

	# -------------------------------------
	# Windows

	# choco / cinst / Chocolatey / Windows
	# https://docs.chocolatey.org/en-us/choco/setup
	# https://docs.chocolatey.org/en-us/choco/commands/
	# https://community.chocolatey.org/packages
	# https://docs.chocolatey.org/en-us/choco/commands/uninstall
	# https://docs.chocolatey.org/en-us/choco/commands/upgrade
	# https://docs.chocolatey.org/en-us/choco/commands/install
	function do_choco {
		local cmd args=() packages=()
		if test "${#CHOCO[@]}" -ne 0; then
			packages+=("${CHOCO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-exists choco; then
			cmd='choco'
		elif command-exists cinst; then
			cmd='cinst'
		else
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				"$cmd"
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				"$cmd"
				'upgrade'
			)
		else
			args+=(
				"$cmd"
				'install'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}

	# scoop / Windows
	# https://scoop.sh/
	# https://github.com/ScoopInstaller/Scoop/wiki/Commands
	# https://github.com/ScoopInstaller/Scoop/wiki/Example-Setup-Scripts
	function do_scoop {
		local args=() packages=()
		if test "${#SCOOP[@]}" -ne 0; then
			packages+=("${SCOOP[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing scoop; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'scoop'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'scoop'
				'update'
			)
		else
			args+=(
				'scoop'
				'install'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}

	# winget / Windows Package Manager Client
	# https://docs.microsoft.com/en-us/windows/package-manager/winget/
	# https://docs.microsoft.com/en-us/windows/package-manager/winget/install
	function do_winget {
		local args=() packages=()
		if test "${#WINGET[@]}" -ne 0; then
			packages+=("${WINGET[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing winget; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'winget'
				'uninstall'
			)
		elif test "$upgrade" = 'yes'; then
			args+=(
				'winget'
				'upgrade'
			)
		else
			args+=(
				'winget'
				'install'
			)
		fi

		# packages
		eval_helper --quiet="$quiet" \
			-- "${args[@]}" "${packages[@]}"
	}

	# emerge / Portage / GURU / Gentoo Linux
	# https://en.wikipedia.org/wiki/Gentoo_Linux
	# https://wiki.gentoo.org/wiki/Emerge
	# https://wiki.gentoo.org/wiki/Portage
	# https://wiki.gentoo.org/wiki/Gentoo_Cheat_Sheet#Package_installation
	# https://dev.gentoo.org/~zmedico/portage/doc/man/emerge.1.html
	# https://packages.gentoo.org/categories
	function do_emerge {
		local args=() packages=() repos=() package repo
		if test "${#EMERGE[@]}" -ne 0; then
			packages+=("${EMERGE[@]}")
		fi
		if test "${#EMERGE_REPO[@]}" -ne 0; then
			repos=("${EMERGE_REPO[@]}")
		fi

		# checks
		if test "${#packages[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if command-missing emerge || command-missing eselect; then
			return 200 # ECUSTOM 200 Not applicable for this package system
		fi

		# repos
		for repo in "${repos[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- eselect repository enable "$repo"
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- emerge --sync guru
		done

		# args
		if test "$action" = 'uninstall'; then
			args+=(
				'emerge'
				'--depclean'
			)
		else
			# install / upgrade
			args+=(
				'emerge'
			)
		fi

		# packages
		for package in "${packages[@]}"; do
			eval_helper --quiet="$quiet" \
				-- sudo-helper \
				-- "${args[@]}" "$package"
		done
	}

	# =====================================
	# Custom Installers

	# eval
	function do_eval {
		local scripts=() script
		if test "${#EVAL[@]}" -ne 0; then
			scripts+=("${EVAL[@]}")
		fi

		# checks
		if test "${#scripts[@]}" -eq 0; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi

		# action
		# eval_helper --quiet="$quiet" -- \
		# 	"${scripts[@]}"
		for script in "${scripts[@]}"; do
			("$script")
		done
	}

	# download
	function do_download {
		local bin_path download_path download="$DOWNLOAD" filename="$DOWNLOAD_FILENAME" unzip_format="$DOWNLOAD_UNZIP_FORMAT" unzip_filter="$DOWNLOAD_UNZIP_FILTER" build_eval="$DOWNLOAD_BUILD_EVAL" build_filter="$DOWNLOAD_BUILD_FILTER"

		# checks
		if test -z "$download"; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if test -z "$filename"; then
			filename="$cli"
			if test -z "$filename"; then
				echo-style --error="DOWNLOAD requires DOWNLOAD_FILENAME or <cli>"
				return 22 # EINVAL 22 Invalid argument
			fi
		fi
		if test -n "$build_eval" -a -z "$build_filter"; then
			build_filter="$filename"
		fi

		# determine path
		bin_path="$(get_path_from_filename "$filename")"
		if test -n "$build_eval"; then
			download_path="$(
				fs-temp \
					--directory='setup-util' \
					--directory
			)"
		else
			download_path="$bin_path"
		fi
		# uninstall?
		if test "$action" = 'uninstall'; then
			# -e instead of -f, as .app is a directory
			if test ! -e "$bin_path" -o -L "$bin_path"; then
				return 200 # ECUSTOM 200 Not applicable for this package system
			fi
			rm_helper "$bin_path"
			return 0
		fi

		# download
		down "$download" \
			--quiet="$quiet" \
			--unzip-format="$unzip_format" \
			--unzip-filter="$unzip_filter" \
			--path="$download_path"

		# build
		if test -n "$build_eval"; then
			(
				cd "$download_path"
				eval_helper --quiet --no-wrap \
					--pending="$(echo-style --bold="Building...")" \
					--success="$(echo-style --success="Built.")" \
					--failure="$(echo-style --error="Failed to build.")" \
					-- "$build_eval"
			)
			if test -n "$build_filter"; then
				# match extracted paths against filter
				local filtered_paths=() filtered_path
				mapfile -t filtered_paths < <(
					expand-path "$download_path/$build_filter"
				)
				if test "${#filtered_paths[@]}" -eq 0; then
					echo-error "$0: No files matched the build filter extracted."
					return 1
				elif test "${#filtered_paths[@]}" -eq 1; then
					# move the single file
					for filtered_path in "${filtered_paths[@]}"; do
						mv -fv "$filtered_path" "$bin_path"
					done
				else
					echo-error "$0: Multiple files matched the build filter."
					return 1
				fi
			fi
		fi

		# verify
		verify_saved_path "$bin_path"
	}

	# installer
	function do_installer {
		local args=() file file_or_url="$INSTALLER" filename="$INSTALLER_FILENAME" __open="$INSTALLER_OPEN"

		# checks
		if test -z "$file_or_url"; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if test "$action" = 'uninstall'; then
			return 200 # ECUSTOM 200 Not applicable to this utility
		fi
		if [[ $file_or_url == *'/setup-util-'* ]]; then
			echo-error "Using INSTALLER=setup-util-* is deprecated, use an alternative: $name"
			return 43 # EPROTONOSUPPORT 43 Protocol not supported
		fi

		# optional filename
		if test -z "$filename"; then
			# include extension
			filename="$(basename "$file_or_url")"
		fi

		# check if it is local, or remote
		if test -e "$file_or_url"; then
			file="$file_or_url"
		else
			# it is remote
			# download it to a temporary location and use that
			file="$(
				fs-temp \
					--directory='setup-util' \
					--directory="$name" \
					--file="$filename"
			)"
			down "$file_or_url" --path="$file"
		fi

		# ensure it is executable, then open or run it
		chmod +x "$file"
		if test "$__open" = 'yes'; then
			open "$file"
		else
			# external installer script
			eval_helper --quiet="$quiet" \
				-- "$file"
		fi
	}

	# =====================================
	# Action

	# None of these exit codes were suitable:
	# ENOENT 2 No such file or directory
	# ESRCH 3 No such process
	# ENODEV 19 Operation not supported by device
	# ENOPROTOOPT 42 Protocol not available
	# EPROTONOSUPPORT 43 Protocol not supported
	# ESOCKTNOSUPPORT 44 Socket type not supported
	# ENOTSUP 45 Operation not supported
	#
	# So we're using our own, note that return codes can't go higher than 232
	# 200 = not applicable ...

	local installer had_success='no' had_failure='no' had_break='no' action_log
	if test "$action" = 'uninstall'; then
		action_log='uninstalled'
	elif test "$upgrade" = 'yes'; then
		action_log='upgraded'
	else
		action_log='installed'
	fi
	function log_success {
		local suffix='' method="${1-}"
		if test -n "$method"; then
			suffix+=" via [$method]"
		else
			suffix+='. ✅'
		fi
		maybe_echo_style --g3="The [$name] utility was ${action_log}${suffix}"
	}
	function log_failure {
		local suffix='' method="${1-}"
		if test -n "$method"; then
			suffix+=" via [$method]"
		elif test "$optional" = 'yes'; then
			suffix='. ⚠️'
		else
			suffix='. ❌'
		fi
		if test "$optional" = 'yes'; then
			maybe_echo_style --n3="The [$name] optional utility was not ${action_log}${suffix}"
		else
			echo-style --e3="The [$name] required utility was not ${action_log}${suffix}"
		fi
		return 0
	}
	function run {
		# install/upgrade until successful, uninstall for all
		local run_status method="$1" fn="$2"
		eval_capture --statusvar=run_status -- "$fn"
		if test "$run_status" -eq 0; then
			had_success='yes'
			log_success "$method"
			if test "$action" != 'uninstall'; then
				had_break='yes'
			fi
		elif test "$run_status" -ne 200; then
			log_failure "$method"
			if test "$action" = 'uninstall'; then
				had_failure='yes' # an uninstall failed
			fi
		fi
	}
	# cycle through the installers according to the order
	for installer in "${order[@]}"; do
		# sanity check
		if test -z "$installer"; then
			echo-style --error="an empty order argument was provided"
			echo-verbose "${order[@]}"
			return 22 # EINVAL 22 Invalid argument
		fi
		run "$installer" "do_$installer"
		if test "$had_break" = 'yes'; then
			break
		fi
	done
	# fallback for failed packages which are missing their package system
	if test "$fallback" = 'yes'; then
		if test "${#fallbacks[@]}" -ne 0; then
			for installer in "${fallbacks[@]}"; do
				run "$installer" "do_$installer"
				if test "$had_break" = 'yes'; then
					break
				fi
			done
		fi
	fi
	# determine failure
	if test "$action" = 'uninstall'; then
		# @todo detect if cli is still present, if so, perhaps prompt the user what to do
		if test "$had_failure" = 'no'; then
			log_success
		else
			# still some that aren't uninstalled
			log_failure
			if test "$optional" != 'yes'; then
				return 1
			fi
		fi
	elif test "$had_success" = 'yes'; then
		# at least one installed
		log_success
	else
		log_failure
		if test "$optional" != 'yes'; then
			return 1
		fi
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup_util "$@"
fi
