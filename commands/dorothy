#!/usr/bin/env bash

# NOTE:
# Help handling is implemented, however it is done specially, due to the following considerations.
# This script may be run directly, eval'd, or even sourced
# DOROTHY may or may not even exist yet
# Dorothy clone may or may not exist yet
# Bash v4 is not guaranteed
#
# Once dorothy is asserted to exist, we want to load environment, such that:
# Environment configuration wouldn't have loaded if:
#   in trial mode,
#   or invoked by a shell that was not yet configured for Dorothy.
# Environment configuration includes:
#   homebrew path, homebrew architecture, ecosystem paths, etc.
# Environment configuration is necessary so that:
#   dependencies can be detected and installed, such as sd for config-helper
#   test dependencies can correctly infer their environment's capabilities

# @TODOS:
# https://github.com/bevry/dorothy/issues/93
# Is `function name(){}` syntax suitable, or must it be `name(){}`` which is more portable?

# elif is bash, we are in sh
# >/dev/null 2>&1 works in all shells, use that
# source is bash, we are in sh

# =====================================
# Command

function dorothy() (
	# sensible defaults from [bash.bash]
	shopt -u progcomp
	shopt -s huponexit
	set +T
	shopt -s lastpipe 2>/dev/null || :
	set -Eeuo pipefail
	shopt -s inherit_errexit 2>/dev/null || :
	trap 'EXIT_STATUS=$?; if test "${FUNCNAME-}" = 'eval_capture_wrapper'; then return 0; elif test -n "${FUNCNAME-}"; then return "$EXIT_STATUS"; else exit "$EXIT_STATUS"; fi' ERR
	shopt -u failglob
	shopt -s nullglob

	# =====================================
	# Environment

	# vars that should be exported to subshells, which may or may not be inherited
	local self
	export DOROTHY DOROTHY_XDG XDG_DATA_HOME XDG_CONFIG_HOME ZDOTDIR PATH
	if test -z "${DOROTHY-}"; then
		# handle cron situation (dorothy is installed, however environment is empty)
		# `env -i "$(which dorothy)" run env` <-- whoami returns user who has dorothy installed:
		# `sudo env -i "$(which dorothy)" run env` <-- whoami returns root, who does not have dorothy installed
		# @todo consider if this runs on zsh and bash v3
		self="${BASH_SOURCE:-"$0"}"
		if [[ $self == *'.local/share/dorothy/commands/dorothy' ]] && test -f "$self"; then
			DOROTHY="${self%/commands/dorothy*}"
			if test -z "${HOME-}"; then
				export HOME
				HOME="${self%/.local/share/dorothy/commands/dorothy*}"
			fi
			if test -z "${USER-}"; then
				export USER
				USER="$(basename "$HOME")"
			fi
			if test -n "${CRON-}" -o -n "${CRONITOR_EXEC-}"; then
				# disable colour, different lines of bash v3 compat
				export COLOR
				COLOR=false
			fi
		else
			# handle fresh install situation
			DOROTHY=''
		fi
	fi
	if test -z "${DOROTHY_XDG-}"; then
		DOROTHY_XDG=''
	fi
	if test -z "${XDG_DATA_HOME-}"; then
		XDG_DATA_HOME="$HOME/.local/share"
	fi
	if test -z "${XDG_CONFIG_HOME-}"; then
		XDG_CONFIG_HOME="$HOME/.config"
	fi
	if test -z "${ZDOTDIR-}"; then
		ZDOTDIR=''
	fi
	mkdir -p "$XDG_DATA_HOME" "$XDG_CONFIG_HOME"

	# =====================================
	# Variables

	# vars that are local to this script and shared between functions
	local dorothy_url="https://github.com/bevry/dorothy"

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helpers for interacting with the Dorothy dotfile ecosystem.

			USAGE:

			dorothy install [--[no-]xdg]

			    Installs Dorothy interactively, with configuration for dotfile modifications.
			    If you are a poweruser and wish to override XDG autodetection to either enforce XDG compliance or non-compliance then provide [--xdg] or [--no-xdg] respectively.

			dorothy uninstall

			    Removes the Dorothy sourcing from your dotfile configuration files.

			dorothy trial
			    [--shell=<shell>]

			    Invoke [dorothy shell] with the trial theme.

			dorothy shell
			    [--shell=<shell>]
			    [--theme=<theme>]

			    Invoke an interactive shell that has Dorothy Available, without the need to install Dorothy to access its commands.
			    If a shell is provided, invoke dorothy within that shell, otherwise invoke dorothy within bash.

			dorothy run
				-- <command> [...]

				Invoke the <command> within the Dorothy environment, without the need to isntall Dorothy to access the command.

			dorothy update

			    Updates Dorothy to the latest version.

			dorothy permissions

			    Correct permissions of new Dorothy commands, ensuring they are executable, and that git is aware of them.

			dorothy edit

			    Correct permissions, then open Dorothy's installation and user configuration in your desired editor.

			dorothy review

			    Correct permissions, then open Dorothy's installation and user configuration in your desired git reviewer.

			dorothy theme

			    Interactively configure your desired theme for Dorothy configured shells.

			dorothy dev

			    Automatically install Dorothy' development dependencies.

			dorothy format

			    Automatically format Dorothy's source code to its conventions.

			dorothy check

			    Automatically check Dorothy's source code to its conventions.

			dorothy lint

			    Automatically format and check Dorothy's source code to its conventions.

			dorothy test

			    Run tests on Dorothy's source code.

		EOF
		if test "$#" -ne 0; then
			# don't use anything fancy here, as dorothy may not be loaded yet
			echo "ERROR:" >/dev/stderr
			echo "$@" >/dev/stderr
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process action arguments
	# @todo prevent double-action overwrite
	local item action='' args=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--xdg') DOROTHY_XDG='yes' ;;
		'--no-xdg') DOROTHY_XDG='no' ;;
		'trial')
			action='trial'
			args+=("$@")
			shift $#
			;;
		'shell')
			action='shell'
			args+=("$@")
			shift $#
			;;
		'run')
			action='run'
			args+=("$@")
			shift $#
			;;
		'i' | 'install')
			action='install'
			;;
		'u' | 'up' | 'update')
			action='update'
			;;
		'p' | 'perm' | 'perms' | 'permissions')
			action='permissions'
			;;
		'e' | 'edit')
			action='edit'
			args+=("$@")
			shift $#
			;;
		'r' | 'review')
			action='review'
			;;
		'theme')
			action='theme'
			;;
		'd' | 'dev')
			action='dev'
			;;
		'f' | 'format')
			action='format'
			;;
		'c' | 'check')
			action='check'
			;;
		'l' | 'lint')
			action='lint'
			;;
		't' | 'test')
			action='test'
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# =====================================
	# Helpers

	# see commands/command-exists for details
	function command_exists { # üëç /docs/bash/errors: robust exit status
		local command commands=("$@")
		for command in "${commands[@]}"; do
			if type -P "$command" &>/dev/null; then
				continue
			else
				return 1 # command missing
			fi
		done
		return 0 # all commands are present
	}

	# see commands/command-missing for details
	function command_missing { # üëç /docs/bash/errors: robust exit status
		local command commands=("$@")
		for command in "${commands[@]}"; do
			if type -P "$command" &>/dev/null; then
				continue
			else
				return 0 # command missing
			fi
		done
		return 1 # all commands are present
	}

	# see commands/sudo-helper for details
	function try_sudo { # üëç /docs/bash/errors: robust exit status
		if command_exists sudo; then
			# check if password is required
			if sudo --validate --non-interactive &>/dev/null; then
				# session still active, password not required
				sudo "$@" || return
			else
				# password is required, let the user know what they are being prompted for
				echo 'Your sudo/root/login password is required to execute the command:'
				echo "sudo $*"
				sudo "$@" || return
			fi
		elif command_exists doas; then
			set -x # <inform the user of why they are being prompted for a doas password>
			doas "$@" || return
			set +x # </inform>
		else
			"$@" || return
		fi
	}

	# see commands/is-mac for details
	function is_mac() { # üëç /docs/bash/errors: robust exit status
		test "$(uname -s)" = "Darwin"
	}

	function ensure_prereq_dependencies {
		# dorothy has yet to be installed
		if command_missing bash curl grep git tput; then
			if command_exists apt-get; then
				# for ubuntu
				try_sudo apt-get update
				try_sudo apt-get install -y bash curl git
			elif command_exists apk; then
				# for alpine
				try_sudo apk add bash curl grep git ncurses
			elif command_exists zypper; then
				# for opensuse
				try_sudo zypper install -y --no-recommends bash curl git-core
			elif command_exists pamac; then
				# for manjaro
				try_sudo pamac install --no-confirm bash curl git
			elif command_exists pacman; then
				# for arch besides manjaro
				try_sudo pacman -S --needed --noconfirm bash curl git ncurses
			elif command_exists yum; then
				# for fedora
				try_sudo yum install -y bash curl git ncurses
			elif test -x "${HOMEBREW_PREFIX-}/bin/brew"; then
				# for macos, don't use command_exists as dorothy has its own brew helper
				"${HOMEBREW_PREFIX-}/bin/brew" install bash curl git ncurses
			else
				# for everything else
				cat <<-EOF >/dev/stderr
					One of these installation dependencies are missing:
					bash:  $(bash --version | head -1 || :)
					curl:  $(curl --version | head -1 || :)
					grep:  $(grep --version | head -1 || :)
					git:   $(git --version | head -1 || :)

					Refer to the manual: https://github.com/bevry/dorothy
				EOF
				return 19 # ENODEV 19 Operation not supported by device
			fi
		fi
	}

	function ensure_minimal_dependencies {
		# dorothy is now installed
		if is_mac; then
			setup-util-xcode --quiet
		fi

		# [github-download] requires [jq]
		# [set-hostname] requires [sd]
		# [config-helper] requires [rg], [sd], [teip]
		if command_missing jq rg sd sd teip; then
			echo-segment --h2="Install required dependencies"
			if command_exists apt-get; then
				try_sudo apt-get update
			fi
			setup-util-jq --quiet
			setup-util-ripgrep --quiet
			setup-util-sd --quiet
			setup-util-teip --quiet
			setup-util-bash --quiet # install last (as depends on above)
			echo-segment --g2="Install required dependencies"
		elif is_mac; then
			setup-util-bash --quiet
		fi

		# make sure our path can detect them
		source "$DOROTHY/sources/environment.sh"
	}

	function ensure_development_dependencies {
		echo-segment --h2="Install development dependencies"
		setup-util-bash --quiet "$@"
		setup-util-prettier --quiet "$@"
		setup-util-ripgrep --quiet "$@"
		setup-util-shellcheck --quiet "$@"
		setup-util-shfmt --quiet "$@"
		setup-util-trunk --quiet "$@" # upgrades trunk
		echo-segment --g2="Install development dependencies"

		# make sure our path can detect them
		source "$DOROTHY/sources/environment.sh"
	}

	function require_globstar {
		# can't source things, as may not be cloned yet
		shopt -s globstar || {
			echo "Missing globstar support." >/dev/stderr
			return 1
		}
	}

	function assert_dorothy_configured {
		# DOROTHY is determined earlier, so this checks it is installed
		if test ! -d "$DOROTHY"; then
			echo-style \
				--error="Dorothy is not installed." $'\n' \
				"Nothing was found at: " --code="$DOROTHY" $'\n' \
				--warning="Run" --code=" dorothy install " --warning="to install, then you can run" --code=" dorothy $action"
			return 2 # ENOENT 2 No such file or directory
		fi
		source "$DOROTHY/sources/environment.sh"
	}

	function assert_user_cloned {
		if test ! -d "$DOROTHY/user/commands.local" -o ! -d "$DOROTHY/user/commands" -o ! -d "$DOROTHY/user/config.local" -o ! -d "$DOROTHY/user/config"; then
			echo-style \
				--error="Dorothy user configuration is not configured correctly." $'\n' \
				--warning="Run" --code=" dorothy install " --warning="to install, then you can run" --code=" dorothy $action"
			return 2 # ENOENT 2 No such file or directory
		fi
	}

	function assert_dorothy_and_user_cloned {
		assert_dorothy_configured
		assert_user_cloned
	}

	function git_init {
		local path="$1"
		mkdir -p "$path"
		pushd "$path" >/dev/null
		git init
		popd >/dev/null
	}

	function rm_deprecated {
		if test -f "$1"; then
			echo ''
			echo-file "$1"
			if confirm --positive --ppid=$$ -- 'The above file is probably deprecated with Dorothy, would you like to replace it?'; then
				rm "$1"
			fi
		fi
	}

	function make_executable {
		# makes sure chmod isn't running on nothing, which can happen upon initial user installs
		if test "$#" -ne 0; then
			chmod -f +x "$@"
		fi
	}

	function relocate_if_necessary {
		local __source="$1" destination="$2"
		# ensure source exists, and isn't the same as the destination
		if test -e "$__source"; then
			# ensure we aren't moving to the same location, especially with handling for symlinks, prevents:
			# mv: /Users/redacted/.local/share/dorothy/user and /Users/redacted/.config/dorothy/user are identical
			# don't risk calling fs-realpath which won't exist on fresh installs, if not needed
			if test -L "$__source"; then
				__source="$(fs-realpath -- "$__source")"
			fi
			if test -L "$destination"; then
				destination="$(fs-realpath -- "$destination")"
			fi
			if test "$__source" != "$destination"; then
				mv -vf "$__source" "$destination"
			fi
		fi
	}

	function relocate_dorothy_if_necessary {
		# move if necessary
		if test -d "$DOROTHY" -o -d "$XDG_DATA_HOME/dorothy"; then
			if test "$DOROTHY_XDG" = 'yes'; then
				relocate_if_necessary "$DOROTHY" "$XDG_DATA_HOME/dorothy"
			elif test "$DOROTHY_XDG" = 'no'; then
				relocate_if_necessary "$XDG_DATA_HOME/dorothy" "$DOROTHY"
				relocate_if_necessary "$HOME/.local/share/dorothy" "$DOROTHY"
			else
				# invalid DOROTHY_XDG value
				return 76 # EPROCUNAVAIL 76 Bad procedure for program
			fi

			# ensure correct permissions
			make_executable "$DOROTHY/commands/"*
		fi # else fresh install and no prior clones exist
	}

	function relocate_user_if_necessary {
		# move if necessary
		if test -d "$DOROTHY/user" -o -d "$XDG_CONFIG_HOME/dorothy"; then
			if test "$DOROTHY_XDG" = 'yes'; then
				relocate_if_necessary "$DOROTHY/user" "$XDG_CONFIG_HOME/dorothy"
				# ensure $DOROTHY/user always exists
				symlink-helper --quiet --existing="$XDG_CONFIG_HOME/dorothy" --symlink="$DOROTHY/user"
			elif test "$DOROTHY_XDG" = 'no'; then
				relocate_if_necessary "$XDG_CONFIG_HOME/dorothy" "$DOROTHY/user"
				relocate_if_necessary "$HOME/.config/dorothy" "$DOROTHY/user"
			else
				# invalid DOROTHY_XDG value
				return 76 # EPROCUNAVAIL 76 Bad procedure for program
			fi

			# ensure correct permissions
			if test -d "$DOROTHY/user/commands"; then
				make_executable "$DOROTHY/user/commands/"*
			fi
			if test -d "$DOROTHY/user/commands.local"; then
				make_executable "$DOROTHY/user/commands.local/"*
			fi
		fi # else fresh install and no prior clones exist
	}

	function relocate_zsh_if_necessary {
		# https://zsh.sourceforge.io/Intro/intro_3.html
		# determine ZDOTDIR
		if test "$DOROTHY_XDG" = 'yes'; then
			if test -z "$ZDOTDIR"; then
				ZDOTDIR="$XDG_CONFIG_HOME/zsh"
			fi
		elif test "$DOROTHY_XDG" = 'no'; then
			if test -z "$ZDOTDIR"; then
				ZDOTDIR="$HOME"
			fi
		else
			# invalid DOROTHY_XDG value
			return 76 # EPROCUNAVAIL 76 Bad procedure for program
		fi
		# move config files
		# zshenv needs to be in $HOME - all other goes in ZDOT.
		mkdir -p "$ZDOTDIR" # required for opensuse
		relocate_if_necessary "$ZDOTDIR/.zshenv" "$HOME/.zshenv"
		relocate_if_necessary "$HOME/.zprofile" "$ZDOTDIR/.zprofile"
		relocate_if_necessary "$HOME/.zshrc" "$ZDOTDIR/.zshrc"
		relocate_if_necessary "$HOME/.zlogin" "$ZDOTDIR/.zlogin"
		relocate_if_necessary "$HOME/.zlogout" "$ZDOTDIR/.zlogout"
	}

	function prepare_dorothy {
		# if DOROTHY or DOROTHY_XDG exist already, it is via env overrides

		# if no DOROTHY env override, attempt DOROTHY from possible existing installations
		if test -z "$DOROTHY"; then
			if test -d "$XDG_DATA_HOME/dorothy"; then
				DOROTHY="$XDG_DATA_HOME/dorothy"
			elif test -d "$HOME/.local/share/dorothy"; then
				DOROTHY="$HOME/.local/share/dorothy"
			elif test -d "$HOME/.dorothy"; then
				DOROTHY="$HOME/.dorothy"
			elif test -x ./commands/dorothy; then
				DOROTHY="$(pwd)" # GitHub Actions
			fi
		fi

		# if no DOROTHY_XDG env override, enforce DOROTHY_XDG from DOROTHY
		if test -z "$DOROTHY_XDG"; then
			if test -n "$DOROTHY"; then
				if test "$DOROTHY" = "$XDG_DATA_HOME/dorothy"; then
					DOROTHY_XDG='yes'
				else
					DOROTHY_XDG='no'
				fi
			elif test -d "$XDG_DATA_HOME"; then
				DOROTHY_XDG='yes'
			else
				DOROTHY_XDG='no'
			fi
		fi

		# if DOROTHY is still not defined, then there is no env override, and no existing installation
		# so enforce DOROTHY based on DOROTHY_XDG determination
		if test -z "$DOROTHY"; then
			if test "$DOROTHY_XDG" = 'yes'; then
				DOROTHY="$XDG_DATA_HOME/dorothy"
			else
				DOROTHY="$HOME/.dorothy"
			fi
		fi

		# adjust path for determined (including user defined) DOROTHY, as well as standard DOROTHY XDG location (in case user ever changes DOROTHY location)
		PATH="$DOROTHY/user/commands:$XDG_CONFIG_HOME/dorothy/commands:$DOROTHY/commands:$XDG_CONFIG_HOME/dorothy/commands:$PATH"

		# ensure DOROTHY is in correct location
		relocate_dorothy_if_necessary

		# ensure user configuration is in correct location
		relocate_user_if_necessary

		# ensure shell config files are in correct location
		relocate_zsh_if_necessary
		# fish uses xdg by default
		# bash does not support xdg
	}

	function stage_new_files {
		require_globstar
		local path="$1"
		pushd "$path" >/dev/null
		# The following paths are ignored by one of your .gitignore files: ...
		# hint: Use -f if you really want to add them.
		# hint: Turn this message off by running
		# hint: "git config advice.addIgnoredFile false"
		git add --ignore-errors ./** || :
		popd >/dev/null
	}

	function stage_changed_files {
		local path="$1"
		pushd "$path" >/dev/null
		git add -u || :
		popd >/dev/null
	}

	function correct_permissions {
		# directories and commands must be executable
		require_array 'mapfile'
		local directories commands
		commands=(
			"$DOROTHY/commands/"*
			"$DOROTHY/user/commands/"*
			"$DOROTHY/user/commands.local/"*
		)
		mapfile -t directories < <(find-directories "$DOROTHY")
		fs-own --changes --no-recursive --permissions='+rwx' \
			-- "${directories[@]}" "${commands[@]}"
	}

	function ensure_permissions_configured {
		source "$(command -v eval-helper)"

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold="Correcting permissions...")" \
			--success="$(echo-style --success="Corrected permissions.")" \
			--failure="$(echo-style --error="Failed to correct permissions.")" \
			-- correct_permissions

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold="Staging new files...")" \
			--success="$(echo-style --success="Staged new files.")" \
			--failure="$(echo-style --error="Failed to stage new files.")" \
			-- stage_new_files "$DOROTHY"

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold="Staging changed files...")" \
			--success="$(echo-style --success="Staged changed files.")" \
			--failure="$(echo-style --error="Failed to stage changed files.")" \
			-- stage_changed_files "$DOROTHY"

		eval_helper --quiet --no-wrap \
			--pending="$(echo-style --bold="Removing junk files...")" \
			--success="$(echo-style --success="Removed junk files.")" \
			--failure="$(echo-style --error="Failed to remove junk files.")" \
			-- rm-junk "$DOROTHY"
	}

	function ensure_dorothy_configured {
		# sanity check
		if ! [[ $action =~ install|update|trial|shell|run ]]; then
			return 29 # ESPIPE 29 Illegal seek
		fi

		# helpers
		function install_dorothy {
			echo "Installing Dorothy into $DOROTHY"
			git clone "https://github.com/bevry/dorothy.git" "$DOROTHY"
		}
		function update_dorothy {
			echo-segment --h2="Updating the Dorothy installation at $DOROTHY"
			if ! git-helper --path="$DOROTHY" update; then
				echo "...Dorothy was unable to be updated, you will have to figure this out now."
				return 1
			fi
			echo-segment --g2="Updating the Dorothy installation at $DOROTHY"
		}

		# check
		if [[ $action =~ trial|shell|run ]]; then
			# in trial mode, only install dorothy if necessary, do not update
			if test ! -d "$DOROTHY"; then
				install_dorothy
			fi
		else
			# in install and update mode, do whatever is appropriate
			if test -d "$DOROTHY"; then
				update_dorothy
			else
				install_dorothy
			fi
		fi

		# move if necessary, and fix permissions
		relocate_dorothy_if_necessary
	}

	function ensure_machine_configured {
		# sanity check
		if ! [[ $action =~ install ]]; then
			return 29 # ESPIPE 29 Illegal seek
		fi

		# act
		local hostname
		hostname="$(get-hostname)"
		if is-generic "$hostname"; then
			if confirm --bool --ppid=$$ -- "This machine's hostname is currently generic [$hostname], would you like to change it?"; then
				hostname="$(
					ask --question="What should the new hostname be?"
				)"
				if test -n "$hostname"; then
					set-hostname "$hostname"
				else
					echo "Proceeding with the existing hostname: $hostname"
				fi
			fi
		fi
	}

	function ensure_user_configured {
		# sanity check
		if ! [[ $action =~ install|update ]]; then
			return 29 # ESPIPE 29 Illegal seek
		fi

		# helpers
		function install_user {
			# sanity check
			if test -d "$DOROTHY/user"; then
				# should have called update
				return 29 # ESPIPE 29 Illegal seek
			fi

			# prepare
			local question='' user='' where='' cli='' repo_git='' repo_url='' repo_name repo_description local_ip
			repo_name="dotfiles"
			repo_description="My user configuration for the Dorothy dotfile ecosystem: $dorothy_url"

			# check where they want to store the user config
			where="$(
				choose-option --required \
					--question="Where do you want to store your Dorothy user configuration?" \
					-- github gitlab custom 'local'
			)"
			if test "$where" = 'github' && command_exists gh; then
				cli='gh'
			elif test "$where" = 'gitlab' && command_exists glab; then
				cli='glab'
			fi
			if test "$where" = 'github' -o "$where" = 'gitlab'; then
				# prepare username default, and clear generic usernames
				user="$(get-profile username || :)"
				if test -n "$user" && is-generic "$user"; then
					user=''
				fi
				user="$(
					ask --required --confirm \
						--question="Enter your $where username." \
						--default="$user"
				)"

				# check what they want to call the repository
				repo_name="$(
					ask --required \
						--question="Enter the ${where} repository name for your Dorothy user configuration." \
						--default="$repo_name"
				)"
				repo_url="https://$where.com/$user/$repo_name"

				# confirm it exists
				if fetch --ok "$repo_url"; then
					if test -n "$cli"; then
						if "$cli" repo view "$repo_name" | grep --quiet --ignore-case --fixed-strings --regexp="$dorothy_url" || :; then
							echo-style --green+bold="$repo_url" --green=" verified as a Dorothy user configuration repository."
						elif confirm --bool --ppid=$$ -- "$repo_url exists, but does not yet seem to be a Dorothy user configuration repository, would you like to use it anyway (Y), or select an alternative (N)?"; then
							echo-style --blue="^ manually confirmed to use as the Dorothy user configuration repository."
						else
							echo-style --yellow="^ manually elected to use an alternative."
							repo_url=''
						fi
					fi
				else
					echo-style --yellow+bold="$repo_url" --yellow=" does not yet exist, let us create it..."
					if test "$cli" = 'gh'; then
						if ! gh repo create "$repo_name" --description "$repo_description" --homepage "$dorothy_url" --public --confirm --enable-wiki=false; then
							repo_url=''
						fi
					elif test "$cli" = 'glab'; then
						# @todo untested
						if ! glab repo create "$repo_name" --description "$repo_description" --public; then
							repo_url=''
						fi
					fi
				fi
			fi

			# if the repo doesn't exist, get the user to manually create it
			if test -z "$repo_url" -a "$where" != 'local'; then
				if test "$where" = 'github'; then
					open 'https://github.com/new'
				elif test "$where" = 'gitlab'; then
					open 'https://gitlab.com/projects/new#blank_project'
				fi
				question="$(
					cat <<-EOF
						Create a repository for your Dorothy user configuration using the following details.

						Repository name:
						${repo_name}

						Description:
						${repo_description}

						Visibility:
						Public

						Initialize with:
						keep everything unchecked

						Once you have created the repository to house your Dorothy user configuration, type its URL below.
					EOF
				)"
				repo_url="$(
					ask --confirm \
						--question="$question"
				)"
			fi

			# if we have a repo url, then clone it
			if test -n "$repo_url"; then
				# check if it is strongbox
				if fetch --ok "$(git-helper protocol-format "$repo_url" https | sed -E 's#.git$#/raw/master/.strongbox-keyid#')"; then
					echo-style --notice="Strongbox repository detected."
					setup-util-strongbox
					local_ip="$(what-is-my-ip local | echo-first-line || :)"
					question="$(
						cat <<-EOF
							You will now be prompted to update your $(echo-style --code="~/.strongbox_keyring") file.

							If VNC is enabled, run the following on your primary machine to copy the contents:

								$(echo-style --code="cat ~/.strongbox_keyring")
								$(echo-style --code="open vnc://${local_ip}")

							If SSH is enabled, run the following on your primary machine to write the contents:

								$(echo-style --code="cpr -- \"\$HOME/.strongbox_keyring\" \"$(whoami)@${local_ip}:$HOME/.strongbox_keyring\"")

							To enable SSH, do the following on this machine:

								macOS via: System Preferences > Sharing > Remote Login.
								Linux via: $(echo-style --code="bash -ic \"\$(curl -fsSL https://dorothy.bevry.workers.dev/commands/setup-util-sshd)\"")

						EOF
					)"
					if test ! -f "$HOME/.strongbox_keyring" && confirm --ppid=$$ -- "$question"; then
						edit "$HOME/.strongbox_keyring"
					fi
				fi

				# do the clone
				repo_git="$(git-helper protocol-format "$repo_url")"
				if git clone "$repo_git" "$DOROTHY/user"; then
					echo-style --green+bold="$repo_git" --green=" successfully cloned to " --green+bold="$DOROTHY/user"
				else
					echo-style --yellow+bold="$repo_git" --yellow=" failed to clone to " --yellow+bold="$DOROTHY/user"
					echo-style --yellow="We will manually initialise instead."
				fi
			else
				echo-style --yellow="No git repository URL provided, we will manually initialise instead."
			fi

			# if we haven't initialised, then manually initialise
			if test ! -d "$DOROTHY/user"; then
				git_init "$DOROTHY/user"
				echo-style --yellow="Manually initialised git repository at " --yellow+bold="$DOROTHY/user"
			fi
		}
		function update_user {
			echo-segment --h2="Updating the Dorothy user configuration at $DOROTHY/user"
			if ! git-helper --path="$DOROTHY/user" update; then
				echo "...Dorothy user configuration was unable to be updated, you will have to figure this out later..."
			fi
			echo-segment --g2="Updating the Dorothy user configuration at $DOROTHY/user"
		}

		# update or install the user configuration based on its presence
		if test -d "$DOROTHY/user"; then
			# it already exists, so update it
			update_user
		else
			# it doesn't exist, so install it
			install_user
		fi

		# move if necessary, and fix permissions
		relocate_user_if_necessary

		# ensure structure is correct
		adjust_user_configuration
	}

	function adjust_user_configuration {
		local file who name url header content deprecated_configuration_files deprecated_configuration_file

		# deprecations
		# this is done awkardly, as we have no guarantees of being in a bash version that properly supports arrays
		deprecated_configuration_files=''
		for deprecated_configuration_file in \
			"$DOROTHY/user/source.sh" \
			"$DOROTHY/user/source.bash" \
			"$DOROTHY/user/source.zsh" \
			"$DOROTHY/user/source.fish" \
			"$DOROTHY/user/env.sh" \
			"$DOROTHY/user/env.bash" \
			"$DOROTHY/user/env.zsh" \
			"$DOROTHY/user/env.fish"; do
			if test -f "$deprecated_configuration_file"; then
				deprecated_configuration_files="$deprecated_configuration_file"$'\n'"$deprecated_configuration_files"
			fi
		done
		if test -n "$deprecated_configuration_files"; then
			cat <<-EOF
				Dorothy has moved away from one configuration file for everything, into specialised configuration files.

				Migration details can be found here:
				https://github.com/bevry/dorothy/discussions/24

				The following files will need to be migrated:
				${deprecated_configuration_files}
			EOF
		fi

		# create essential directories
		mkdir -p \
			"$DOROTHY/user/commands.local" \
			"$DOROTHY/user/commands" \
			"$DOROTHY/user/config.local" \
			"$DOROTHY/user/config"

		# ensure README.md mentions dorothy
		file="$DOROTHY/user/README.md"
		if ! (test -f "$file" && grep --quiet --ignore-case --fixed-strings --regexp="$dorothy_url" "$file"); then
			# README.md does not mention dorothy, time to add it
			name="$(get-profile name || get-profile username || :)"
			url="$(get-profile url || :)"
			if test -n "$name" -a -n "$url"; then
				who="[${name}'s](${url})"
			elif test -n "$name"; then
				who="${name}'s"
			else
				who='my'
			fi
			header="$(
				cat <<-EOF
					# Dorothy User Configuration

					This is ${who} user configuration for the [Dorothy](${dorothy_url}) dotfile ecosystem.
				EOF
			)"
			if test ! -f "$file"; then
				echo "$header" >"$file"
			else
				content="$(cat "$file")"
				printf '%s\n\n%s' "$header" "$content" >"$file"
			fi
		fi

		# gitignore
		config-helper --file="$DOROTHY/user/.gitignore" -- \
			--find='commands.local[/]' --replace='commands.local/' \
			--find='config.local[/]' --replace='config.local/'
	}

	function ensure_shell_configured {
		echo
		echo 'Dorothy will now confirm the modifications required to have it be loaded by your shell.'
		echo
		rm_deprecated "$HOME/.profile"
		rm_deprecated "$HOME/.bash_profile"
		rm_deprecated "$HOME/.bashrc"
		rm_deprecated "$ZDOTDIR/.zshrc"
		rm_deprecated "$ZDOTDIR/.zprofile"
		rm_deprecated "$HOME/.config/fish/config.fish"
		echo

		if confirm --positive --ppid=$$ -- "Would you like bash to use Dorothy?"; then
			# mac and raspi ubuntu
			config-helper --file="$HOME/.bash_profile" -- \
				--find='source ".+?" # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"

			# vm ubuntu
			config-helper --file="$HOME/.bashrc" -- \
				--find='source ".+?" # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"
		fi

		# https://zsh.sourceforge.io/Intro/intro_3.html
		if confirm --positive --ppid=$$ -- "Would you like zsh to use Dorothy?"; then
			mkdir -p "$ZDOTDIR"

			config-helper --file="$ZDOTDIR/.zshrc" -- \
				--find='source ".+?" # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"

			config-helper --file="$ZDOTDIR/.zprofile" -- \
				--find='source ".+?" # Dorothy' --replace="source \"$DOROTHY/init.sh\" # Dorothy"

			config-helper --file="$HOME/.zshenv" -- \
				--find='ZDOTDIR=.+' --replace="ZDOTDIR=\"$ZDOTDIR\""
		fi

		if confirm --positive --ppid=$$ -- "Would you like fish to use Dorothy?"; then
			mkdir -p "$HOME/.config/fish"
			config-helper --file="$HOME/.config/fish/config.fish" -- \
				--find='source ".+?" # Dorothy' --replace="source \"$DOROTHY/init.fish\" # Dorothy"
		fi
	}

	function remove_shell_configuration {
		# bash
		config-helper --file="$HOME/.bash_profile" -- \
			--find='source ".+?" # Dorothy' --replace=''
		config-helper --file="$HOME/.bashrc" -- \
			--find='source ".+?" # Dorothy' --replace=''

		# zsh
		mkdir -p "$ZDOTDIR"
		config-helper --file="$ZDOTDIR/.zshrc" -- \
			--find='source ".+?" # Dorothy' --replace=''
		config-helper --file="$ZDOTDIR/.zprofile" -- \
			--find='source ".+?" # Dorothy' --replace=''
		config-helper --file="$HOME/.zshenv" -- \
			--find='ZDOTDIR=.+' --replace="ZDOTDIR=\"$ZDOTDIR\""

		# fish
		mkdir -p "$HOME/.config/fish"
		config-helper --file="$HOME/.config/fish/config.fish" -- \
			--find='source ".+?" # Dorothy' --replace=''
	}

	# =====================================
	# Actions: Install, Update, Trial

	function act_install {
		ensure_dorothy_configured
		assert_dorothy_configured
		ensure_minimal_dependencies

		echo-segment --h1='Install Dorothy'
		ensure_machine_configured
		ensure_user_configured
		ensure_shell_configured
		echo-segment --g1='Install Dorothy'

		# log success
		echo-style --success='Dorothy is now setup.' ' ' --notice='Restart your terminal.'
	}

	function act_uninstall {
		ensure_dorothy_configured
		assert_dorothy_configured
		ensure_minimal_dependencies

		echo-segment --h1='Uninstall Dorothy'
		remove_shell_configuration
		echo-segment --g1='Uninstall Dorothy'

		# log success and instructions for removal
		echo-style --success='Dorothy is now uninstalled.' ' ' --notice='Restart your terminal.'
		local paths=()
		if test -d "$DOROTHY"; then
			paths+=("$DOROTHY")
		fi
		if test -d "$DOROTHY/user"; then
			paths+=("$(fs-realpath -- "$DOROTHY/user")")
		fi
		if test "${#paths[@]}" -ne 0; then
			echo 'Once you have restarted your terminal, you can delete Dorothy by removing the following paths:'
			echo-lines "${paths[@]}"
		fi
	}

	function act_update {
		assert_dorothy_configured
		ensure_minimal_dependencies

		echo-segment --h1='Update Dorothy'
		ensure_dorothy_configured
		ensure_user_configured
		echo-segment --g1='Update Dorothy'
	}

	function act_trial {
		act_shell --theme=trial "$@"
	}

	# eval "$(curl -fsSL https://dorothy.bevry.me/try)"
	# eval "$(curl -fsSL https://dorothy.bevry.workers.dev)"
	# bash eval "$(curl -fsSL https://dorothy.bevry.workers.dev)"
	#
	# default to [shell=bash] instead of [sh] as [sh] is [dash] on ubuntu, and [dash] doesn't support the [--...] args
	# [bash --rcfile] works but not within a [--rcfile]
	function act_shell {
		# process arguments
		local item shell='bash' theme=''
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--shell='*) shell="${item#*--shell=}" ;;
			'--theme='*) theme="${item#*--theme=}" ;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) help "An unrecognised argument was provided: $item" ;;
			esac
		done

		# prepare
		ensure_dorothy_configured
		assert_dorothy_configured
		ensure_minimal_dependencies

		# compatibility
		if command_missing "$shell"; then
			echo-error "$shell is not available on this system"
			return 3 # ESRCH 3 No such process
		fi

		# interactive bash prompt
		# [--login] ignores [--rcfile]
		# this is not a true login shell, as [$0] is not [-bash], as such loading [init.sh] is incompatible
		# without [env -i] which would wipe [USER/HOME/DOROTHY], then this shell will inherit exports from the current environment
		# [environment.sh] is sourced as many variables that are not exported must be loaded
		if [[ $shell == *bash ]]; then
			# trunk-ignore(shellcheck/SC2028)
			"$shell" --rcfile <(echo "
				#!/usr/bin/env bash
				DOROTHY_LOAD=yes
				DOROTHY_LOADED=no
				DOROTHY_THEME_OVERRIDE='$theme'
				. '$DOROTHY/init.sh'
				echo-style 'Your are now using the ' --code='$ACTIVE_SHELL' ' shell with Dorothy loaded from ' --code='$DOROTHY' \$'\n' 'Use the ' --code='exit' ' command to return to your parent shell.' \$'\n' 'Use ' --code='ls $DOROTHY/commands' ' to see available commands.'
			")
		elif [[ $shell == *fish ]]; then
			"$shell" --interactive --login --no-config --init-command="$(
				cat <<-EOF
					#!/usr/bin/env fish
					set DOROTHY_THEME_OVERRIDE '$theme'
					source '$DOROTHY/init.fish'
					echo-style 'Your are now using the ' --code='$ACTIVE_SHELL' ' shell with Dorothy loaded from ' --code='$DOROTHY' \n 'Use the ' --code='exit' ' command to return to your parent shell.' \n 'Use ' --code='ls $DOROTHY/commands' ' to see available commands.'
				EOF
			)"
		else
			echo-error "$shell cannot be trialed by " --code='dorothy shell' ' as it does not support trialling a REPL with a custom configuration'
			return 93 # EPROTONOSUPPORT 93 Protocol not supported
		fi
	}

	# bash -ic "$(curl -fsSL https://dorothy.bevry.me/commands/what-is-my-ip)"
	# bash -ilc "$(curl -fsSL https://dorothy.bevry.me/install)"
	# bash -ic "$(curl -fsSL https://dorothy.bevry.me/commands/confirm)" --ppid=$$ --positive -- "Did you see this?"
	# bash -ic "$(curl -fsSL https://raw.githubusercontent.com/bevry/dorothy/master/commands/what-is-my-ip)"
	# bash -ic "$(curl -fsSL https://raw.githubusercontent.com/bevry/dorothy/master/commands/confirm)" --ppid=$$ --positive -- "Did you see this?"
	function act_run {
		# process arguments
		local item args=()
		while test "$#" -ne 0; do
			item="$1"
			shift
			case "$item" in
			'--')
				args+=("$@")
				shift $#
				break
				;;
			'--'*) help "An unrecognised flag was provided: $item" ;;
			*) help "An unrecognised argument was provided: $item" ;;
			esac
		done

		# prepare
		{
			ensure_dorothy_configured
			assert_dorothy_configured
			ensure_minimal_dependencies
		} >/dev/stderr # don't conflate stdout, don't use /dev/tty as tty doesn't exist on CI

		# run the command, inheriting our preconfigured environment
		("${args[@]}")
	}

	# =====================================
	# Actions: ...

	function act_permissions {
		assert_dorothy_configured
		ensure_minimal_dependencies

		echo-segment --h1='Correct Dorothy Permissions'
		ensure_permissions_configured
		echo-segment --g1='Correct Dorothy Permissions'
	}

	function act_edit {
		assert_dorothy_and_user_cloned
		# ensure_minimal_dependencies
		# ^ if they are editing, then we assume they are already setup

		echo-segment --h1='Edit Dorothy'
		ensure_permissions_configured
		if test "$(edit --dry)" == 'code'; then
			code -- "$DOROTHY/.vscode/workspace.code-workspace"
		else
			edit -- "$DOROTHY"
		fi
		echo-segment --g1='Edit Dorothy'
	}

	function act_review {
		assert_dorothy_and_user_cloned
		ensure_minimal_dependencies

		echo-segment --h1='Review Dorothy'
		ensure_permissions_configured
		git-helper review "$DOROTHY/user" || :
		git-helper review "$DOROTHY" || :
		echo-segment --g1='Review Dorothy'
	}

	function act_theme {
		assert_dorothy_and_user_cloned
		ensure_minimal_dependencies

		# features
		echo-segment --h1='Select Dorothy Theme'
		local themes theme files
		source "$DOROTHY/sources/config.sh"
		require_array 'mapfile'

		# prepare
		mapfile -t files < <(echo-lines -- "$DOROTHY/themes/"*.* "$DOROTHY/user/themes/"*.* | echo-filenames | uniq)
		themes=(
			system
			"${files[@]}"
		)

		# ask
		theme="$(
			choose-option --required \
				--question='Which theme to use?' \
				-- "${themes[@]}"
		)"

		# apply
		source "$DOROTHY/sources/config.bash"
		update_dorothy_user_config 'interactive.sh' -- \
			--find='export DOROTHY_THEME=(.*)' --replace="export DOROTHY_THEME=$(echo-quote "$theme")"

		# log
		echo-style --success='Configuration change applied, ' --notice='restart your terminal for the change to take effect.'
		echo-segment --g1='Select Dorothy Theme'
	}

	function act_dev {
		assert_dorothy_configured

		# log
		echo-segment --h1='Dorothy Development'

		# install
		if is-ci; then
			ensure_development_dependencies --no-quiet
		else
			# local dev, upgrade and add git hook
			ensure_development_dependencies --no-quiet --upgrade
			printf 'trunk check --no-progress --trigger=git-push\n' >"$DOROTHY/.git/hooks/pre-push"
		fi

		# versions
		eval-helper --no-quiet -- bash --version
		eval-helper --no-quiet -- prettier --version
		eval-helper --no-quiet -- rg --version
		eval-helper --no-quiet -- shellcheck --version
		eval-helper --no-quiet -- shfmt --version
		eval-helper --no-quiet -- trunk --version

		# log
		echo-segment --g1='Dorothy Development'
	}

	function act_format {
		assert_dorothy_configured

		echo-segment --h1='Dorothy Format'
		ensure_development_dependencies

		# adjust for ci
		local args=()
		if test -n "${CI-}"; then
			args+=('--no-progress')
		fi

		# action
		echo-segment --h2='Running Formatter'
		# on dorothy
		pushd "$DOROTHY" >/dev/null
		trunk fmt --all "${args[@]}"
		popd >/dev/null
		# on user configuration
		if test -d "$DOROTHY/user/.trunk"; then
			pushd "$DOROTHY/user" >/dev/null
			trunk fmt --all "${args[@]}"
			popd >/dev/null
		fi
		echo-segment --g2='Running Formatter'

		echo-segment --g1='Dorothy Format'
	}

	function act_check {
		assert_dorothy_configured

		echo-segment --h1='Dorothy Lint'
		ensure_development_dependencies

		# adjust for ci
		local args=()
		if test -n "${CI-}"; then
			args+=('--no-progress')
		fi

		# action
		echo-segment --h2='Running Checks'
		# on dorothy
		pushd "$DOROTHY" >/dev/null
		trunk check --all "${args[@]}"
		popd >/dev/null
		# on user configuration
		if test -d "$DOROTHY/user/.trunk"; then
			pushd "$DOROTHY/user" >/dev/null
			trunk check --all "${args[@]}"
			popd >/dev/null
		fi
		echo-segment --g2='Running Checks'

		echo-segment --g1='Dorothy Lint'
	}

	function act_lint {
		assert_dorothy_configured

		echo-segment --h1='Dorothy Lint'
		ensure_development_dependencies

		# adjust for ci
		local args=()
		if test -n "${CI-}"; then
			args+=('--no-progress')
		fi

		# action
		echo-segment --h2='Running Lint'
		# on dorothy
		echo-segment --h3="$DOROTHY"
		pushd "$DOROTHY" >/dev/null
		trunk upgrade # always upgrade as still buggy
		trunk fmt --all "${args[@]}"
		trunk check --all "${args[@]}"
		popd >/dev/null
		echo-segment --g3="$DOROTHY"
		# on user configuration
		if test -d "$DOROTHY/user/.trunk"; then
			echo-segment --h3="$DOROTHY/user"
			pushd "$DOROTHY/user" >/dev/null
			trunk upgrade # always upgrade as still buggy
			trunk fmt --all "${args[@]}"
			trunk check --all "${args[@]}"
			popd >/dev/null
			echo-segment --g3="$DOROTHY/user"
		fi
		echo-segment --g2='Running Lint'

		echo-segment --g1='Dorothy Lint'
	}

	function act_test {
		local filepath filename
		assert_dorothy_configured
		# ^ no need for user config for tests

		# able to test on bash v3?
		local bash bashv3=''
		bash="$(command -v bash)"
		if is_mac && test "$bash" != '/bin/bash' && [[ "$(/bin/bash --version || :)" == 'GNU bash, version 3.'* ]]; then
			bashv3='/bin/bash'
		fi

		# dependencies
		source "$DOROTHY/sources/ripgrep.bash"

		# log
		echo-segment --h1='Dorothy Tests'
		pushd "$DOROTHY" >/dev/null

		# check recursion
		# local commands
		# commands=("$DOROTHY/commands/"*)
		# for filepath in "${commands[@]}"; do
		# 	filename="$(basename "$filepath")"

		# 	# skip tests on these
		# 	if test "$filename" = 'dorothy'; then
		# 		continue
		# 	fi

		# 	echo-segment --h2="$filename"
		# 	rg --only-matching --regexp=".*$filename.*" "$filepath" || :
		# 	echo-segment --g2="$filename"
		# done

		# run tests on commands that have them
		while read -r filepath; do
			filename="$(basename "$filepath")"

			# skip tests on these
			if test "$filename" = 'dorothy'; then
				continue
			fi

			# run the bash test
			eval-helper --no-quiet --wrap -- "$bash" "$filepath" --test

			# skip bash v3 test on these
			if test "$filename" = 'get-installer'; then
				continue
			fi

			# run the bash v3 test
			if test -n "$bashv3"; then
				eval-helper --no-quiet --wrap -- "$bashv3" "$filepath" --test
			fi
		done < <(rg --files-with-matches --regexp '--test' "$DOROTHY" | sort)

		# log
		popd >/dev/null
		echo-segment --g1='Dorothy Tests'

	}

	# =====================================
	# Act

	# ensure the prerequisites are installed in case the user skipped them
	ensure_prereq_dependencies >/dev/stderr # don't conflate stdout, don't use /dev/tty as tty doesn't exist on CI

	# all helpers are defined, and argument overrides are handled
	# so prepare the local environment context with what is necessary for dorothy
	# such that the following [choose-option] will be found
	prepare_dorothy >/dev/stderr # don't conflate stdout, don't use /dev/tty as tty doesn't exist on CI

	if test "$(type -t "act_$action")" = 'function'; then
		# bash v3 compat
		if test "${#args[@]}" -eq 0; then
			"act_$action"
		else
			"act_$action" "${args[@]}"
		fi
	else
		echo-style --error="Action [$action] not yet implemented." >/dev/stderr
		return 78 # ENOSYS 78 Function not implemented
	fi

)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	dorothy "$@"
fi
