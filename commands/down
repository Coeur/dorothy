#!/usr/bin/env bash

function down() (
	source "$DOROTHY/sources/bash.bash"
	source "$(type -P eval-helper)"

	# supported tools
	local tool available_tools=() all_tools=(
		got    # nice progress bar
		wget   # nice progress bar
		httpie # progress bar is too sporadic
		aria2c # progress bar doesn't play well with eval-helper
		curl   # complex progress bar
	)

	# determine which tools are available
	for tool in "${all_tools[@]}"; do
		if command-exists "$tool"; then
			available_tools+=("$tool")
		fi
	done
	tool=''

	# if no tools are available, install preference
	if test "${#available_tools[@]}" -eq 0; then
		get-installer --first-success --invoke --quiet -- "${all_tools[@]}"
		down "$@"
		return
	fi

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Download a file, using the best available tool, and with the best available options.

			USAGE:
			down [...options] <url>

			OUTPUTS:
			Progress to tty.
			Errors to stderr.
			Downloaded filepath to stdout.

			OPTIONS:
			--tool=<tool>
			    Enforce the usage of <tool> to download the file.
			    If omitted, the first available preferred tool will be used.

			--unzip-format=<format>
			    Treat the download as a zip file, and enforce <format> as the extraction format.
			    This option is handled by the [unziptar] command.

			--unzip-filter=<filter>
			    Treat the download as a zip fie, and only extract files that match the glob pattern <filter>.
			    This option is handled by the [unziptar] command.

			--bearer-token=<token>
			    If provided, include this in a bearer token header.

			--directory=<directory>
			    Place downloaded file(s) inside <directory>.
			    If ommitted, the current working directory will be used.

			--file=<file>
			    If only a single file was downloaded, rename it to <file>.
			    If multiple files were downloaded, then fail.

			--filepath=<directory>/<file>
			    If only a single file was downloaded, rename it to <file>, and place it inside <directory>.
			    If multiple files were downloaded, then fail.

			--retry=<retries>
			    How many times to retry the download.
			    Defaults to 2.

			--[no-]quiet
			    Whether or not output should be simplified, defaults to enabled.

			TOOLS:
			The following download tools, sorted by order of preference, were determined to be available on your system:

			    ${available_tools[*]}

		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item url='' tool='' unzip_format='' unzip_filter='' directory='' file='' filepath='' retry='2' quiet='yes' option_bearer_token=''
	quiet="$(echo-quiet "$quiet" -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--bearer-token='*) option_bearer_token="${item#*--bearer-token=}" ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		'--tool='*) tool="${item#*--tool=}" ;;
		'--unzip-format='*) unzip_format="${item#*--unzip-format=}" ;;
		'--unzip-filter='*) unzip_filter="${item#*--unzip-filter=}" ;;
		'--directory='*) directory="${item#*--directory=}" ;;
		'--file='*) file="${item#*--file=}" ;;
		'--filepath='*) filepath="${item#*--filepath=}" ;;
		'--retry='*) retry="${item#*--retry=}" ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*)
			if test -z "$url"; then
				url="$item"
			else
				help "An unrecognised argument was provided: $item"
			fi
			;;
		esac
	done

	# assert url
	if test -z "$url"; then
		help "No URL was provided."
	fi

	# ensure tool
	if test -z "$tool"; then
		tool="${available_tools[0]}"
	elif ! is-needle "$tool" "${available_tools[@]}"; then
		help "The specified tool is not available: $tool"
	fi

	# ensure directory, filename, path
	if test -n "$filepath"; then
		# filepath is a directory + file combination
		filepath="$(fs-absolute -- "$filepath")"
		directory="$(dirname "$filepath")"
		file="$(basename "$filepath")"
	elif test -n "$directory" -a -n "$file"; then
		# directory + file
		filepath="$(fs-absolute -- "$directory/$file")"
		directory="$(dirname "$filepath")"
		file="$(basename "$filepath")"
	elif test -z "$directory" -a -n "$file"; then
		# file, without directory
		filepath="$(pwd)/$file"
		directory="$(dirname "$filepath")"
		file="$(basename "$filepath")"
	elif test -n "$directory" -a -z "$file"; then
		# directory, without file
		directory="$(fs-absolute -- "$directory")"
		filepath='' # it is for dir+file combos only
	else
		directory="$(pwd)"
		filepath='' # it is for dir+file combos only
	fi
	mkdir -p "$directory"

	# =====================================
	# Action

	function act {
		# if zip, then download to a temporary/random directory first, filename must be valid but keep extension for unziptar (so trim special)
		local download_directory download_file
		if test -n "$unzip_format" -o -n "$unzip_filter"; then
			local url_basename
			url_basename="$(basename "$url" | echo-trim-special)"
			download_directory="$(fs-temp --directory='down' --directory)"
			download_file="$url_basename"
		else
			download_directory="$directory"
			download_file="$file" # can be empty
		fi
		mkdir -p "$download_directory"

		# tool helpers
		function do_aria2c {
			local aria2c_options=(
				--dir="$download_directory"
				--file-allocation=none
				--allow-overwrite=true
				--always-resume=true
				--auto-file-renaming=false
				--show-console-readout=false
				--summary-interval=1
				--no-conf
			)
			if test -n "$option_bearer_token"; then
				aria2c_options+=(
					"--header=Authorization: Bearer $option_bearer_token"
				)
			fi
			if test -n "$download_file"; then
				aria2c_options+=(
					--out="$download_file"
				)
			fi
			aria2c_options+=("$url")
			aria2c "${aria2c_options[@]}"
		}
		function do_curl {
			local curl_options=('-L')
			if test -n "$option_bearer_token"; then
				curl_options+=(
					'--header'
					"Authorization: Bearer $option_bearer_token"
				)
			fi
			if test -n "$download_file"; then
				curl_options+=(-o "$download_file")
			else
				curl_options+=(-O)
			fi
			curl_options+=("$url")
			(
				cd "$download_directory"
				curl "${curl_options[@]}"
			)
		}
		function do_got {
			# https://github.com/melbahja/got#command-line-tool-usage
			local got_options=()
			if test -n "$option_bearer_token"; then
				got_options+=(
					'--header'
					"Authorization: Bearer $option_bearer_token"
				)
			fi
			if test -n "$download_file"; then
				got_options+=(-o "$download_file")
			fi
			got_options+=("$url")
			(
				cd "$download_directory"
				got "${got_options[@]}"
			)
		}
		function do_httpie {
			# https://httpie.io/docs/cli/download-mode
			local http_options=('-dc')
			if test -n "$option_bearer_token"; then
				got_options+=(
					'--auth'
					"Bearer $option_bearer_token"
				)
			fi
			if test -n "$download_file"; then
				http_options+=(
					-o "$download_file"
				)
			fi
			http_options+=("$url")
			(
				cd "$download_directory"
				http "${http_options[@]}"
			)
		}
		function do_wget() (
			#   -O,  --output-document=FILE      write documents to FILE
			#   -o,  --output-file=FILE          log messages to FILE
			#   -N,  --timestamping              don't re-retrieve files unless newer than local
			#   -c,  --continue                  resume getting a partially-downloaded file
			#   -q,  --quiet                     quiet (no output)
			#   -v,  --verbose                   be verbose (this is the default)
			#   -nv, --no-verbose                turn off verboseness, without being quiet
			#        --show-progress             display the progress bar in any verbosity mode
			# WARNING: timestamping does nothing in combination with -O. See the manual for details.
			local wget_options=()
			if test "$option_bearer_token"; then
				options+=(
					"--header=Authorization: Bearer $option_bearer_token"
				)
			fi
			if test -n "$download_file"; then
				wget_options+=(
					"--output-document=$download_file"
				)
			else
				wget_options+=(
					--timestamping
				)
			fi
			wget_options+=("$url")
			(
				cd "$download_directory"
				wget "${wget_options[@]}"
			)
		)
		function do_download {
			if test "$(type -t "do_$tool")" = 'function'; then
				"do_$tool"
			else
				help "Unrecognised tool: $tool"
			fi
		}

		# invoke the download with retry support, capturing exit codes
		local download_status
		while test "$retry" -ge 0; do
			eval_capture --statusvar=download_status -- do_download
			if test "$download_status" -eq 0; then
				break
			fi
			retry=$((retry - 1))
		done

		# double confirm it was created, in case exit code passed but it still was not created
		if test -n "$download_file"; then
			if is-missing "$download_directory/$download_file"; then
				echo-error "Failed to download " --code="$url" ' to ' --code="$download_directory/$download_file"
				return 1
			fi
		fi

		# log
		echo-style --success="Downloaded!"

		# if desired, perform extraction of the temporary file
		if test -n "$unzip_format" -o -n "$unzip_filter"; then
			echo-style --notice="Unzipping..."
			unziptar "$download_directory/$download_file" \
				--prune \
				--directory="$directory" \
				--file="$file" \
				--filepath="$filepath" \
				--format="$unzip_format" \
				--filter="$unzip_filter"

			# check extraction
			if test -n "$file"; then
				# assert it was created
				if is-missing "$filepath"; then
					echo-error "Failed to extract " --code="$url" ' to ' --code="$filepath"
					return 1
				fi
			fi
		fi

		# log
		echo-style --success="Extracted!"
	}

	# messages
	local pending="Downloading"
	local success="Downloaded"
	local failure="Failed to download"
	if test -n "$unzip_format" -o -n "$unzip_filter"; then
		pending="Downloading and extracting"
		success="Downloaded and extracted"
		failure="Failed to download and extract"
	fi

	# act
	eval_helper --quiet="$quiet" --no-wrap \
		--pending="$(
			echo-style --bold="$pending " \
				--code="$url" " to " --code="$directory/$file"
		)" \
		--success="$(
			echo-style --success="$success " \
				--code="$url" " to " --code="$directory/$file"
		)" \
		--failure="$(
			echo-style --error="$failure " \
				--code="$url" " to " --code="$directory/$file"
		)" \
		-- act
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	down "$@"
fi
