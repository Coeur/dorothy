#!/usr/bin/env bash

function echo_clear_lines() (
	source "$DOROTHY/sources/bash.bash"

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Deletes as many lines as it received.

			USAGE:
			echo 'sup'; printf 'a\nb\nc' | echo-clear-lines --piped
			# ^ outputs: sup

			header="\$(mktemp)"; echo 'sup'; printf 'a\nb\nc' | tee "\$header"; echo-clear-lines < "\$header"
			# ^ outputs: sup
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# test cases:
	# confirm --ppid=$$ -- "Press <enter> once you are ready to continue..."
	# ^ without \e[J it will have an indentation at the start

	local piped='no'
	if test "${1-}" = '--piped'; then
		piped='yes'
		shift
	fi
	function on_arg {
		help "$0: does not support arguments, use stdin only"
	}
	function on_line {
		# if we are piping (there is newline we want to keep from pressing return in the terminal), or if the input is deleting rather than clearing lines, then we can only safely clear the current line
		# touch test.txt; fs-rm --no-confirm --quiet --trash -- test.txt
		# setup-util-sd --uninstall; (create an error in do_brew); setup-util-sd
		if test "$piped" = 'yes' || [[ $1 == *$'\e[J'* || $1 == *$'\e[0J'* || $1 == *$'\e[1J'* || $1 == *$'\e[2J'* || $1 == *$'\e[3J'* ]]; then
			# erase current line
			printf '\e[2K\e[G'
		else
			# delete prior line (aka echo-clear-line)
			printf '\e[F\e[J'
		fi
	}
	function on_inline {
		# erase current line
		printf '\e[2K\e[G'
	}

	local REQUIRE_STDIN=yes
	source "$DOROTHY/sources/stdinargs.bash"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	echo_clear_lines "$@"
fi
