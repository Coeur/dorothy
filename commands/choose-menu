#!/usr/bin/env bash

# QUIRKS:
# - if there are more options than [$LINES - header], then this will fall apart

# TODOS:
# - [ ] limit the options output to [$LINES - header]
# - [ ] if one gets to $LINES, and there are truncated values, then scroll downwards
# - [ ] support $COLUMNS - if a menu item is larger than the column, then it will show all of it when active

function choose_menu_test() (
	source "$DOROTHY/sources/bash.bash"
	echo-segment --h1="TEST: $0"

	# timeout response not required
	eval-tester --name='timeout response not required' --status='60' --stderr='Read timed out [60], without selection.' \
		-- env NO_COLOR=yes choose-menu --question='timeout response not required' --timeout=5 -- a b c

	# timeout response is required
	eval-tester --name='timeout response is required' --status='60' --stderr='Read timed out [60], without selection.' \
		-- env NO_COLOR=yes choose-menu --question='timeout response is required' --timeout=5 --required -- a b c

	# default response
	{
		sleep 3
	} | eval-tester --name='default response' --stdout='1' --ignore-stderr \
		-- choose-menu --question='default response' --timeout=2 --default=b -- a b c

	# default response should clear on movement
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
	} | eval-tester --name='default response should clear on movement' --status='60' --stdout='' --ignore-stderr \
		-- choose-menu --question='default response should clear on movement' --timeout=10 --default=b -- a b c

	# default multi response
	{
		sleep 3
	} | eval-tester --name='default multi response' --stdout=$'1\n2' --ignore-stderr \
		-- choose-menu --question='default multi response' --timeout=2 --multi --default=b --default=c -- a b c

	# default multi response should not clear on movement
	{
		sleep 3
		printf $'\eOB'
		sleep 3
	} | eval-tester --name='default multi response should not clear on movement' --stdout=$'1\n2' --ignore-stderr \
		-- choose-menu --question='default multi response should not clear on movement' --timeout=10 --multi --default=b --default=c -- a b c

	# multiline defaults
	{
		sleep 3
	} | eval-tester --name='default multiline response' --stdout=$'1\n2\n3' --ignore-stderr \
		-- choose-menu --question='default multiline response' --timeout=2 --multi --default=$'b\nB' --defaults=$'c\nd' -- a $'b\nB' c d

	# first selection
	{
		sleep 3
		echo
	} | eval-tester --name='first response' --stdout='0' \
		-- choose-menu --question='first selection' -- a b c

	# second selection
	{
		# move down and select second response
		sleep 3
		printf $'\eOB'
		sleep 3
		echo
	} | eval-tester --name='second response' --stdout='1' \
		-- choose-menu --question='second selection' -- a b c

	# abort response via escape
	{
		# press escape key
		sleep 3
		printf $'\x1b'
	} | eval-tester --name='abort response via escape' \
		-- choose-menu --question='abort response via escape' -- a b c

	echo-segment --g1="TEST: $0"
	return 0
)
function choose_menu() (
	source "$DOROTHY/sources/bash.bash"
	source "$DOROTHY/sources/tty.bash"
	require_array 'mapfile'

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Display a menu that the user can navigate using the keyboard.

			USAGE:
			choose-menu [...options] -- ...<item>

			RETURNS:
			The index of the result

			OPTIONS:
			--default=<value>
			--defaults=<newline separated values>
			    Pre-selected <item>s.

			--question=<question>
			    Question to display as the prompt.

			--timeout=<timeout>
			    Custom timeout value in seconds.

			--[no-]multi=[yes|NO]
			    Multiple items can be selected.

			--[no-]hints=[YES|no]
			    Display interaction hint line.

			--[no-]required=[yes|NO]
			    If required, aborting the menu will not be possible.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item='' items=() defaults=() tmp=() option_question='' option_timeout='' option_multi='no' option_required='no' option_hints='yes' use_colors
	use_colors="$(echo-color yes -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-color'* | '--color'*) ;; # handled by echo-color
		'--default='*) defaults+=("${item#*--default=}") ;;
		'--defaults='*)
			mapfile -t tmp <<<"${item#*--defaults=}"
			defaults+=("${tmp[@]}")
			;;
		'--question='*) option_question="${item#*--question=}" ;;
		'--timeout='*) option_timeout="${item#*--timeout=}" ;;
		'--no-hints'* | '--hints'*)
			option_hints="$(get-flag-value hints --missing="$option_hints" -- "$item" | echo-affirmative --stdin)"
			;;
		'--no-multi'* | '--multi'*)
			option_multi="$(get-flag-value multi --missing="$option_multi" -- "$item" | echo-affirmative --stdin)"
			;;
		'--no-required'* | '--required'*)
			option_required="$(get-flag-value required --missing="$option_required" -- "$item" | echo-affirmative --stdin)"
			;;
		'--')
			items+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# ensure we have items
	if test "${#items[@]}" -eq 0; then
		help 'No <item>s were provided.'
	elif is-array-partial "${items[@]}"; then
		help 'Empty <item>s were provided:' $'\n' "$(echo-verbose -- "${items[@]}")"
	fi

	# prepare
	local count last selections=()
	count="${#items[@]}"
	last="$((count - 1))"
	mapfile -t selections < <(get-array "$count")

	# default selection
	local cursor=0
	local index _default
	if test "${#defaults[@]}" -ne 0; then # bash v3 compat
		if test "${#defaults[@]}" -gt 1 -a "$option_multi" = 'no'; then
			help 'Multiple defaults were provided, but --multi was not set.'
		fi
		for _default in "${defaults[@]}"; do
			for index in "${!items[@]}"; do
				item="${items[index]}"
				if test "$_default" = "$item"; then
					selections[index]='yes'
					if test "$option_multi" = 'no'; then
						cursor="$index"
						break
					fi
				fi
			done
		done
	fi

	# commence
	tty_start
	local read_status menu_status=0 menu='' action='' tty_target
	local magenta=$'\e[35m' bold=$'\e[1m' dim=$'\e[2m' reset=$'\e[0m'
	local help_begin="$dim" help_end="$reset" key_begin key_end=" $reset" indent='  '
	if test "$use_colors" = 'no'; then
		magenta=''
		bold=''
		dim=''
		reset=''
		help_begin=''
		help_end=''
		key_begin='['
		key_end=']'
	elif test "$(get-terminal-theme || :)" = 'dark'; then
		key_begin=$'\e[30m\e[47m ' # foreground black, background white
	else
		key_begin=$'\e[107m ' # foreground default black, background intense white
	fi
	tty_target="$(is-tty --fallback)" had_selected='no'
	while test "$action" != 'done'; do
		menu=''

		# question
		if test -n "$option_question"; then
			menu+="${bold}${option_question}${reset}"$'\n'
		fi

		# show the menu
		had_selected='no'
		for index in "${!items[@]}"; do
			if test "$index" -eq "$cursor"; then
				menu+="$magenta>"
			else
				if test "${selections[index]-}" = 'yes'; then
					menu+=" $magenta"
				else
					menu+=' '
				fi
			fi
			if test "$option_multi" = 'yes'; then
				# one hollow circle: ⚬ ○ ◯ ❍
				# two hollow circles: ◎ ⦾ ⊚
				# one hollow, one full: ☉ ⦿ ◉
				# one full: ●
				# ▣ ▢ □ ⊡
				# ☑ ☒
				# ✓ ✔ ✖  ✗  ✘
				if test "${selections[index]-}" = 'yes'; then
					had_selected='yes'
					menu+=" ⦿ "
				else
					menu+=' ○ '
				fi
			else
				if test "${selections[index]-}" = 'yes'; then
					had_selected='yes'
					menu+=" $bold"
				else
					menu+=' '
				fi
			fi
			menu+="${items[index]}${reset}"$'\n'
		done

		# hints
		if test "$option_hints" = 'yes'; then
			if test "$option_multi" = 'no'; then
				menu+="${help_begin}SELECT${help_end} ${key_begin}ENTER${key_end} ${key_begin}SPACE${key_end}"
			else
				menu+="${help_begin}SELECT${help_end} ${key_begin}SPACE${key_end}"
			fi
			if test "$count" -ne 1; then
				# [⬆⬇⇧] have alignment issues, use [↑↓]
				menu+="${indent}${help_begin}UP${help_end} ${key_begin}↑${key_end} ${key_begin}W${key_end} ${key_begin}K${key_end}"
				menu+="${indent}${help_begin}DOWN${help_end} ${key_begin}↓${key_end} ${key_begin}S${key_end} ${key_begin}J${key_end}"
				if test "$option_multi" = 'yes'; then
					menu+="${indent}${help_begin}ALL${help_end} ${key_begin}A${key_end}"
					menu+="${indent}${help_begin}NONE${help_end} ${key_begin}D${key_end}"
				fi
			fi
			if test "$option_required" = 'no'; then
				menu+="${indent}${help_begin}CANCEL${help_end} ${key_begin}ESC${key_end}"
			fi
		fi

		# output menu
		printf '%s' "$menu" >"$tty_target"

		# handle the response
		eval_capture --statusvar=read_status --stdoutvar=action -- read-key --timeout="$option_timeout"
		if test "$read_status" -eq 60; then
			if test "$had_selected" = 'yes'; then
				tty_clear
				echo-style --colors="$use_colors" --notice="Read timed out [$read_status], using selection." >/dev/stderr
				sleep 3
				break # out of the while loop
			else
				tty_clear
				echo-style --colors="$use_colors" --warning="Read timed out [$read_status], without selection." >/dev/stderr
				sleep 3
				menu_status="$read_status"
				break # out of the while loop
			fi
		elif test "$read_status" -ne 0; then
			# some other failure
			tty_clear
			echo-style --colors="$use_colors" --error="Read failed [$read_status]." >/dev/stderr
			sleep 3
			menu_status="$read_status"
			break # out of the while loop
		fi

		# reset selection if not multi
		if test "$had_selected" = 'yes' -a "$option_multi" = 'no'; then
			for index in "${!selections[@]}"; do
				selections[index]=''
			done
		fi

		# handle special cases and remaps
		# such as numbers, wasd, and vim movers
		if is-digit "$action"; then
			# number jump
			if test "$action" -le 1; then
				cursor=0
			elif test "$action" -le "$count"; then
				cursor="$((action - 1))"
			else
				cursor="$last"
			fi
			action='space'
		elif test "$action" = 'left' -o "$action" = 'h' -o "$action" = 'k' -o "$action" = 'w'; then
			action='up'
		elif test "$action" = 'right' -o "$action" = 'l' -o "$action" = 'j' -o "$action" = 's'; then
			action='down'
		elif test "$action" = 'd' -o "$action" = 'backspace'; then
			action='none'
		elif test "$action" = 'a'; then
			action='all'
		fi

		# control key
		if test "$action" = 'up'; then
			if test "$cursor" -eq 0; then
				cursor="$last"
			elif test "$cursor" -ne 0; then
				cursor="$((cursor - 1))"
			fi
		elif test "$action" = 'down'; then
			if test "$cursor" -eq "$last"; then
				cursor=0
			elif test "$cursor" -ne "$last"; then
				cursor="$((cursor + 1))"
			fi
		elif test "$action" = 'home'; then
			cursor=0
		elif test "$action" = 'end'; then
			cursor="$last"
		elif test "$action" = 'none'; then
			# if multi then unselect everything, other no-op (as any keypress by now would have cleared the non-multi selection)
			if test "$option_multi" = 'yes'; then
				for index in "${!items[@]}"; do
					selections[index]=''
				done
			fi
		elif test "$action" = 'all'; then
			# if multi then select everything, other no-op (as any keypress by now would have cleared the non-multi selection)
			if test "$option_multi" = 'yes'; then
				for index in "${!items[@]}"; do
					selections[index]='yes'
				done
			fi
		elif test "$action" = 'tab'; then
			# select and move to next line
			selections[cursor]='yes'
			if test "$cursor" -eq "$last"; then
				cursor=0
			elif test "$cursor" -lt "$last"; then
				cursor="$((cursor + 1))"
			fi
		elif test "$action" = 'space'; then
			# toggle single
			if test "${selections[cursor]}" = 'yes'; then
				selections[cursor]=''
			else
				selections[cursor]='yes'
				if test "$option_multi" != 'yes'; then
					break
				fi
			fi
		elif test "$action" = 'enter'; then
			if test "$option_multi" != 'yes'; then
				selections[cursor]='yes'
			fi
			break
		elif test "$action" = 'escape'; then
			# todo implement --required with --multi fallback properly here
			if test "$option_required" = 'no'; then
				break
			fi
		fi

		# no break, so repeat the menu
		tty_clear
	done

	# terminate our tty
	tty_finish

	# output the custom selections
	if test "$menu_status" -eq 0; then
		local index selection
		for index in "${!selections[@]}"; do
			selection="${selections[index]}"
			if test "$selection" = 'yes'; then
				print_line "$index"
			fi
		done
	else
		return "$menu_status"
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	if test "$*" = '--test'; then
		choose_menu_test
	else
		choose_menu "$@"
	fi
fi
